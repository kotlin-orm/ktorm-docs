<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Ktorm | 实体查询</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch-css@3.6.2/style.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"实体查询",lang:"zh-cn",related_path:"en/entity-finding.html",path:"zh-cn/entity-finding.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"GETTING STARTED",type:"label",isCurrent:!1},{text:"Overview",type:"link",path:"/",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!0},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",target:"_blank",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]},"navigation-zh-cn":{home:[{title:"快速上手",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"开始",type:"label",isCurrent:!1},{text:"简介",type:"link",path:"zh-cn/",isCurrent:!1},{text:"快速上手",type:"link",path:"zh-cn/quick-start.html",isCurrent:!1},{text:"连接管理",type:"label",isCurrent:!1},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html",isCurrent:!1},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html",isCurrent:!1},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html",isCurrent:!1},{text:"查询",type:"link",path:"zh-cn/query.html",isCurrent:!1},{text:"联表",type:"link",path:"zh-cn/joining.html",isCurrent:!1},{text:"增删改",type:"link",path:"zh-cn/dml.html",isCurrent:!1},{text:"运算符",type:"link",path:"zh-cn/operators.html",isCurrent:!1},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html",isCurrent:!1},{text:"实体类 API",type:"label",isCurrent:!1},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html",isCurrent:!1},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html",isCurrent:!1},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html",isCurrent:!0},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html",isCurrent:!1},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html",isCurrent:!1},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"支持和反馈",type:"label",isCurrent:!1},{text:"API 文档",type:"support-link",path:"api-docs/index.html",target:"_blank",isCurrent:!1},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank",isCurrent:!1},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html",isCurrent:!1}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc"}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation"><nav class="doc-navbar"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="doc-navbar__logo"><a href="/zh-cn/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close"></i><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/entity-finding.html">English</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"></span></button></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>开始</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/" target="_self"><span>简介</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/quick-start.html" target="_self"><span>快速上手</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>连接管理</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/connect-to-databases.html" target="_self"><span>连接数据库</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/transaction-management.html" target="_self"><span>事务管理</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/spring-support.html" target="_self"><span>Spring 支持</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/schema-definition.html" target="_self"><span>定义表结构</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/query.html" target="_self"><span>查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/joining.html" target="_self"><span>联表</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/dml.html" target="_self"><span>增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/operators.html" target="_self"><span>运算符</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/dialects-and-native-sql.html" target="_self"><span>方言与原生 SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>实体类 API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entities-and-column-binding.html" target="_self"><span>实体类与列绑定</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-finding.html" target="_self"><span>实体查询</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-sequence.html" target="_self"><span>实体序列</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/sequence-aggregation.html" target="_self"><span>序列聚合</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-dml.html" target="_self"><span>实体增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/define-entities-as-any-kind-of-classes.html" target="_self"><span>使用任意的类作为实体类</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>支持和反馈</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/api-docs/index.html" target="_blank"><span>API 文档</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank"><span>问题反馈</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/sponsor.html" target="_self"><span>打赏作者</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/entity-finding.html">English</a></span></span></div><div class="dc-page"><div class="dc-card"><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/zh-cn/entity-finding.md"><i class="icon fa fa-github"></i> <span class="text">编辑本页</span></a><h1 id="实体查询"><a class="markdownIt-Anchor" href="#实体查询"></a> 实体查询</h1><p>Ktorm 提供了一套名为”实体序列”的 API，用来从数据库中获取实体对象。正如其名字所示，它的风格和使用方式与 Kotlin 标准库中的序列 API 极其类似，它提供了许多同名的扩展函数，比如 <code>filter</code>、<code>map</code>、<code>reduce</code> 等。</p><h2 id="使用序列-api-获取实体"><a class="markdownIt-Anchor" href="#使用序列-api-获取实体"></a> 使用序列 API 获取实体</h2><p>要使用序列 API，首先要创建实体序列的对象。一般来说，我们会给 <code>Database</code> 定义一些扩展属性，它们使用 <code>sequenceOf</code> 函数创建序列对象并返回。这些属性可以帮助我们提高代码的可读性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Database.departments <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Departments)</span><br><span class="line"><span class="keyword">val</span> Database.employees <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Employees)</span><br></pre></td></tr></table></figure><p>下面的代码使用 <code>find</code> 函数从序列中根据名字获取一个 Employee 对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123; it.name eq <span class="string">&quot;vince&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>这种写法十分自然，就像使用 Kotlin 标准库中的函数从一个集合中筛选符合条件的元素一样，不同的仅仅是在 lambda 表达式中的等号 <code>==</code> 被这里的 <code>eq</code> 函数代替了而已。</p><p><code>find</code> 函数接收一个类型为 <code>(T) -&gt; ColumnDeclaring&lt;Boolean&gt;</code> 的参数，这是一个闭包函数，其中的返回值会作为查询的筛选条件，SQL 执行完毕后，返回结果集中的第一条记录。作为参数的闭包函数本身也接收一个参数 <code>T</code>，这正是当前表对象，因此我们能在闭包中使用 it 引用它。</p><p>上述代码生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.id <span class="keyword">as</span> t_employee_id, t_employee.name <span class="keyword">as</span> t_employee_name, t_employee.job <span class="keyword">as</span> t_employee_job, t_employee.manager_id <span class="keyword">as</span> t_employee_manager_id, t_employee.hire_date <span class="keyword">as</span> t_employee_hire_date, t_employee.salary <span class="keyword">as</span> t_employee_salary, t_employee.department_id <span class="keyword">as</span> t_employee_department_id, _ref0.id <span class="keyword">as</span> _ref0_id, _ref0.name <span class="keyword">as</span> _ref0_name, _ref0.location <span class="keyword">as</span> _ref0_location </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> _ref0.id </span><br><span class="line"><span class="keyword">where</span> t_employee.id <span class="operator">=</span> ? </span><br></pre></td></tr></table></figure><blockquote><p>生成 SQL 中包含了十分长的字段列表，这是有必要的，Ktorm 会尽量避免使用 select *，但是为了展示的方便，以后在文档中出现的 SQL，太长的字段列表会使用 select * 代替。</p></blockquote><p>观察生成的 SQL，我们发现 Ktorm 自动使用外键 left join 了 <code>t_employee</code> 的关联表 <code>t_department</code>。这是因为我们在表对象中声明 <code>departmentId</code> 这一列时使用 <code>references</code> 函数将此列绑定到了 <code>Departments</code> 表。在使用序列 API 的时候，Ktorm 会自动递归地 left join 所有关联的表，将部门表的数据一并查询出来，填充到 <code>Employee.department</code> 属性中。</p><blockquote><p>在使用 <code>references</code> 绑定时请注意避免循环的引用，比如 <code>Employees</code> 表引用了 <code>Departments</code>，则 <code>Departments</code> 不能再直接或间接地引用 <code>Employees</code>，否则会导致 Ktorm 在自动 left join 的过程中出现栈溢出。</p></blockquote><p>既然 Ktorm 会自动 left join 关联表，我们当然也能在筛选条件中使用关联表中的列。下面的代码可以获取一个在广州工作的员工对象，这里我们通过列的 <code>referenceTable</code> 属性获取 <code>departmentId</code> 所引用的表对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123;</span><br><span class="line">    <span class="keyword">val</span> dept = it.departmentId.referenceTable <span class="keyword">as</span> Departments</span><br><span class="line">    dept.location eq <span class="string">&quot;Guangzhou&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让代码看起来优雅一点，我们可以在 <code>Employees</code> 表对象中添加一个 get 属性。下面的代码和上面是完全等价的，但是阅读起来却更加自然：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Employees</span>(alias: String?) : Table&lt;Employee&gt;(<span class="string">&quot;t_employee&quot;</span>, alias) &#123;</span><br><span class="line">    <span class="comment">// 此处省略无关的列定义...</span></span><br><span class="line">    <span class="keyword">val</span> department <span class="keyword">get</span>() = departmentId.referenceTable <span class="keyword">as</span> Departments</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123; it.department.location eq <span class="string">&quot;Guangzhou&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> _ref0.id </span><br><span class="line"><span class="keyword">where</span> _ref0.location <span class="operator">=</span> ? </span><br></pre></td></tr></table></figure><blockquote><p>注意：我们在通过 <code>it.departmentId.referenceTable</code> 获取到引用的表对象后，把它转型成了 <code>Departments</code>，因此这要求我们必须使用 class 而不是 object 定义表对象，并且重写 <code>aliased</code> 函数，具体参见<a href="./joining.html#%E8%87%AA%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E4%B8%8E%E8%A1%A8%E5%88%AB%E5%90%8D">表别名</a>的相关介绍。</p></blockquote><p>除了 <code>find</code> 函数外，实体序列 API 还给我们提供了许多方便的函数，如使用 <code>filter</code> 对元素进行筛选、使用 <code>groupingBy</code> 进行分组聚合等。与 SQL DSL 相比，实体序列 API 更具有函数式风格，其使用方式就像在操作内存中的集合一样，因此我们建议大家优先使用。更多用法请参见<a href="./entity-sequence.html">实体序列</a>和<a href="./sequence-aggregation.html">序列聚合</a>的文档。</p><h2 id="使用查询-dsl-获取实体"><a class="markdownIt-Anchor" href="#使用查询-dsl-获取实体"></a> 使用查询 DSL 获取实体</h2><p>序列 API 会自动 left join 引用表，有时这可能会造成一点浪费。如果你希望对查询进行更细粒度的控制，你可以使用前面章节中介绍的查询 DSL，Ktorm 提供了从查询 DSL 中获取实体对象的方法。</p><p>下面的例子使用 <code>createEntity</code> 函数从查询 DSL 中获取了实体对象的列表：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select()</span><br><span class="line">    .orderBy(Employees.id.asc())</span><br><span class="line">    .map &#123; row -&gt; Employees.createEntity(row) &#125;</span><br><span class="line"></span><br><span class="line">employees.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure><p>在这里，我们使用 <code>map</code> 函数对查询进行迭代，在迭代中使用 <code>createEntity</code> 为每一行返回的记录创建一个实体对象。<code>createEntity</code> 是 <code>Table</code> 类的函数，它会根据表对象中的列绑定配置，自动创建实体对象，从结果集中读取数据填充到实体对象的各个属性中。如果该表使用 <code>references</code> 引用绑定了其它表，也会递归地对所引用的表调用 <code>createEntity</code> 创建关联的实体对象。</p><p>然而，查询 DSL 返回的列是可自定义的，里面不一定包含引用表中的列。针对这种情况，<code>createEntity</code> 函数提供了一个名为 <code>withReferences</code> 的参数，它的值默认是 <code>true。</code>但当我们把它设为 <code>false</code> 时，<code>createEntity</code> 将不再获取引用表关联的实体对象的数据，它会把引用绑定视为到其所引用的实体对象的主键的嵌套绑定，例如 <code>c.references(Departments) &#123; it.department &#125;</code>，在它眼里相当于 <code>c.bindTo &#123; it.department.id &#125;</code>，使用这个参数可避免一些不必要的对象创建。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employees.createEntity(row, withReferences = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>但是在上面的查询中，因为我们并没有联表，因此不管我们把 <code>withReferences</code> 参数设置成什么，都会生成一句简单的 SQL <code>select * from t_employee order by t_employee.id</code>，打印出同样的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee&#123;id=1, name=vince, job=engineer, hireDate=2018-01-01, salary=100, department=Department&#123;id=1&#125;&#125;</span><br><span class="line">Employee&#123;id=2, name=marry, job=trainee, manager=Employee&#123;id=1&#125;, hireDate=2019-01-01, salary=50, department=Department&#123;id=1&#125;&#125;</span><br><span class="line">Employee&#123;id=3, name=tom, job=director, hireDate=2018-01-01, salary=200, department=Department&#123;id=2&#125;&#125;</span><br><span class="line">Employee&#123;id=4, name=penny, job=assistant, manager=Employee&#123;id=3&#125;, hireDate=2019-01-01, salary=100, department=Department&#123;id=2&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="joinreferencesandselect"><a class="markdownIt-Anchor" href="#joinreferencesandselect"></a> joinReferencesAndSelect</h2><p><code>joinReferencesAndSelect</code> 是 <code>QuerySource</code> 的扩展函数，它创建一个 <code>Query</code> 对象，这个查询递归地 left join 当前表对象的所有关联表，并且 select 出它们的所有列。你可以直接从这个返回的 <code>Query</code> 对象中获取所有的记录，也可以紧接着调用 <code>Query</code> 类的其他扩展方法修改这个查询。实际上，实体序列 API 就是基于这个函数实现自动联表的。</p><p>下面是一个使用示例，这个查询获取所有的员工及其所在的部门的信息，并按员工的 ID 进行排序：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .joinReferencesAndSelect()</span><br><span class="line">    .orderBy(Employees.id.asc())</span><br><span class="line">    .map &#123; row -&gt; Employees.createEntity(row) &#125;</span><br></pre></td></tr></table></figure><p>生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> _ref0.id </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t_employee.id </span><br></pre></td></tr></table></figure><p>从生成的 SQL 中可以看出，上面的查询实际上相当于手动调用 <code>leftJoin</code> 函数，例如下面的代码与上面例子中的查询就是完全等价的，但是使用 <code>joinReferencesAndSelect</code> 可以为我们减少一些样板代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> emp = Employees</span><br><span class="line"><span class="keyword">val</span> dept = emp.departmentId.referenceTable <span class="keyword">as</span> Departments</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> employees = database</span><br><span class="line">    .from(emp)</span><br><span class="line">    .leftJoin(dept, on = emp.departmentId eq dept.id)</span><br><span class="line">    .select(emp.columns + dept.columns)</span><br><span class="line">    .orderBy(emp.id.asc())</span><br><span class="line">    .map &#123; row -&gt; emp.createEntity(row) &#125;</span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer"><div class="doc-footer-link">上一篇：<a href="/zh-cn/entities-and-column-binding.html">实体类与列绑定</a></div><div class="doc-footer-link">下一篇：<a href="/zh-cn/entity-sequence.html">实体序列</a></div>对文档内容有疑问？请在侧边栏尝试搜索或者在 GitHub <a href="https://github.com/kotlin-orm/ktorm/issues/new">提出 issue</a></div></div></article></div></div><div class="doc-footer">&copy; 2024 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script></body></html>