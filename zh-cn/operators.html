<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Ktorm | 运算符</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch-css@3.6.2/style.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"运算符",lang:"zh-cn",related_path:"en/operators.html",path:"zh-cn/operators.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"GETTING STARTED",type:"label",isCurrent:!1},{text:"Overview",type:"link",path:"/",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",target:"_blank",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!0}]},"navigation-zh-cn":{home:[{title:"快速上手",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"开始",type:"label",isCurrent:!1},{text:"简介",type:"link",path:"zh-cn/",isCurrent:!0},{text:"快速上手",type:"link",path:"zh-cn/quick-start.html",isCurrent:!1},{text:"连接管理",type:"label",isCurrent:!1},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html",isCurrent:!1},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html",isCurrent:!1},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html",isCurrent:!1},{text:"查询",type:"link",path:"zh-cn/query.html",isCurrent:!1},{text:"联表",type:"link",path:"zh-cn/joining.html",isCurrent:!1},{text:"增删改",type:"link",path:"zh-cn/dml.html",isCurrent:!1},{text:"运算符",type:"link",path:"zh-cn/operators.html",isCurrent:!1},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html",isCurrent:!1},{text:"实体类 API",type:"label",isCurrent:!1},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html",isCurrent:!1},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html",isCurrent:!1},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html",isCurrent:!1},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html",isCurrent:!1},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html",isCurrent:!1},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"支持和反馈",type:"label",isCurrent:!1},{text:"API 文档",type:"support-link",path:"api-docs/index.html",target:"_blank",isCurrent:!1},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank",isCurrent:!1},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html",isCurrent:!1}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc"}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation"><nav class="doc-navbar"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="doc-navbar__logo"><a href="/zh-cn/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close"></i><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/operators.html">English</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"></span></button></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>开始</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/" target="_self"><span>简介</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/quick-start.html" target="_self"><span>快速上手</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>连接管理</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/connect-to-databases.html" target="_self"><span>连接数据库</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/transaction-management.html" target="_self"><span>事务管理</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/spring-support.html" target="_self"><span>Spring 支持</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/schema-definition.html" target="_self"><span>定义表结构</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/query.html" target="_self"><span>查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/joining.html" target="_self"><span>联表</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/dml.html" target="_self"><span>增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current doc-sidebar-list__item--no-children"><a href="/zh-cn/operators.html" target="_self"><span>运算符</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/dialects-and-native-sql.html" target="_self"><span>方言与原生 SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>实体类 API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entities-and-column-binding.html" target="_self"><span>实体类与列绑定</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-finding.html" target="_self"><span>实体查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-sequence.html" target="_self"><span>实体序列</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/sequence-aggregation.html" target="_self"><span>序列聚合</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-dml.html" target="_self"><span>实体增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/define-entities-as-any-kind-of-classes.html" target="_self"><span>使用任意的类作为实体类</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>支持和反馈</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/api-docs/index.html" target="_blank"><span>API 文档</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank"><span>问题反馈</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/sponsor.html" target="_self"><span>打赏作者</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/operators.html">English</a></span></span></div><div class="dc-page"><div class="dc-card"><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/zh-cn/operators.md"><i class="icon fa fa-github"></i> <span class="text">编辑本页</span></a><h1 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h1><p>在前面的章节中，我们已经对运算符有了一定的了解，现在，我们来对它进行详细的介绍。</p><h2 id="内置运算符"><a class="markdownIt-Anchor" href="#内置运算符"></a> 内置运算符</h2><p>Ktorm 的每个运算符实际上都是一个返回 <code>SqlExpression</code> 的 Kotlin 函数，下面是目前我们支持的所有运算符的列表及使用示例：</p><figure class="table-wrapper"><table><thead><tr><th>Kotlin 函数名</th><th>SQL 关键字/符号</th><th>使用示例</th></tr></thead><tbody><tr><td>isNull</td><td>is null</td><td>Ktorm: Employees.name.isNull()<br>SQL: t_employee.name is null</td></tr><tr><td>isNotNull</td><td>is not null</td><td>Ktorm: Employees.name.isNotNull()<br>SQL: t_employee.name is not null</td></tr><tr><td>unaryMinus (-)</td><td>-</td><td>Ktorm: -Employees.salary<br>SQL: -t_employee.salary</td></tr><tr><td>unaryPlus (+)</td><td>+</td><td>Ktorm: +Employees.salary<br>SQL: +t_employee.salary</td></tr><tr><td>not (!)</td><td>not</td><td>Ktorm: !Employees.name.isNull()<br>SQL: not (t_employee.name is null)</td></tr><tr><td>plus (+)</td><td>+</td><td>Ktorm: Employees.salary + Employees.salary<br>SQL: t_employee.salary + t_employee.salary</td></tr><tr><td>minus (-)</td><td>-</td><td>Ktorm: Employees.salary - Employees.salary<br>SQL: t_employee.salary - t_employee.salary</td></tr><tr><td>times (*)</td><td>*</td><td>Ktorm: Employees.salary * 2<br>SQL: t_employee.salary * 2</td></tr><tr><td>div (/)</td><td>/</td><td>Ktorm: Employees.salary / 2<br>SQL: t_employee.salary / 2</td></tr><tr><td>rem (%)</td><td>%</td><td>Ktorm: <a href="http://Employees.id">Employees.id</a> % 2<br>SQL: t_employee.id % 2</td></tr><tr><td>like</td><td>like</td><td>Ktorm: <a href="http://Employees.name">Employees.name</a> like “vince”<br>SQL: t_employee.name like ‘vince’</td></tr><tr><td>notLike</td><td>not like</td><td>Ktorm: <a href="http://Employees.name">Employees.name</a> notLike “vince”<br>SQL: t_employee.name not like ‘vince’</td></tr><tr><td>and</td><td>and</td><td>Ktorm: Employees.name.isNotNull() and (<a href="http://Employees.name">Employees.name</a> like “vince”)<br>SQL: t_employee.name is not null and t_employee.name like ‘vince’</td></tr><tr><td>or</td><td>or</td><td>Ktorm: Employees.name.isNull() or (<a href="http://Employees.name">Employees.name</a> notLike “vince”)<br>SQL: t_employee.name is null or t_employee.name not like ‘vince’</td></tr><tr><td>xor</td><td>xor</td><td>Ktorm: Employees.name.isNotNull() xor (<a href="http://Employees.name">Employees.name</a> notLike “vince”)<br>SQL: t_employee.name is not null xor t_employee.name not like ‘vince’</td></tr><tr><td>lt / less</td><td>&lt;</td><td>Ktorm: Employees.salary lt 1000<br>SQL: t_employee.salary &lt; 1000</td></tr><tr><td>lte / lessEq</td><td>&lt;=</td><td>Ktorm: Employees.salary lte 1000<br>SQL: t_employee.salary &lt;= 1000</td></tr><tr><td>gt / greater</td><td>&gt;</td><td>Ktorm: Employees.salary gt 1000<br>SQL: t_employee.salary &gt; 1000</td></tr><tr><td>gte / greaterEq</td><td>&gt;=</td><td>Ktorm: Employees.salary gte 1000<br>SQL: t_employee.salary &gt;= 1000</td></tr><tr><td>eq</td><td>=</td><td>Ktorm: <a href="http://Employees.id">Employees.id</a> eq 1<br>SQL: t_employee.id = 1</td></tr><tr><td>neq / notEq</td><td>&lt;&gt;</td><td>Ktorm: <a href="http://Employees.id">Employees.id</a> neq 1<br>SQL: t_employee.id &lt;&gt; 1</td></tr><tr><td>between</td><td>between</td><td>Ktorm: <a href="http://Employees.id">Employees.id</a> between 1…3<br>SQL: t_employee.id between 1 and 3</td></tr><tr><td>notBetween</td><td>not between</td><td>Ktorm: <a href="http://Employees.id">Employees.id</a> notBetween 1…3<br>SQL: t_employee.id not between 1 and 3</td></tr><tr><td>inList</td><td>in</td><td>Ktorm: Employees.departmentId.inList(1, 2, 3)<br>SQL: t_employee.department_id in (1, 2, 3)</td></tr><tr><td>notInList</td><td>not in</td><td>Ktorm: Employees.departmentId notInList db.from(Departments).selectDistinct(<a href="http://Departments.id">Departments.id</a>)<br>SQL: t_employee.department_id not in (select distinct t_department.id from t_department)</td></tr><tr><td>exists</td><td>exists</td><td>Ktorm: exists(db.from(Employees).select())<br>SQL: exists (select * from t_employee)</td></tr><tr><td>notExists</td><td>not exists</td><td>Ktorm: notExists(db.from(Employees).select())<br>SQL: not exists (select * from t_employee)</td></tr></tbody></table></figure><p>这些运算符按照实现方式大概可以分为两类：</p><p><strong>使用 operator 关键字重载的 Kotlin 内置运算符</strong>：这类运算符一般用于实现加减乘除等基本的运算，由于重载了 Kotlin 的内置运算符，它们使用起来就像是真的执行了运算一样，比如 <code>Employees.salary + 1000</code>。但实际上并没有，它们只是创建了一个 SQL 表达式，这个表达式会被 <code>SqlFormatter</code> 翻译为 SQL 中的对应符号。下面是加号运算符的代码实现，可以看到，它只是创建了一个 <code>BinaryExpression&lt;T&gt;</code> 而已：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Number&gt;</span> ColumnDeclaring<span class="type">&lt;T&gt;</span>.<span class="title">plus</span><span class="params">(expr: <span class="type">ColumnDeclaring</span>&lt;<span class="type">T</span>&gt;)</span></span>: BinaryExpression&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> BinaryExpression(BinaryExpressionType.PLUS, asExpression(), expr.asExpression(), sqlType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>普通的运算符函数</strong>：然而，Kotlin 重载运算符还有许多限制，比如 <code>equals</code> 方法要求必须返回 <code>Boolean</code>，然而 Ktorm 的运算符需要返回 SQL 表达式，因此，Ktorm 提供了另外一个 <code>eq</code> 函数用于相等比较。除此之外，还有许多 SQL 中的运算符在 Kotlin 中并不存在，比如 like，Ktorm 就提供了一个 <code>like</code> 函数用于字符串匹配。下面是 <code>like</code> 函数的实现，这类函数一般都具有 infix 关键字修饰：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> ColumnDeclaring<span class="type">&lt;*&gt;</span>.<span class="title">like</span><span class="params">(argument: <span class="type">String</span>)</span></span>: BinaryExpression&lt;<span class="built_in">Boolean</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> BinaryExpression(</span><br><span class="line">        type = BinaryExpressionType.LIKE, </span><br><span class="line">        left = asExpression(), </span><br><span class="line">        right = ArgumentExpression(argument, VarcharSqlType), </span><br><span class="line">        sqlType = BooleanSqlType</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级"></a> 运算符优先级</h2><p>运算符可以连续使用，但是，当我们一次使用多个运算符时，它们的优先级就成了一个问题。在一个表达式中可能包含多个运算符，不同的运算顺序可能得出不同的结果甚至出现运算错误，因为当表达式中含多种运算时，必须按一定顺序进行结合，才能保证运算的合理性和结果的正确性、唯一性。</p><p>例如 1 + 2 * 3，乘号的优先级比较高，则 2 * 3 优先结合，运算结果为 7；若不考虑运算符的优先级，从前往后结合，那么运算结果为 9，这是完全错误的。一般来说，乘除的优先级高于加减，与的优先级高于或，但是，在 Ktorm 中，情况却有些不同。</p><p>对于重载的 Kotlin 内置运算符，其优先级遵循 Kotlin 语言自己的规范。例如表达式 <code>Employees.salary + 1000 * 2</code>，由于乘号的优先级较高，最终翻译出来的 SQL 是 <code>t_employee.salary + 2000</code>。</p><p><strong>但是对于普通的运算符函数，却并没有优先级一说</strong>。在 Kotlin 语言的层面，它们实际上都只是普通的函数调用，因此只需要遵循从前往后结合的原则，尽管这有时可能会违反我们的直觉。比如 <code>a or b and c</code>，这里的 <code>or</code> 和 <code>and</code> 都是运算符函数，直觉上，<code>and</code> 的优先级应该比 <code>or</code> 高，因此应该优先结合，但实际上，它们只是普通的 Kotlin 函数而已。如果对这一点没有清楚的认识，可能导致一些意料之外的 bug，为了解决这个问题，我们可以在需要的地方使用括号，比如 <code>a or (b and c)</code>。</p><p>关于表达式优先级的具体顺序，请参考 <a href="https://kotlinlang.org/docs/reference/grammar.html#expressions">Kotlin 语言规范</a>中的相关规定。</p><h2 id="自定义运算符"><a class="markdownIt-Anchor" href="#自定义运算符"></a> 自定义运算符</h2><p>前面已经介绍过 Ktorm 核心模块的内置运算符，这些运算符为标准 SQL 中的运算符提供了支持，但如果我们想使用一些数据库方言中特有的运算符呢？下面我们以 PostgreSQL 中的 <code>ilike</code> 运算符为例，了解如何增加自己的运算符。</p><p><code>ilike</code> 是 PostgreSQL 中特有的运算符，它的功能与 <code>like</code> 一样，也是进行字符串匹配，但是忽略大小写。我们首先创建一个表达式类型，它继承于 <code>ScalarExpression&lt;Boolean&gt;</code>，表示一个 ilike 操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">ILikeExpression</span>(</span><br><span class="line">    <span class="keyword">val</span> left: ScalarExpression&lt;*&gt;,</span><br><span class="line">    <span class="keyword">val</span> right: ScalarExpression&lt;*&gt;,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> sqlType: SqlType&lt;<span class="built_in">Boolean</span>&gt; = BooleanSqlType,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> isLeafNode: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">) : ScalarExpression&lt;<span class="built_in">Boolean</span>&gt;()</span><br></pre></td></tr></table></figure><p>有了表达式类型之后，我们只需要再增加一个扩展函数，这就是运算符函数，为了函数使用起来真的像一个运算符，我们需要添加 infix 关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> ColumnDeclaring<span class="type">&lt;*&gt;</span>.<span class="title">ilike</span><span class="params">(argument: <span class="type">String</span>)</span></span>: ILikeExpression &#123;</span><br><span class="line">    <span class="keyword">return</span> ILikeExpression(asExpression(), ArgumentExpression(argument, VarcharSqlType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就能使用这个运算符函数了，就像使用其他运算符一样。不过现在 Ktorm 还无法识别我们自己创建的 <code>ILikeExpression</code>，无法为我们生成正确的 SQL。因此，我们需要扩展 <code>SqlFormatter</code> 类，重写它的 <code>visitUnknown</code> 方法，在里面检测我们的自定义表达式，为其生成正确的 SQL：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomSqlFormatter</span>(database: Database, beautifySql: <span class="built_in">Boolean</span>, indentSize: <span class="built_in">Int</span>)</span><br><span class="line">    : PostgreSqlFormatter(database, beautifySql, indentSize) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitUnknown</span><span class="params">(expr: <span class="type">SqlExpression</span>)</span></span>: SqlExpression &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr <span class="keyword">is</span> ILikeExpression) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expr.left.removeBrackets) &#123;</span><br><span class="line">                visit(expr.left)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                write(<span class="string">&quot;(&quot;</span>)</span><br><span class="line">                visit(expr.left)</span><br><span class="line">                removeLastBlank()</span><br><span class="line">                write(<span class="string">&quot;) &quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            write(<span class="string">&quot;ilike &quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expr.right.removeBrackets) &#123;</span><br><span class="line">                visit(expr.right)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                write(<span class="string">&quot;(&quot;</span>)</span><br><span class="line">                visit(expr.right)</span><br><span class="line">                removeLastBlank()</span><br><span class="line">                write(<span class="string">&quot;) &quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> expr</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.visitUnknown(expr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，使用方言（Dialect）将这个自定义的 SqlFormatter 注册到 <code>Database</code> 对象中。更多关于<a href="./dialects-and-native-sql.html">方言</a>的细节，可参考后面的章节。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> database = Database.connect(</span><br><span class="line">    url = <span class="string">&quot;jdbc:postgresql://localhost:5432/ktorm&quot;</span>,</span><br><span class="line">    dialect = <span class="keyword">object</span> : SqlDialect &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createSqlFormatter</span><span class="params">(database: <span class="type">Database</span>, beautifySql: <span class="type">Boolean</span>, indentSize: <span class="type">Int</span>)</span></span>: SqlFormatter &#123;</span><br><span class="line">            <span class="keyword">return</span> CustomSqlFormatter(database, beautifySql, indentSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>大功告成，<code>ilike</code> 的使用方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database.from(Employees).select().<span class="keyword">where</span> &#123; Employees.name ilike <span class="string">&quot;VINCE&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>这样，Ktorm 就能够无缝支持 <code>ilike</code> 运算符，事实上，这正是 ktorm-support-postgresql 模块的功能之一，如果你真的需要使用 PostgreSQL 的 <code>ilike</code> 运算符，请直接在项目中添加依赖，不必再写一遍上面的代码，这里仅作示范。</p><p>Maven 依赖：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ktorm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ktorm-support-postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;ktorm.version&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>或者 gradle：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">&quot;org.ktorm:ktorm-support-postgresql:$&#123;ktorm.version&#125;&quot;</span></span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer"><div class="doc-footer-link">上一篇：<a href="/zh-cn/dml.html">增删改</a></div><div class="doc-footer-link">下一篇：<a href="/zh-cn/dialects-and-native-sql.html">方言与原生 SQL</a></div>对文档内容有疑问？请在侧边栏尝试搜索或者在 GitHub <a href="https://github.com/kotlin-orm/ktorm/issues/new">提出 issue</a></div></div></article></div></div><div class="doc-footer">&copy; 2024 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script></body></html>