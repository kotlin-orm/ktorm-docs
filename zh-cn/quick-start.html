<!-- build time:Fri Apr 02 2021 23:46:48 GMT+0800 (CST) --><!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Ktorm | 快速开始</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"快速开始",lang:"zh-cn",related_path:"en/quick-start.html",path:"zh-cn/quick-start.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"Overview",type:"link",path:"",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!0},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]},"navigation-zh-cn":{home:[{title:"快速开始",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"概述",type:"link",path:"zh-cn/",isCurrent:!0},{text:"快速开始",type:"link",path:"zh-cn/quick-start.html",isCurrent:!1},{text:"连接管理",type:"label",isCurrent:!1},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html",isCurrent:!1},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html",isCurrent:!1},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html",isCurrent:!1},{text:"查询",type:"link",path:"zh-cn/query.html",isCurrent:!1},{text:"联表",type:"link",path:"zh-cn/joining.html",isCurrent:!1},{text:"增删改",type:"link",path:"zh-cn/dml.html",isCurrent:!1},{text:"运算符",type:"link",path:"zh-cn/operators.html",isCurrent:!1},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html",isCurrent:!1},{text:"实体类 API",type:"label",isCurrent:!1},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html",isCurrent:!1},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html",isCurrent:!1},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html",isCurrent:!1},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html",isCurrent:!1},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html",isCurrent:!1},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"支持和反馈",type:"label",isCurrent:!1},{text:"API 文档",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html",isCurrent:!1}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc",algolia:{appId:"2W81KMSLOD",apiKey:"2a146a809de068d9b7a07ba3fb70b4e5",indexName:"ktorm",chunkSize:5e3,fields:["title","lang","date","updated","_content:truncate,0,5200","path","permalink"]}}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><span class="doc-navbar__logo"><a href="/zh-cn/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/quick-start.html">English</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><div class="dc-search-form doc-search-form"><input type="search" id="doc-search-input" class="dc-input dc-search-form__input doc-search-form__input" placeholder="搜索文档" autofocus><button class="dc-btn dc-search-form__btn doc-search-form__btn" aria-label="Search"><i class="dc-icon dc-icon--search"></i></button></div></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/" target="_self"><span>概述</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current"><a href="/zh-cn/quick-start.html" target="_self"><span>快速开始</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>连接管理</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/connect-to-databases.html" target="_self"><span>连接数据库</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/transaction-management.html" target="_self"><span>事务管理</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/spring-support.html" target="_self"><span>Spring 支持</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/schema-definition.html" target="_self"><span>定义表结构</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/query.html" target="_self"><span>查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/joining.html" target="_self"><span>联表</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/dml.html" target="_self"><span>增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/operators.html" target="_self"><span>运算符</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/dialects-and-native-sql.html" target="_self"><span>方言与原生 SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>实体类 API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entities-and-column-binding.html" target="_self"><span>实体类与列绑定</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-finding.html" target="_self"><span>实体查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-sequence.html" target="_self"><span>实体序列</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/sequence-aggregation.html" target="_self"><span>序列聚合</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-dml.html" target="_self"><span>实体增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/define-entities-as-any-kind-of-classes.html" target="_self"><span>使用任意的类作为实体类</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>支持和反馈</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/api-docs/index.html" target="_self"><span>API 文档</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_self"><span>问题反馈</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/sponsor.html" target="_self"><span>打赏作者</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher" data-reactroot=""><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/quick-start.html">English</a></span></span></div><div class="dc-page"><div class="dc-card"><div id="doc-search-results" class="doc-search-results"><div id="doc-search-stats"></div><div id="doc-search-hits"></div><div id="doc-search-pagination"></div></div><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/zh-cn/quick-start.md"><i class="icon fa fa-github"></i> <span class="text">编辑本页</span></a><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>Ktorm 已经发布到 maven 中央仓库和 jcenter，因此，如果你使用 maven 的话，只需要在 <code>pom.xml</code> 文件里面添加一个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ktorm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ktorm-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;ktorm.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者 gradle：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">"org.ktorm:ktorm-core:$&#123;ktorm.version&#125;"</span></span><br></pre></td></tr></table></figure><p>首先，创建 Kotlin object，<a href="./schema-definition.html">描述你的表结构</a>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Departments : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">"t_department"</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">"id"</span>).primaryKey()</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">val</span> location = varchar(<span class="string">"location"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Employees : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">"t_employee"</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">"id"</span>).primaryKey()</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">val</span> job = varchar(<span class="string">"job"</span>)</span><br><span class="line">    <span class="keyword">val</span> managerId = int(<span class="string">"manager_id"</span>)</span><br><span class="line">    <span class="keyword">val</span> hireDate = date(<span class="string">"hire_date"</span>)</span><br><span class="line">    <span class="keyword">val</span> salary = long(<span class="string">"salary"</span>)</span><br><span class="line">    <span class="keyword">val</span> departmentId = int(<span class="string">"department_id"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，连接到数据库，执行一个简单的查询：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> database = Database.connect(<span class="string">"jdbc:mysql://localhost:3306/ktorm"</span>, user = <span class="string">"root"</span>, password = <span class="string">"***"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (row <span class="keyword">in</span> database.from(Employees).select()) &#123;</span><br><span class="line">        println(row[Employees.name])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，你可以执行这个程序了，Ktorm 会生成一条 SQL <code>select * from t_employee</code>，查询表中所有的员工记录，然后打印出他们的名字。 因为 <code>select</code> 函数返回的查询对象重载了迭代运算符，所以你可以在这里使用 for-each 循环的语法。</p><h2 id="SQL-DSL"><a href="#SQL-DSL" class="headerlink" title="SQL DSL"></a>SQL DSL</h2><p>让我们在上面的查询里再增加一点筛选条件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.name)</span><br><span class="line">    .<span class="keyword">where</span> &#123; (Employees.departmentId eq <span class="number">1</span>) and (Employees.name like <span class="string">"%vince%"</span>) &#125;</span><br><span class="line">    .forEach &#123; row -&gt; </span><br><span class="line">        println(row[Employees.name]) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生成的 SQL 如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.name <span class="keyword">as</span> t_employee_name </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">where</span> (t_employee.department_id = ?) <span class="keyword">and</span> (t_employee.name <span class="keyword">like</span> ?)</span><br></pre></td></tr></table></figure><p>这就是 Kotlin 的魔法，使用 Ktorm 写查询十分地简单和自然，所生成的 SQL 几乎和 Kotlin 代码一一对应。并且，Ktorm 是强类型的，编译器会在你的代码运行之前对它进行检查，IDE 也能对你的代码进行智能提示和自动补全。</p><p>动态查询，根据不同的情况在 where 子句中增加不同的筛选条件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.name)</span><br><span class="line">    .whereWithConditions &#123;</span><br><span class="line">        <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">            it += Employees.managerId.isNull()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (otherCondition) &#123;</span><br><span class="line">            it += Employees.departmentId eq <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>聚合查询：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = Employees.aliased(<span class="string">"t"</span>)</span><br><span class="line">database</span><br><span class="line">    .from(t)</span><br><span class="line">    .select(t.departmentId, avg(t.salary))</span><br><span class="line">    .groupBy(t.departmentId)</span><br><span class="line">    .having &#123; avg(t.salary) greater <span class="number">100.0</span> &#125;</span><br><span class="line">    .forEach &#123; row -&gt; </span><br><span class="line">        println(<span class="string">"<span class="subst">$&#123;row.getInt(<span class="number">1</span>)&#125;</span>:<span class="subst">$&#123;row.getDouble(<span class="number">2</span>)&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Union：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.id)</span><br><span class="line">    .unionAll(</span><br><span class="line">        database.from(Departments).select(Departments.id)</span><br><span class="line">    )</span><br><span class="line">    .unionAll(</span><br><span class="line">        database.from(Departments).select(Departments.id)</span><br><span class="line">    )</span><br><span class="line">    .orderBy(Employees.id.desc())</span><br></pre></td></tr></table></figure><p>多表连接查询：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Names</span></span>(<span class="keyword">val</span> name: String?, <span class="keyword">val</span> managerName: String?, <span class="keyword">val</span> departmentName: String?)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> emp = Employees.aliased(<span class="string">"emp"</span>)</span><br><span class="line"><span class="keyword">val</span> mgr = Employees.aliased(<span class="string">"mgr"</span>)</span><br><span class="line"><span class="keyword">val</span> dept = Departments.aliased(<span class="string">"dept"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> results = database</span><br><span class="line">    .from(emp)</span><br><span class="line">    .leftJoin(dept, on = emp.departmentId eq dept.id)</span><br><span class="line">    .leftJoin(mgr, on = emp.managerId eq mgr.id)</span><br><span class="line">    .select(emp.name, mgr.name, dept.name)</span><br><span class="line">    .orderBy(emp.id.asc())</span><br><span class="line">    .map &#123; row -&gt; </span><br><span class="line">        Names(</span><br><span class="line">            name = row[emp.name],</span><br><span class="line">            managerName = row[mgr.name],</span><br><span class="line">            departmentName = row[dept.name]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>插入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">database.insert(Employees) &#123;</span><br><span class="line">    <span class="keyword">set</span>(it.name, <span class="string">"jerry"</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.job, <span class="string">"trainee"</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.managerId, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.hireDate, LocalDate.now())</span><br><span class="line">    <span class="keyword">set</span>(it.salary, <span class="number">50</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.departmentId, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">database.update(Employees) &#123;</span><br><span class="line">    <span class="keyword">set</span>(it.job, <span class="string">"engineer"</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.managerId, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.salary, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">where</span> &#123;</span><br><span class="line">        it.id eq <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">database.delete(Employees) &#123; it.id eq <span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure><p>更多 SQL DSL 的用法，请参考<a href="./query.html">具体文档</a>。</p><h2 id="实体类与列绑定"><a href="#实体类与列绑定" class="headerlink" title="实体类与列绑定"></a>实体类与列绑定</h2><p>除了 SQL DSL 以外，Ktorm 也支持实体对象。首先，我们需要定义实体类，然后在表对象中使用 <code>bindTo</code> 函数将表与实体类进行绑定。在 Ktorm 里面，我们使用接口定义实体类，继承 <code>Entity&lt;E&gt;</code> 即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Department</span> : <span class="type">Entity</span>&lt;<span class="type">Department</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Entity.Factory&lt;Department&gt;()</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">var</span> location: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Employee</span> : <span class="type">Entity</span>&lt;<span class="type">Employee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Entity.Factory&lt;Employee&gt;()</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">var</span> job: String</span><br><span class="line">    <span class="keyword">var</span> manager: Employee?</span><br><span class="line">    <span class="keyword">var</span> hireDate: LocalDate</span><br><span class="line">    <span class="keyword">var</span> salary: <span class="built_in">Long</span></span><br><span class="line">    <span class="keyword">var</span> department: Department</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改前面的表对象，把数据库中的列绑定到实体类的属性上：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Departments : Table&lt;Department&gt;(<span class="string">"t_department"</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">"id"</span>).primaryKey().bindTo &#123; it.id &#125;</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">"name"</span>).bindTo &#123; it.name &#125;</span><br><span class="line">    <span class="keyword">val</span> location = varchar(<span class="string">"location"</span>).bindTo &#123; it.location &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Employees : Table&lt;Employee&gt;(<span class="string">"t_employee"</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">"id"</span>).primaryKey().bindTo &#123; it.id &#125;</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">"name"</span>).bindTo &#123; it.name &#125;</span><br><span class="line">    <span class="keyword">val</span> job = varchar(<span class="string">"job"</span>).bindTo &#123; it.job &#125;</span><br><span class="line">    <span class="keyword">val</span> managerId = int(<span class="string">"manager_id"</span>).bindTo &#123; it.manager.id &#125;</span><br><span class="line">    <span class="keyword">val</span> hireDate = date(<span class="string">"hire_date"</span>).bindTo &#123; it.hireDate &#125;</span><br><span class="line">    <span class="keyword">val</span> salary = long(<span class="string">"salary"</span>).bindTo &#123; it.salary &#125;</span><br><span class="line">    <span class="keyword">val</span> departmentId = int(<span class="string">"department_id"</span>).references(Departments) &#123; it.department &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名规约：强烈建议使用单数名词命名实体类，使用名词的复数形式命名表对象，如：Employee/Employees、Department/Departments。</p></blockquote><p>完成列绑定后，我们就可以使用<a href="#实体序列-API">序列 API</a> 对实体进行各种灵活的操作。我们先给 <code>Database</code> 定义两个扩展属性，它们使用 <code>sequenceOf</code> 函数创建序列对象并返回。这两个属性可以帮助我们提高代码的可读性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Database.departments <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Departments)</span><br><span class="line"><span class="keyword">val</span> Database.employees <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Employees)</span><br></pre></td></tr></table></figure><p>下面的代码使用 <code>find</code> 函数从序列中根据名字获取一个 Employee 对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123; it.name eq <span class="string">"vince"</span> &#125;</span><br></pre></td></tr></table></figure><p>我们还能使用 <code>filter</code> 函数对序列进行筛选，比如获取所有名字为 vince 的员工：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.filter &#123; it.name eq <span class="string">"vince"</span> &#125;.toList()</span><br></pre></td></tr></table></figure><p><code>find</code> 和 <code>filter</code> 函数都接受一个 lambda 表达式作为参数，使用该 lambda 的返回值作为条件，生成一条查询 SQL。可以看到，生成的 SQL 自动 left join 了关联表 <code>t_department</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id = _ref0.id </span><br><span class="line"><span class="keyword">where</span> t_employee.name = ?</span><br></pre></td></tr></table></figure><p>将实体对象保存到数据库：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = Employee &#123;</span><br><span class="line">    name = <span class="string">"jerry"</span></span><br><span class="line">    job = <span class="string">"trainee"</span></span><br><span class="line">    hireDate = LocalDate.now()</span><br><span class="line">    salary = <span class="number">50</span></span><br><span class="line">    department = database.departments.find &#123; it.name eq <span class="string">"tech"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">database.employees.add(employee)</span><br></pre></td></tr></table></figure><p>将内存中实体对象的变化更新到数据库：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123; it.id eq <span class="number">2</span> &#125; ?: <span class="keyword">return</span></span><br><span class="line">employee.job = <span class="string">"engineer"</span></span><br><span class="line">employee.salary = <span class="number">100</span></span><br><span class="line">employee.flushChanges()</span><br></pre></td></tr></table></figure><p>从数据库中删除实体对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123; it.id eq <span class="number">2</span> &#125; ?: <span class="keyword">return</span></span><br><span class="line">employee.delete()</span><br></pre></td></tr></table></figure><p>更多实体 API 的用法，可参考<a href="./entities-and-column-binding.html">列绑定</a>和<a href="./entity-finding.html">实体查询</a>相关的文档。</p><h2 id="实体序列-API"><a href="#实体序列-API" class="headerlink" title="实体序列 API"></a>实体序列 API</h2><p>Ktorm 提供了一套名为”实体序列”的 API，用来从数据库中获取实体对象。正如其名字所示，它的风格和使用方式与 Kotlin 标准库中的序列 API 极其类似，它提供了许多同名的扩展函数，比如 <code>filter</code>、<code>map</code>、<code>reduce</code> 等。</p><p>Ktorm 的实体序列 API，大部分都是以扩展函数的方式提供的，这些扩展函数大致可以分为两类，它们分别是中间操作和终止操作。</p><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>这类操作并不会执行序列中的查询，而是修改并创建一个新的序列对象，比如 <code>filter</code> 函数会使用指定的筛选条件创建一个新的序列对象。下面使用 <code>filter</code> 获取部门 1 中的所有员工：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.filter &#123; it.departmentId eq <span class="number">1</span> &#125;.toList()</span><br></pre></td></tr></table></figure><p>可以看到，用法几乎与 <code>kotlin.sequences</code> 完全一样，不同的仅仅是在 lambda 表达式中的等号 <code>==</code> 被这里的 <code>eq</code> 函数代替了而已。<code>filter</code> 函数还可以连续使用，此时所有的筛选条件将使用 <code>and</code> 运算符进行连接，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .filter &#123; it.managerId.isNotNull() &#125;</span><br><span class="line">    .toList()</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id = _ref0.id </span><br><span class="line"><span class="keyword">where</span> (t_employee.department_id = ?) <span class="keyword">and</span> (t_employee.manager_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>使用 <code>sortedBy</code> 或 <code>sortedByDescending</code> 对序列中的元素进行排序：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.sortedBy &#123; it.salary &#125;.toList()</span><br></pre></td></tr></table></figure><p>使用 <code>drop</code> 和 <code>take</code> 函数进行分页：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.drop(<span class="number">1</span>).take(<span class="number">1</span>).toList()</span><br></pre></td></tr></table></figure><h3 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h3><p>实体序列的终止操作会马上执行一个查询，获取查询的执行结果，然后执行一定的计算。for-each 循环就是一个典型的终止操作，下面我们使用 for-each 循环打印出序列中所有的员工：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (employee <span class="keyword">in</span> database.employees) &#123;</span><br><span class="line">    println(employee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id = _ref0.id</span><br></pre></td></tr></table></figure><p><code>toCollection</code>、<code>toList</code> 等方法用于将序列中的元素保存为一个集合：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.toCollection(ArrayList())</span><br></pre></td></tr></table></figure><p><code>mapColumns</code> 函数用于获取指定列的结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = database.employees.mapColumns &#123; it.name &#125;</span><br></pre></td></tr></table></figure><p>除此之外，<code>mapColumns</code> 还可以同时获取多个列的结果，这时我们只需要在闭包中使用 <code>tupleOf</code> 包装我们的这些字段，函数的返回值也相应变成了 <code>List&lt;TupleN&lt;C1?, C2?, .. Cn?&gt;&gt;</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .mapColumns &#123; tupleOf(it.id, it.name) &#125;</span><br><span class="line">    .forEach &#123; (id, name) -&gt;</span><br><span class="line">        println(<span class="string">"<span class="variable">$id</span>:<span class="variable">$name</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.id, t_employee.name</span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">where</span> t_employee.department_id = ?</span><br></pre></td></tr></table></figure><p>其他我们熟悉的序列函数也都支持，比如 <code>fold</code>、<code>reduce</code>、<code>forEach</code> 等，下面使用 <code>fold</code> 计算所有员工的工资总和：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> totalSalary = database.employees.fold(<span class="number">0L</span>) &#123; acc, employee -&gt; acc + employee.salary &#125;</span><br></pre></td></tr></table></figure><h3 id="序列聚合"><a href="#序列聚合" class="headerlink" title="序列聚合"></a>序列聚合</h3><p>实体序列 API 不仅可以让我们使用类似 <code>kotlin.sequences</code> 的方式获取数据库中的实体对象，它还支持丰富的聚合功能，让我们可以方便地对指定字段进行计数、求和、求平均值等操作。</p><p>下面使用 <code>aggregateColumns</code> 函数获取部门 1 中工资的最大值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .aggregateColumns &#123; max(it.salary) &#125;</span><br></pre></td></tr></table></figure><p>如果你希望同时获取多个聚合结果，只需要在闭包中使用 <code>tupleOf</code> 包装我们的这些聚合表达式即可，此时函数的返回值就相应变成了 <code>TupleN&lt;C1?, C2?, .. Cn?&gt;</code>。下面的例子获取部门 1 中工资的平均值和极差：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (avg, diff) = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .aggregateColumns &#123; tupleOf(avg(it.salary), max(it.salary) - min(it.salary)) &#125;</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(t_employee.salary), <span class="keyword">max</span>(t_employee.salary) - <span class="keyword">min</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">where</span> t_employee.department_id = ?</span><br></pre></td></tr></table></figure><p>除了直接使用 <code>aggregateColumns</code> 函数以外，Ktorm 还为序列提供了许多方便的辅助函数，他们都是基于 <code>aggregateColumns</code> 函数实现的，分别是 <code>count</code>、<code>any</code>、<code>none</code>、<code>all</code>、<code>sumBy</code>、<code>maxBy</code>、<code>minBy</code>、<code>averageBy</code>。</p><p>下面改用 <code>maxBy</code> 函数获取部门 1 中工资的最大值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .maxBy &#123; it.salary &#125;</span><br></pre></td></tr></table></figure><p>除此之外，Ktorm 还支持分组聚合，只需要先调用 <code>groupingBy</code>，再调用 <code>aggregateColumns</code>。下面的代码可以获取所有部门的平均工资，它的返回值类型是 <code>Map&lt;Int?, Double?&gt;</code>，其中键为部门 ID，值是各个部门工资的平均值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .aggregateColumns &#123; avg(it.salary) &#125;</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id, <span class="keyword">avg</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t_employee.department_id</span><br></pre></td></tr></table></figure><p>在分组聚合时，Ktorm 也提供了许多方便的辅助函数，它们是 <code>eachCount(To)</code>、<code>eachSumBy(To)</code>、<code>eachMaxBy(To)</code>、<code>eachMinBy(To)</code>、<code>eachAverageBy(To)</code>。有了这些辅助函数，上面获取所有部门平均工资的代码就可以改写成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .eachAverageBy &#123; it.salary &#125;</span><br></pre></td></tr></table></figure><p>除此之外，Ktorm 还提供了 <code>aggregate</code>、<code>fold</code>、<code>reduce</code> 等函数，它们与 <code>kotlin.collections.Grouping</code> 的相应函数同名，功能也完全一样。下面的代码使用 <code>fold</code> 函数计算每个部门工资的总和：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> totalSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .fold(<span class="number">0L</span>) &#123; acc, employee -&gt; </span><br><span class="line">        acc + employee.salary </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>更多实体序列 API 的用法，可参考<a href="./entity-sequence.html">实体序列</a>和<a href="./sequence-aggregation.html">序列聚合</a>相关的文档。</p><div id="support-footer-container"><div class="doc-support-footer" data-reactroot=""><div class="doc-footer-link">上一篇：<a href="/zh-cn/">概述</a></div><div class="doc-footer-link">下一篇：<a href="/zh-cn/connect-to-databases.html">连接数据库</a></div>对文档内容有疑问？请在侧边栏尝试搜索或者在 GitHub <a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank" rel="noopener">提出 issue</a></div></div></article></div></div><div class="doc-footer">&copy; 2021 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm" target="_blank" rel="noopener">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/script/doc.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script><script type="text/javascript">docsearch({apiKey:"8cd6a3b7dc33b50b89c7e9b11110717a",indexName:"ktorm",inputSelector:"#doc-search-input",algoliaOptions:{facetFilters:["lang:zh-cn","tags:doc"]},autocompleteOptions:{hint:!1,appendTo:"body"},debug:!1})</script><script>!function(){$(".kotlin .code .keyword").each(function(){var e=$(this);("where"===e.text()||"set"===e.text())&&e.removeClass("keyword")})}()</script></body></html><!-- rebuild by neat -->