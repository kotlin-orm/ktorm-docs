<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Ktorm | 定义表结构</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch-css@3.6.2/style.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"定义表结构",lang:"zh-cn",related_path:"en/schema-definition.html",path:"zh-cn/schema-definition.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"GETTING STARTED",type:"label",isCurrent:!1},{text:"Overview",type:"link",path:"/",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!0},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",target:"_blank",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]},"navigation-zh-cn":{home:[{title:"快速上手",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"开始",type:"label",isCurrent:!1},{text:"简介",type:"link",path:"zh-cn/",isCurrent:!1},{text:"快速上手",type:"link",path:"zh-cn/quick-start.html",isCurrent:!1},{text:"连接管理",type:"label",isCurrent:!1},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html",isCurrent:!1},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html",isCurrent:!1},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html",isCurrent:!1},{text:"查询",type:"link",path:"zh-cn/query.html",isCurrent:!0},{text:"联表",type:"link",path:"zh-cn/joining.html",isCurrent:!1},{text:"增删改",type:"link",path:"zh-cn/dml.html",isCurrent:!1},{text:"运算符",type:"link",path:"zh-cn/operators.html",isCurrent:!1},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html",isCurrent:!1},{text:"实体类 API",type:"label",isCurrent:!1},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html",isCurrent:!1},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html",isCurrent:!1},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html",isCurrent:!1},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html",isCurrent:!1},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html",isCurrent:!1},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"支持和反馈",type:"label",isCurrent:!1},{text:"API 文档",type:"support-link",path:"api-docs/index.html",target:"_blank",isCurrent:!1},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank",isCurrent:!1},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html",isCurrent:!1}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc"}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation"><nav class="doc-navbar"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="doc-navbar__logo"><a href="/zh-cn/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close"></i><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/schema-definition.html">English</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"></span></button></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>开始</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/" target="_self"><span>简介</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/quick-start.html" target="_self"><span>快速上手</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>连接管理</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/connect-to-databases.html" target="_self"><span>连接数据库</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/transaction-management.html" target="_self"><span>事务管理</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/spring-support.html" target="_self"><span>Spring 支持</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current doc-sidebar-list__item--no-children"><a href="/zh-cn/schema-definition.html" target="_self"><span>定义表结构</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/query.html" target="_self"><span>查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/joining.html" target="_self"><span>联表</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/dml.html" target="_self"><span>增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/operators.html" target="_self"><span>运算符</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/dialects-and-native-sql.html" target="_self"><span>方言与原生 SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>实体类 API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entities-and-column-binding.html" target="_self"><span>实体类与列绑定</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-finding.html" target="_self"><span>实体查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-sequence.html" target="_self"><span>实体序列</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/sequence-aggregation.html" target="_self"><span>序列聚合</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-dml.html" target="_self"><span>实体增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/define-entities-as-any-kind-of-classes.html" target="_self"><span>使用任意的类作为实体类</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>支持和反馈</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/api-docs/index.html" target="_blank"><span>API 文档</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank"><span>问题反馈</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/sponsor.html" target="_self"><span>打赏作者</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/schema-definition.html">English</a></span></span></div><div class="dc-page"><div class="dc-card"><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/zh-cn/schema-definition.md"><i class="icon fa fa-github"></i> <span class="text">编辑本页</span></a><h1 id="定义表结构"><a class="markdownIt-Anchor" href="#定义表结构"></a> 定义表结构</h1><p>在使用 SQL DSL 之前，我们首先要让 Ktorm 能够了解我们的表结构。假设我们有两个表，他们分别是部门表 <code>t_department</code> 和员工表 <code>t_employee</code>， 它们的建表 SQL 如下，我们要如何描述这两个表呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_department(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  location <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_employee(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  job <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  manager_id <span class="type">int</span> <span class="keyword">null</span>,</span><br><span class="line">  hire_date <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  salary <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  department_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="表对象"><a class="markdownIt-Anchor" href="#表对象"></a> 表对象</h2><p>一般来说，Ktorm 使用 Kotlin 中的 object 关键字定义一个继承 <code>Table</code> 类的对象来描述表结构，上面例子中的两个表可以像这样在 Ktorm 中定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Departments : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">&quot;t_department&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">&quot;id&quot;</span>).primaryKey()</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> location = varchar(<span class="string">&quot;location&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Employees : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">&quot;t_employee&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">&quot;id&quot;</span>).primaryKey()</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = varchar(<span class="string">&quot;job&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> managerId = int(<span class="string">&quot;manager_id&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> hireDate = date(<span class="string">&quot;hire_date&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> salary = long(<span class="string">&quot;salary&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> departmentId = int(<span class="string">&quot;department_id&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>Departments</code> 和 <code>Employees</code> 都继承了 <code>Table</code>，并且在构造函数中指定了表名，<code>Table</code> 类还有一个泛型参数，它是此表绑定到的实体类的类型，在这里我们不需要绑定到任何实体类，因此指定为 <code>Nothing</code> 即可。</p><p>表中的列则使用 val 关键字定义为表对象中的成员属性，列的类型使用 int、long、varchar、date 等函数定义，它们分别对应了 SQL 中的相应类型，这些类型定义函数的普遍特征如下：</p><ul><li>它们是 <code>Table</code> 类的扩展函数，只能在定义表对象时使用</li><li>它们的名称一般对应于其实际的 SQL 类型的名称</li><li>它们都接收一个字符串的参数，在这里我们需要把列的名称传入</li><li>它们的返回值都是 <code>Column&lt;C&gt;</code>，C 为该列的类型，我们可以链式调用 <code>primaryKey</code> 扩展函数，将当前列声明为主键</li></ul><p>通常我们都会将表定义为 Kotlin 单例对象，但我们其实不必拘泥于此。例如，在某些情况下，我们有两个结构完全相同的表，只是表名不同（在数据备份的时候比较常见），难道我们一定要在每一个表对象中都写一遍完全相同的字段定义吗？当然不需要，这里我们可以使用继承重用代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Employees</span>(tableName: String) : Table&lt;<span class="built_in">Nothing</span>&gt;(tableName) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">&quot;id&quot;</span>).primaryKey()</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = varchar(<span class="string">&quot;job&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> managerId = int(<span class="string">&quot;manager_id&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> hireDate = date(<span class="string">&quot;hire_date&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> salary = long(<span class="string">&quot;salary&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> departmentId = int(<span class="string">&quot;department_id&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> RegularEmployees : Employees(<span class="string">&quot;t_regular_employee&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> FormerEmployees : Employees(<span class="string">&quot;t_former_employee&quot;</span>)</span><br></pre></td></tr></table></figure><p>再比如，有时我们的某个表只需要使用一次，因此没有必要将其定义为全局对象，以免污染命名空间。这时，我们甚至可以在函数内部使用匿名对象定义一个表：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = <span class="keyword">object</span> : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">&quot;t_config&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> key = varchar(<span class="string">&quot;key&quot;</span>).primaryKey()</span><br><span class="line">    <span class="keyword">val</span> value = varchar(<span class="string">&quot;value&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all configs as a Map&lt;String, String&gt;</span></span><br><span class="line"><span class="keyword">val</span> configs = database.from(t).select().associate &#123; row -&gt; row[t.key] to row[t.value] &#125;</span><br></pre></td></tr></table></figure><p>灵活使用 Kotlin 的语法特性可以帮助我们减少重复代码、提高项目的可维护性。</p><h2 id="sqltype"><a class="markdownIt-Anchor" href="#sqltype"></a> SqlType</h2><p><code>SqlType</code> 是一个抽象类，它为 SQL 中的数据类型提供了统一的抽象，基于 JDBC，它封装了从 <code>ResultSet</code> 中获取数据，往 <code>PreparedStatement</code> 设置参数等通用的操作。在前面定义表中的字段时，我们曾使用了表示不同类型的 int、varchar 等列定义函数，这些函数的背后其实都有一个特定的 <code>SqlType</code> 的子类。比如 int 函数的实现是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> BaseTable<span class="type">&lt;*&gt;</span>.<span class="title">int</span><span class="params">(name: <span class="type">String</span>)</span></span>: Column&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> registerColumn(name, IntSqlType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> IntSqlType : SqlType&lt;<span class="built_in">Int</span>&gt;(Types.INTEGER, typeName = <span class="string">&quot;int&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSetParameter</span><span class="params">(ps: <span class="type">PreparedStatement</span>, index: <span class="type">Int</span>, parameter: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        ps.setInt(index, parameter)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doGetResult</span><span class="params">(rs: <span class="type">ResultSet</span>, index: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> rs.getInt(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IntSqlType</code> 的实现特别简单，它只是使用了 <code>ResultSet.getInt</code> 函数获取来自结果集中的数据，使用 <code>PreparedStatement.setInt</code> 设置传递给数据库的参数而已。</p><p>Ktorm 默认支持的数据类型如下表：</p><figure class="table-wrapper"><table><thead><tr><th>函数名</th><th>Kotlin 类型</th><th>底层 SQL 类型</th><th>JDBC 类型码 (java.sql.Types)</th></tr></thead><tbody><tr><td>boolean</td><td>kotlin.Boolean</td><td>boolean</td><td>Types.BOOLEAN</td></tr><tr><td>int</td><td>kotlin.Int</td><td>int</td><td>Types.INTEGER</td></tr><tr><td>short</td><td>kotlin.Short</td><td>smallint</td><td>Types.SMALLINT</td></tr><tr><td>long</td><td>kotlin.Long</td><td>bigint</td><td>Types.BIGINT</td></tr><tr><td>float</td><td>kotlin.Float</td><td>float</td><td>Types.FLOAT</td></tr><tr><td>double</td><td>kotlin.Double</td><td>double</td><td>Types.DOUBLE</td></tr><tr><td>decimal</td><td>java.math.BigDecimal</td><td>decimal</td><td>Types.DECIMAL</td></tr><tr><td>varchar</td><td>kotlin.String</td><td>varchar</td><td>Types.VARCHAR</td></tr><tr><td>text</td><td>kotlin.String</td><td>text</td><td>Types.LONGVARCHAR</td></tr><tr><td>blob</td><td>kotlin.ByteArray</td><td>blob</td><td>Types.BLOB</td></tr><tr><td>bytes</td><td>kotlin.ByteArray</td><td>bytes</td><td>Types.BINARY</td></tr><tr><td>jdbcTimestamp</td><td>java.sql.Timestamp</td><td>timestamp</td><td>Types.TIMESTAMP</td></tr><tr><td>jdbcDate</td><td>java.sql.Date</td><td>date</td><td>Types.DATE</td></tr><tr><td>jdbcTime</td><td>java.sql.Time</td><td>time</td><td>Types.TIME</td></tr><tr><td>timestamp</td><td>java.time.Instant</td><td>timestamp</td><td>Types.TIMESTAMP</td></tr><tr><td>datetime</td><td>java.time.LocalDateTime</td><td>datetime</td><td>Types.TIMESTAMP</td></tr><tr><td>date</td><td>java.time.LocalDate</td><td>date</td><td>Types.DATE</td></tr><tr><td>time</td><td>java.time.Time</td><td>time</td><td>Types.TIME</td></tr><tr><td>monthDay</td><td>java.time.MonthDay</td><td>varchar</td><td>Types.VARCHAR</td></tr><tr><td>yearMonth</td><td>java.time.YearMonth</td><td>varchar</td><td>Types.VARCHAR</td></tr><tr><td>year</td><td>java.time.Year</td><td>int</td><td>Types.INTEGER</td></tr><tr><td>enum</td><td>kotlin.Enum</td><td>enum</td><td>Types.VARCHAR</td></tr><tr><td>uuid</td><td>java.util.UUID</td><td>uuid</td><td>Types.OTHER</td></tr></tbody></table></figure><h2 id="扩展更多的类型"><a class="markdownIt-Anchor" href="#扩展更多的类型"></a> 扩展更多的类型</h2><p>有时候，Ktorm 内置的这些数据类型可能并不能完全满足你的需求，比如你希望在数据库中存储一个 json 字段，许多关系数据库都已经支持了 json 类型，但是原生 JDBC 并不支持，Ktorm 也并没有默认支持。这时你可以自己提供一个 <code>SqlType</code> 的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JsonSqlType</span>&lt;<span class="type">T : Any</span>&gt;(</span><br><span class="line">    <span class="keyword">val</span> objectMapper: ObjectMapper,</span><br><span class="line">    <span class="keyword">val</span> javaType: JavaType</span><br><span class="line">) : SqlType&lt;T&gt;(Types.VARCHAR, <span class="string">&quot;json&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSetParameter</span><span class="params">(ps: <span class="type">PreparedStatement</span>, index: <span class="type">Int</span>, parameter: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        ps.setString(index, objectMapper.writeValueAsString(parameter))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doGetResult</span><span class="params">(rs: <span class="type">ResultSet</span>, index: <span class="type">Int</span>)</span></span>: T? &#123;</span><br><span class="line">        <span class="keyword">val</span> json = rs.getString(index)</span><br><span class="line">        <span class="keyword">if</span> (json.isNullOrBlank()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.readValue(json, javaType)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个类使用 Jackson 框架进行 json 与对象之间的转换，提供了 json 数据类型的支持。有了 <code>JsonSqlType</code> 之后，怎样使用这个类型定义一个列呢？在前面 int 函数的实现中，我们注意到其中调用了 <code>registerColumn</code> 函数，这正是其中的秘诀，<code>registerColumn</code> 函数正是 Ktorm 提供的用来支持类型扩展的入口。我们可以写一个这样的扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> C : Any&gt;</span> BaseTable<span class="type">&lt;*&gt;</span>.<span class="title">json</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    mapper: <span class="type">ObjectMapper</span> = sharedObjectMapper</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Column&lt;C&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> registerColumn(name, JsonSqlType(mapper, mapper.constructType(typeOf&lt;C&gt;())))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Foo : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">&quot;foo&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> bar = json&lt;List&lt;<span class="built_in">Int</span>&gt;&gt;(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，Ktorm 就能无缝支持 json 字段的存取，事实上，这正是 ktorm-jackson 模块的功能之一。如果你真的需要使用 json 字段，请直接在项目中添加依赖即可，不必再写一遍上面的代码，这里仅作示范。</p><p>Maven 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ktorm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ktorm-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;ktorm.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者 gradle：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">&quot;org.ktorm:ktorm-jackson:$&#123;ktorm.version&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>最后，Ktorm 2.7 版本还新增了一个 <code>transform</code> 函数，使用这个函数，我们可以基于现有的数据类型进行扩展，增加一些自定义的转换行为，得到新的数据类型，而不必手动写一个 <code>SqlType</code> 的实现类。</p><p>例如下面的例子，我们定义了一个类型为 <code>Column&lt;UserRole&gt;</code> 的列，但是在数据库中保存的还是 <code>int</code> 值，只是在获取结果及设置参数到 <code>PreparedStatement</code> 时执行了一定的转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> role = int(<span class="string">&quot;role&quot;</span>).transform(&#123; UserRole.fromCode(it) &#125;, &#123; it.code &#125;)</span><br></pre></td></tr></table></figure><p>需要注意的是，这个转换在获取每条结果时都会执行一次，所以在这里不要有太重的行为，以免对性能造成影响。</p><div id="support-footer-container"><div class="doc-support-footer"><div class="doc-footer-link">上一篇：<a href="/zh-cn/spring-support.html">Spring 支持</a></div><div class="doc-footer-link">下一篇：<a href="/zh-cn/query.html">查询</a></div>对文档内容有疑问？请在侧边栏尝试搜索或者在 GitHub <a href="https://github.com/kotlin-orm/ktorm/issues/new">提出 issue</a></div></div></article></div></div><div class="doc-footer">&copy; 2025 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script></body></html>