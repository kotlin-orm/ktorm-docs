<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Ktorm | 联表</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch-css@3.6.2/style.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"联表",lang:"zh-cn",related_path:"en/joining.html",path:"zh-cn/joining.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"GETTING STARTED",type:"label"},{text:"Overview",type:"link",path:"/"},{text:"Quick Start",type:"link",path:"en/quick-start.html"},{text:"CONNECTION MANAGEMENT",type:"label"},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html"},{text:"Transaction Management",type:"link",path:"en/transaction-management.html"},{text:"Spring Support",type:"link",path:"en/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"Schema Definition",type:"link",path:"en/schema-definition.html"},{text:"Query",type:"link",path:"en/query.html"},{text:"Joining",type:"link",path:"en/joining.html"},{text:"Data Manipulation",type:"link",path:"en/dml.html"},{text:"Operators",type:"link",path:"en/operators.html"},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html"},{text:"ENTITY API",type:"label"},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html"},{text:"Entity Query",type:"link",path:"en/entity-finding.html"},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html"},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html"},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html"},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html"},{text:"SUPPORT & FEEDBACK",type:"label"},{text:"API Documents",type:"support-link",path:"api-docs/index.html",target:"_blank"},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank"},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html"}]},"navigation-zh-cn":{home:[{title:"快速上手",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"开始",type:"label"},{text:"简介",type:"link",path:"zh-cn/"},{text:"快速上手",type:"link",path:"zh-cn/quick-start.html"},{text:"连接管理",type:"label"},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html"},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html"},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html"},{text:"查询",type:"link",path:"zh-cn/query.html"},{text:"联表",type:"link",path:"zh-cn/joining.html"},{text:"增删改",type:"link",path:"zh-cn/dml.html"},{text:"运算符",type:"link",path:"zh-cn/operators.html"},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html"},{text:"实体类 API",type:"label"},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html"},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html"},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html"},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html"},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html"},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html"},{text:"支持和反馈",type:"label"},{text:"API 文档",type:"support-link",path:"api-docs/index.html",target:"_blank"},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank"},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html"}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc"}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation"><nav class="doc-navbar"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="doc-navbar__logo"><a href="/zh-cn/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close"></i><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/joining.html">English</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"></span></button></div><ul class="doc-sidebar-list"></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/joining.html">English</a></span></span></div><div class="dc-page"><div class="dc-card"><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/zh-cn/joining.md"><i class="icon fa fa-github"></i> <span class="text">编辑本页</span></a><h1 id="联表"><a class="markdownIt-Anchor" href="#联表"></a> 联表</h1><p>在上一节中，我们介绍了查询的 SQL DSL，这足以应付许多的场景。不过前面的查询都只限于单表，在大部分情况下，我们的业务都需要多个表来完成。连接查询的支持，对于一个 ORM 框架而言必不可少。</p><h2 id="连接函数"><a class="markdownIt-Anchor" href="#连接函数"></a> 连接函数</h2><p>Ktorm 使用扩展函数对连接查询提供支持，内置的标准连接类型有四种：</p><figure class="table-wrapper"><table><thead><tr><th>连接类型</th><th>扩展函数名</th><th>对应的 SQL 关键字</th></tr></thead><tbody><tr><td>交叉连接</td><td>crossJoin</td><td>cross join</td></tr><tr><td>内连接</td><td>innerJoin</td><td>inner join</td></tr><tr><td>左外连接</td><td>leftJoin</td><td>left join</td></tr><tr><td>右外连接</td><td>rightJoin</td><td>right join</td></tr><tr><td>全外连接</td><td>fullJoin</td><td>full join</td></tr></tbody></table></figure><p>以上函数都是 <code>QuerySource</code> 的扩展函数，最简单的使用方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> querySource = database.from(Employees).crossJoin(Departments)</span><br></pre></td></tr></table></figure><p>我们知道，<code>from</code> 函数的功能是把一个表对象包装成 <code>QuerySource</code> 对象，而 <code>crossJoin</code> 则把它的结果与另一个表进行交叉连接，返回一个新的 <code>QuerySource</code>。然而，大部分时候，我们持有一个 <code>QuerySource</code> 并没有任何用处，我们需要将它变成一个 <code>Query</code> 对象，以便进行多表查询，并取得查询的结果。</p><p>还记得怎样使用 <code>QuerySource</code> 创建一个查询吗？是的，只需要调用 <code>select</code> 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database.from(Employees).crossJoin(Departments).select()</span><br></pre></td></tr></table></figure><p>上面的查询把员工表和部门表进行交叉连接，并返回所有记录（笛卡尔积），生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">join</span> t_department </span><br></pre></td></tr></table></figure><p>上面的查询比较简单，在实际使用中，如此简单的联表查询通常都用处有限。接下来是一个比较实际的例子，这个查询获取所有薪水大于 100 的员工的名字和他所属的部门的名字。在这里，我们指定了 <code>leftJoin</code> 函数的第二个参数，它就是连接条件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .leftJoin(Departments, on = Employees.departmentId eq Departments.id)</span><br><span class="line">    .select(Employees.name, Departments.name)</span><br><span class="line">    .<span class="keyword">where</span> &#123; Employees.salary gt <span class="number">100L</span> &#125;</span><br></pre></td></tr></table></figure><p>生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.name <span class="keyword">as</span> t_employee_name, t_department.name <span class="keyword">as</span> t_department_name </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> t_department.id </span><br><span class="line"><span class="keyword">where</span> t_employee.salary <span class="operator">&gt;</span> ? </span><br></pre></td></tr></table></figure><h2 id="自连接查询与表别名"><a class="markdownIt-Anchor" href="#自连接查询与表别名"></a> 自连接查询与表别名</h2><p>自连接是连接查询的一种特殊用法，它支持把一个表与它自身进行连接，比如下面这句 SQL 就使用了自连接，它查询每个员工的名字、他直属上司的名字以及他所属部门的名称：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.name <span class="keyword">as</span> emp_name, mgr.name <span class="keyword">as</span> mgr_name, dept.name <span class="keyword">as</span> dept_name </span><br><span class="line"><span class="keyword">from</span> t_employee emp </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_employee mgr <span class="keyword">on</span> emp.manager_id <span class="operator">=</span> mgr.id </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department dept <span class="keyword">on</span> emp.department_id <span class="operator">=</span> dept.id </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> emp.id </span><br></pre></td></tr></table></figure><p>可以看到，在这句 SQL 中，<code>t_employee</code> 表出现了两次，但是它们拥有不同的别名，分别是 <code>emp</code> 和 <code>mgr</code>，正是这两个别名区分开了连接查询中的两个相同的表。那么在 Ktorm 中，我们如何实现这样的查询呢？</p><p>如果你有心的话，可能已经发现，<code>Table</code> 类中正好提供了一个 <code>aliased</code> 函数，它返回一个新的表对象，该对象复制自当前对象，具有完全相同的数据和结构，但是赋予了新的 <code>alias</code> 属性，这个函数正是在现在这个场景中使用的。使用 <code>aliased</code> 函数，尝试完成上面的自连接查询，你可能会写出这样的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Names</span>(<span class="keyword">val</span> name: String?, <span class="keyword">val</span> managerName: String?, <span class="keyword">val</span> departmentName: String?)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> emp = Employees.aliased(<span class="string">&quot;emp&quot;</span>) <span class="comment">// 第三行，对 Employees 表对象赋予别名</span></span><br><span class="line"><span class="keyword">val</span> mgr = Employees.aliased(<span class="string">&quot;mgr&quot;</span>) <span class="comment">// 第四行，对 Employees 表对象赋予另一个不同的别名</span></span><br><span class="line"><span class="keyword">val</span> dept = Departments.aliased(<span class="string">&quot;dept&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> results = database</span><br><span class="line">    .from(emp)</span><br><span class="line">    .leftJoin(mgr, on = emp.managerId eq mgr.id) <span class="comment">// 第八行，连接两个不同的 Employees 表</span></span><br><span class="line">    .leftJoin(dept, on = emp.departmentId eq dept.id)</span><br><span class="line">    .select(emp.name, mgr.name, dept.name)</span><br><span class="line">    .orderBy(emp.id.asc())</span><br><span class="line">    .map &#123; row -&gt; </span><br><span class="line">        Names(</span><br><span class="line">            name = row[emp.name],</span><br><span class="line">            managerName = row[mgr.name],</span><br><span class="line">            departmentName = row[dept.name]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的代码很符合直觉，也正是 Ktorm 的 SQL DSL 所推荐的书写风格，但遗憾的是，它很有可能无法通过编译。为了帮助我们分析这个错误，在这里先贴出 <code>Employees</code> 表对象的定义，这个定义复制自<a href="./schema-definition.html#%E8%A1%A8%E5%AF%B9%E8%B1%A1">定义表结构 - 表对象</a>一节：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Employees : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">&quot;t_employee&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">&quot;id&quot;</span>).primaryKey()</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = varchar(<span class="string">&quot;job&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> managerId = int(<span class="string">&quot;manager_id&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> hireDate = date(<span class="string">&quot;hire_date&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> salary = long(<span class="string">&quot;salary&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> departmentId = int(<span class="string">&quot;department_id&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而父类 <code>Table</code> 中 <code>aliased</code> 方法的签名则是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">aliased</span><span class="params">(alias: <span class="type">String</span>)</span></span>: Table&lt;E&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>很显然，根据 <code>aliased</code> 方法的签名，上面第三行中的 <code>Employees.aliased(&quot;emp&quot;)</code> 得到的返回值的类型应该是 <code>Table&lt;E&gt;</code>，第四行中的 <code>mgr</code> 变量的类型也是如此。那么，第八行中的 <code>emp.managerId eq mrg.id</code> 明显就是错误的了，因为 <code>id</code> 和 <code>managerId</code> 两个属性只在 <code>Employees</code> 对象中存在，而这里的两个具有别名的表对象的类型都是 <code>Table&lt;E&gt;</code>，而不是 <code>Employees</code>。</p><p>受限于 Kotlin 语言的限制，<code>Table.aliased</code> 函数虽然能够完成复制表结构并赋予别名的功能，但它的返回值只能是 <code>Table&lt;E&gt;</code>，而无法与它的调用者具有完全相同的类型。例如在这里我们使用 object 关键字将 <code>Employees</code> 定义为单例的表对象，由于 Kotlin 的单例限制，<code>aliased</code> 方法创建的新的表对象不可能也是 <code>Employees</code>。</p><p>为了正常实现自连接查询，我们推荐，<strong>如果需要使用到表别名功能，请勿将表对象定义为 object，而应该使用 class 代替，并重写 <code>aliased</code> 方法使其返回完全相同的类型</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employees</span>(alias: String?) : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">&quot;t_employee&quot;</span>, alias) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">aliased</span><span class="params">(alias: <span class="type">String</span>)</span></span> = Employees(alias)</span><br><span class="line">    <span class="comment">// 此处省略无关的列定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，单纯把 object 改成 class 也会遇到问题，比如无法再使用 <code>Employees.name</code> 的写法快速获取一个列，而必须要先调用构造方法创建一个表对象。因此，我们还推荐<strong>在将表定义为 class 的同时，提供一个伴随对象，作为未赋予别名的默认表对象，这样既支持了原来的写法，又能使用表别名的功能</strong>。最终的 <code>Employees</code> 定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Employees</span>(alias: String?) : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">&quot;t_employee&quot;</span>, alias) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Employees(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">aliased</span><span class="params">(alias: <span class="type">String</span>)</span></span> = Employees(alias)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">&quot;id&quot;</span>).primaryKey()</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = varchar(<span class="string">&quot;job&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> managerId = int(<span class="string">&quot;manager_id&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> hireDate = date(<span class="string">&quot;hire_date&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> salary = long(<span class="string">&quot;salary&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> departmentId = int(<span class="string">&quot;department_id&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 Ktorm 提供的表别名的支持。现在你可以再尝试执行一下前面的自连接查询，如无意外，它现在应该已经可以完美生成 SQL，返回结果了。</p><h2 id="扩展连接类型"><a class="markdownIt-Anchor" href="#扩展连接类型"></a> 扩展连接类型</h2><p>Ktorm 的核心模块只提供了四种标准的连接类型（见<a href="#%E8%BF%9E%E6%8E%A5%E5%87%BD%E6%95%B0">连接函数</a>一节），一般来说，这四种连接类型已经足够应付我们的业务，但是，如果我们想使用某些数据库特有的连接类型，该如何做呢？下面我们以 MySQL 中的自然连接（natural join）为例对此问题进行探讨。</p><p>查看源码，我们可以知道，<code>JoinExpression</code> 继承于 <code>QuerySourceExpression</code>，这是一个抽象类。我们也可以创建一个 <code>NaturalJoinExpression</code> 类继承于 <code>QuerySourceExpression</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">NaturalJoinExpression</span>(</span><br><span class="line">    <span class="keyword">val</span> left: QuerySourceExpression,</span><br><span class="line">    <span class="keyword">val</span> right: QuerySourceExpression,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> isLeafNode: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">) : QuerySourceExpression()</span><br></pre></td></tr></table></figure><p>有了定制的表达式类型以后，我们需要添加一个扩展函数，就像上面的 <code>crossJoin</code>、<code>leftJoin</code> 等扩展函数一样，用于将 <code>QuerySource</code> 对象中的 <code>expression</code> 替换为 <code>NaturalJoinExpression</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> QuerySource.<span class="title">naturalJoin</span><span class="params">(right: <span class="type">BaseTable</span>&lt;*&gt;)</span></span>: QuerySource &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.copy(expression = NaturalJoinExpression(left = expression, right = right.asExpression()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ktorm 默认情况下无法识别我们自己创建的表达式类型 <code>NaturalJoinExpression</code>，因此无法生成支持 <code>natural join</code> 的 SQL 语句。这时，我们可以扩展 <code>SqlFormatter</code> 类，重写它的 <code>visitUnknown</code> 方法，在里面检测我们的自定义表达式，为其生成正确的 SQL：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomSqlFormatter</span>(database: Database, beautifySql: <span class="built_in">Boolean</span>, indentSize: <span class="built_in">Int</span>)</span><br><span class="line">    : MySqlFormatter(database, beautifySql, indentSize) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitUnknown</span><span class="params">(expr: <span class="type">SqlExpression</span>)</span></span>: SqlExpression &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr <span class="keyword">is</span> NaturalJoinExpression) &#123;</span><br><span class="line">            visitQuerySource(expr.left)</span><br><span class="line">            newLine(Indentation.SAME)</span><br><span class="line">            write(<span class="string">&quot;natural join &quot;</span>)</span><br><span class="line">            visitQuerySource(expr.right)</span><br><span class="line">            <span class="keyword">return</span> expr</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitUnknown(expr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，使用方言（Dialect）将这个自定义的 SqlFormatter 注册到 <code>Database</code> 对象中。更多关于<a href="./dialects-and-native-sql.html">方言</a>的细节，可参考后面的章节。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> database = Database.connect(</span><br><span class="line">    url = <span class="string">&quot;jdbc:mysql://localhost:3306/ktorm&quot;</span>, user = <span class="string">&quot;root&quot;</span>, password = <span class="string">&quot;***&quot;</span>,</span><br><span class="line">    dialect = <span class="keyword">object</span> : SqlDialect &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createSqlFormatter</span><span class="params">(database: <span class="type">Database</span>, beautifySql: <span class="type">Boolean</span>, indentSize: <span class="type">Int</span>)</span></span>: SqlFormatter &#123;</span><br><span class="line">            <span class="keyword">return</span> CustomSqlFormatter(database, beautifySql, indentSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>大功告成，<code>naturalJoin</code> 的使用方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database.from(Employees).naturalJoin(Departments).select()</span><br></pre></td></tr></table></figure><p>这样，Ktorm 就能够无缝支持自然连接，事实上，这正是 ktorm-support-mysql 模块的功能之一，如果你真的需要使用 MySQL 的自然连接，请直接在项目中添加依赖，不必再写一遍上面的代码，这里仅作示范。</p><p>Maven 依赖：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ktorm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ktorm-support-mysql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;ktorm.version&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>或者 gradle：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">&quot;org.ktorm:ktorm-support-mysql:$&#123;ktorm.version&#125;&quot;</span></span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer"><div class="doc-footer-link">上一篇：<a href="/zh-cn/query.html">查询</a></div><div class="doc-footer-link">下一篇：<a href="/zh-cn/dml.html">增删改</a></div>对文档内容有疑问？请在侧边栏尝试搜索或者在 GitHub <a href="https://github.com/kotlin-orm/ktorm/issues/new">提出 issue</a></div></div></article></div></div><div class="doc-footer">&copy; 2024 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script><script>$(".kotlin .code .keyword").each(function(){var e=$(this);"where"!==e.text()&&"set"!==e.text()||e.removeClass("keyword")})</script></body></html>