<!-- build time:Fri Apr 02 2021 22:55:18 GMT+0800 (China Standard Time) --><!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Ktorm | 增删改</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"增删改",lang:"zh-cn",related_path:"en/dml.html",path:"zh-cn/dml.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"Overview",type:"link",path:"",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!0}]},"navigation-zh-cn":{home:[{title:"快速开始",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"概述",type:"link",path:"zh-cn/",isCurrent:!1},{text:"快速开始",type:"link",path:"zh-cn/quick-start.html",isCurrent:!1},{text:"连接管理",type:"label",isCurrent:!1},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html",isCurrent:!1},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html",isCurrent:!1},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html",isCurrent:!1},{text:"查询",type:"link",path:"zh-cn/query.html",isCurrent:!1},{text:"联表",type:"link",path:"zh-cn/joining.html",isCurrent:!1},{text:"增删改",type:"link",path:"zh-cn/dml.html",isCurrent:!1},{text:"运算符",type:"link",path:"zh-cn/operators.html",isCurrent:!1},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html",isCurrent:!1},{text:"实体类 API",type:"label",isCurrent:!1},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html",isCurrent:!1},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html",isCurrent:!0},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html",isCurrent:!1},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html",isCurrent:!1},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html",isCurrent:!1},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"支持和反馈",type:"label",isCurrent:!1},{text:"API 文档",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html",isCurrent:!1}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc",algolia:{appId:"2W81KMSLOD",apiKey:"2a146a809de068d9b7a07ba3fb70b4e5",indexName:"ktorm",chunkSize:5e3,fields:["title","lang","date","updated","_content:truncate,0,5200","path","permalink"]}}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><span class="doc-navbar__logo"><a href="/zh-cn/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/dml.html">English</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><div class="dc-search-form doc-search-form"><input type="search" id="doc-search-input" class="dc-input dc-search-form__input doc-search-form__input" placeholder="搜索文档" autofocus><button class="dc-btn dc-search-form__btn doc-search-form__btn" aria-label="Search"><i class="dc-icon dc-icon--search"></i></button></div></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/" target="_self"><span>概述</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/quick-start.html" target="_self"><span>快速开始</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>连接管理</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/connect-to-databases.html" target="_self"><span>连接数据库</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/transaction-management.html" target="_self"><span>事务管理</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/spring-support.html" target="_self"><span>Spring 支持</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/schema-definition.html" target="_self"><span>定义表结构</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/query.html" target="_self"><span>查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/joining.html" target="_self"><span>联表</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current"><a href="/zh-cn/dml.html" target="_self"><span>增删改</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/operators.html" target="_self"><span>运算符</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/dialects-and-native-sql.html" target="_self"><span>方言与原生 SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>实体类 API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entities-and-column-binding.html" target="_self"><span>实体类与列绑定</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-finding.html" target="_self"><span>实体查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-sequence.html" target="_self"><span>实体序列</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/sequence-aggregation.html" target="_self"><span>序列聚合</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-dml.html" target="_self"><span>实体增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/define-entities-as-any-kind-of-classes.html" target="_self"><span>使用任意的类作为实体类</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>支持和反馈</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/api-docs/index.html" target="_self"><span>API 文档</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_self"><span>问题反馈</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/sponsor.html" target="_self"><span>打赏作者</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher" data-reactroot=""><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/dml.html">English</a></span></span></div><div class="dc-page"><div class="dc-card"><div id="doc-search-results" class="doc-search-results"><div id="doc-search-stats"></div><div id="doc-search-hits"></div><div id="doc-search-pagination"></div></div><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/zh-cn/dml.md"><i class="icon fa fa-github"></i> <span class="text">编辑本页</span></a><h1 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h1><p>Ktorm 不仅提供了查询和联表的 DSL，而且还能方便地对数据进行增删改操作，下面我们开始介绍 Ktorm 的 DML DSL。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>Ktorm 使用 <code>insert</code> 函数来实现数据插入，它是 <code>Database</code> 类的扩展函数，签名如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : BaseTable&lt;*&gt;</span>&gt; Database.<span class="title">insert</span><span class="params">(table: <span class="type">T</span>, block: <span class="type">AssignmentsBuilder</span>.(<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><p><code>insert</code> 函数接受一个闭包作为参数，我们需要在这个闭包中指定插入的字段和它们的值，插入成功后，返回受影响的记录数，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">database.insert(Employees) &#123;</span><br><span class="line">    <span class="keyword">set</span>(it.name, <span class="string">"jerry"</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.job, <span class="string">"trainee"</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.managerId, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.hireDate, LocalDate.now())</span><br><span class="line">    <span class="keyword">set</span>(it.salary, <span class="number">50</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.departmentId, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_employee (<span class="keyword">name</span>, job, manager_id, hire_date, salary, department_id) <span class="keyword">values</span> (?, ?, ?, ?, ?, ?)</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出，在闭包函数中，我们可以使用 <code>set(it.name, &quot;jerry&quot;)</code> 为 name 字段赋值为 jerry，这是如何实现的呢？</p><p>这是因为闭包函数的类型是 <code>AssignmentsBuilder.(T) -&gt; Unit</code>，它接受一个 <code>T</code> 作为参数，而 <code>T</code> 正是第一个参数所指定的表对象，所以我们可以在闭包中使用 <code>it</code> 获取表对象，进而获取到它的字段。我们还发现，这个闭包函数同时也是 <code>AsssignmentsBuilder</code> 类的扩展函数，因此，在闭包的范围内，<code>this</code> 引用指向的是一个 <code>AssignmentsBuilder</code> 对象，因此我们可以调用到它的成员函数 <code>set</code>。</p><p>有时我们的表会使用自增主键，我们可能希望在插入一条数据后，能够获取到数据库自动生成的主键，这时我们可以使用 <code>insertAndGenerateKey</code> 函数。与 <code>insert</code> 函数不同，它不再返回受影响的记录数，而是返回自动生成的主键，除此之外，其他用法完全一致。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> id = database.insertAndGenerateKey(Employees) &#123;</span><br><span class="line">    <span class="keyword">set</span>(it.name, <span class="string">"jerry"</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.job, <span class="string">"trainee"</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.managerId, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.hireDate, LocalDate.now())</span><br><span class="line">    <span class="keyword">set</span>(it.salary, <span class="number">50</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.departmentId, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候，我们需要一次性插入许多条数据，而循环调用 <code>insert</code> 方法的性能可能无法忍受。Ktorm 提供了一个 <code>batchInsert</code> 函数，它基于原生 JDBC 提供的 <code>executeBatch</code> 函数实现，可以提高批量操作的性能。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">database.batchInsert(Employees) &#123;</span><br><span class="line">    item &#123;</span><br><span class="line">        <span class="keyword">set</span>(it.name, <span class="string">"jerry"</span>)</span><br><span class="line">        <span class="keyword">set</span>(it.job, <span class="string">"trainee"</span>)</span><br><span class="line">        <span class="keyword">set</span>(it.managerId, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">set</span>(it.hireDate, LocalDate.now())</span><br><span class="line">        <span class="keyword">set</span>(it.salary, <span class="number">50</span>)</span><br><span class="line">        <span class="keyword">set</span>(it.departmentId, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    item &#123;</span><br><span class="line">        <span class="keyword">set</span>(it.name, <span class="string">"linda"</span>)</span><br><span class="line">        <span class="keyword">set</span>(it.job, <span class="string">"assistant"</span>)</span><br><span class="line">        <span class="keyword">set</span>(it.managerId, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">set</span>(it.hireDate, LocalDate.now())</span><br><span class="line">        <span class="keyword">set</span>(it.salary, <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">set</span>(it.departmentId, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>batchInsert</code> 函数也接受一个闭包函数作为参数，这个闭包函数的类型是 <code>BatchInsertStatementBuilder&lt;T&gt;.() -&gt; Unit</code>，而 <code>item</code> 正是 <code>BatchInsertStatementBuilder</code> 的成员函数。我们使用 <code>item</code> 函数指定批量插入的每一条数据，通常，<code>item</code> 函数应该会在一个循环中调用。批量插入成功后，返回一个 <code>IntArray</code>，它包含每个子操作所影响的记录数。</p><p>有时候，我们会遇到一些转移数据的需求，需要将一个表的数据转移到另一个表。Ktorm 提供了一个 <code>insertTo</code> 函数，它是 <code>Query</code> 类的扩展函数，用于将一个查询的结果插入到指定的表中。相比于先获取查询的结果，然后调用 <code>batchInsert</code> 批量插入数据的方式，<code>insertTo</code> 只执行了一条 SQL，性能大大提升。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">database</span><br><span class="line">    .from(Departments)</span><br><span class="line">    .select(Departments.name, Departments.location)</span><br><span class="line">    .<span class="keyword">where</span> &#123; Departments.id eq <span class="number">1</span> &#125;</span><br><span class="line">    .insertTo(Departments, Departments.name, Departments.location)</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_department (<span class="keyword">name</span>, location) </span><br><span class="line"><span class="keyword">select</span> t_department.name <span class="keyword">as</span> t_department_name, t_department.location <span class="keyword">as</span> t_department_location </span><br><span class="line"><span class="keyword">from</span> t_department </span><br><span class="line"><span class="keyword">where</span> t_department.id = ?</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>Ktorm 使用 <code>update</code> 函数实现数据更新，它也是 <code>Database</code> 类的扩展函数，签名如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : BaseTable&lt;*&gt;</span>&gt; Database.<span class="title">update</span><span class="params">(table: <span class="type">T</span>, block: <span class="type">UpdateStatementBuilder</span>.(<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><p>与 <code>insert</code> 函数类似，它也接受一个闭包作为参数，更新成功后，返回受影响的记录数。闭包函数的类型是 <code>UpdateStatementBuilder.(T) -&gt; Unit</code>，其中，<code>UpdateStatementBuilder</code> 正是 <code>AssignmentsBuilder</code> 的子类，所以在这里我们仍然可以使用 <code>set(it.name, &quot;jerry&quot;)</code> 的写法为 name 字段赋值为 jerry。不同的是，<code>UpdateStatementBuilder</code> 增加了一个 <code>where</code> 函数，用于指定更新的条件。使用方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">database.update(Employees) &#123;</span><br><span class="line">    <span class="keyword">set</span>(it.job, <span class="string">"engineer"</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.managerId, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.salary, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">where</span> &#123;</span><br><span class="line">        it.id eq <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_employee <span class="keyword">set</span> job = ?, manager_id = ?, salary = ? <span class="keyword">where</span> <span class="keyword">id</span> = ?</span><br></pre></td></tr></table></figure><p>值得注意的是，<code>set</code> 函数的第二个参数不仅可以是一个值，也可以是一个表达式，即一个字段不仅可以更新为一个固定值，也可更新为指定表达式的计算结果。我们可以利用此特性实现一些特殊的功能，比如为某个员工增加 100 薪水：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">database.update(Employees) &#123;</span><br><span class="line">    <span class="keyword">set</span>(it.salary, it.salary + <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">where</span> &#123; </span><br><span class="line">        it.id eq <span class="number">1</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_employee <span class="keyword">set</span> salary = salary + ? <span class="keyword">where</span> <span class="keyword">id</span> = ?</span><br></pre></td></tr></table></figure><p>有时候，我们需要一次性更新多条数据，而循环调用 <code>update</code> 方法的性能可能难以忍受。这时，我们可以使用 <code>batchUpdate</code> 函数，与 <code>batchInsert</code> 类似，它基于原生 JDBC 提供的 <code>executeBatch</code> 函数实现，可以提高批量操作的性能。下面的操作将 id 为 1 和 2 的部门的 location 字段更新为 Hong Kong，当然我们也可以不用 <code>batchUpdate</code> 而是把更新条件指定为 <code>it.id between 1..2</code>，这里只是为了示范。可以看到，它的用法与 <code>batchInsert</code> 函数十分类似，只是多了一个 <code>where</code> 函数用于指定更新条件。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">database.batchUpdate(Departments) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">2</span>) &#123;</span><br><span class="line">        item &#123;</span><br><span class="line">            <span class="keyword">set</span>(it.location, <span class="string">"Hong Kong"</span>)</span><br><span class="line">            <span class="keyword">where</span> &#123;</span><br><span class="line">                it.id eq i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>Ktorm 使用 <code>delete</code> 函数实现数据删除，它也是 <code>Database</code> 类的扩展函数，签名如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : BaseTable&lt;*&gt;</span>&gt; Database.<span class="title">delete</span><span class="params">(table: <span class="type">T</span>, predicate: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">Boolean</span>&gt;)</span></span>: <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><p><code>delete</code> 接受一个闭包函数作为参数，我们需要在闭包函数中指定删除的数据的条件，删除完成后，返回受影响的记录数。闭包函数接受一个 <code>T</code> 作为参数，而 <code>T</code> 正是当前表对象，因此我们可以在闭包中使用 <code>it</code> 获取表对象。使用方法非常简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">database.delete(Employees) &#123; it.id eq <span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure><p>这个操作将 id 为 4 的员工从数据库中删除。</p><div id="support-footer-container"><div class="doc-support-footer" data-reactroot=""><div class="doc-footer-link">上一篇：<a href="/zh-cn/joining.html">联表</a></div><div class="doc-footer-link">下一篇：<a href="/zh-cn/operators.html">运算符</a></div>对文档内容有疑问？请在侧边栏尝试搜索或者在 GitHub <a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank" rel="noopener">提出 issue</a></div></div></article></div></div><div class="doc-footer">&copy; 2021 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm" target="_blank" rel="noopener">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/script/doc.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script><script type="text/javascript">docsearch({apiKey:"8cd6a3b7dc33b50b89c7e9b11110717a",indexName:"ktorm",inputSelector:"#doc-search-input",algoliaOptions:{facetFilters:["lang:zh-cn","tags:doc"]},autocompleteOptions:{hint:!1,appendTo:"body"},debug:!1})</script><script>!function(){$(".kotlin .code .keyword").each(function(){var e=$(this);("where"===e.text()||"set"===e.text())&&e.removeClass("keyword")})}()</script></body></html><!-- rebuild by neat -->