<!-- build time:Sun Jun 05 2022 16:42:51 GMT+0800 (CST) --><!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Ktorm | 实体类与列绑定</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"实体类与列绑定",lang:"zh-cn",related_path:"en/entities-and-column-binding.html",path:"zh-cn/entities-and-column-binding.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"Overview",type:"link",path:"",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!0},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]},"navigation-zh-cn":{home:[{title:"快速开始",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"概述",type:"link",path:"zh-cn/",isCurrent:!1},{text:"快速开始",type:"link",path:"zh-cn/quick-start.html",isCurrent:!1},{text:"连接管理",type:"label",isCurrent:!1},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html",isCurrent:!1},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html",isCurrent:!1},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html",isCurrent:!1},{text:"查询",type:"link",path:"zh-cn/query.html",isCurrent:!1},{text:"联表",type:"link",path:"zh-cn/joining.html",isCurrent:!1},{text:"增删改",type:"link",path:"zh-cn/dml.html",isCurrent:!0},{text:"运算符",type:"link",path:"zh-cn/operators.html",isCurrent:!1},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html",isCurrent:!1},{text:"实体类 API",type:"label",isCurrent:!1},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html",isCurrent:!1},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html",isCurrent:!1},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html",isCurrent:!1},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html",isCurrent:!1},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html",isCurrent:!1},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"支持和反馈",type:"label",isCurrent:!1},{text:"API 文档",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html",isCurrent:!1}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc",algolia:{appId:"2W81KMSLOD",apiKey:"2a146a809de068d9b7a07ba3fb70b4e5",indexName:"ktorm",chunkSize:5e3,fields:["title","lang","date","updated","_content:truncate,0,5200","path","permalink"]}}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><span class="doc-navbar__logo"><a href="/zh-cn/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/entities-and-column-binding.html">English</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><div class="dc-search-form doc-search-form"><input type="search" id="doc-search-input" class="dc-input dc-search-form__input doc-search-form__input" placeholder="搜索文档" autofocus><button class="dc-btn dc-search-form__btn doc-search-form__btn" aria-label="Search"><i class="dc-icon dc-icon--search"></i></button></div></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/" target="_self"><span>概述</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/quick-start.html" target="_self"><span>快速开始</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>连接管理</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/connect-to-databases.html" target="_self"><span>连接数据库</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/transaction-management.html" target="_self"><span>事务管理</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/spring-support.html" target="_self"><span>Spring 支持</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/schema-definition.html" target="_self"><span>定义表结构</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/query.html" target="_self"><span>查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/joining.html" target="_self"><span>联表</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/dml.html" target="_self"><span>增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/operators.html" target="_self"><span>运算符</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/dialects-and-native-sql.html" target="_self"><span>方言与原生 SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>实体类 API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current"><a href="/zh-cn/entities-and-column-binding.html" target="_self"><span>实体类与列绑定</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-finding.html" target="_self"><span>实体查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-sequence.html" target="_self"><span>实体序列</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/sequence-aggregation.html" target="_self"><span>序列聚合</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-dml.html" target="_self"><span>实体增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/define-entities-as-any-kind-of-classes.html" target="_self"><span>使用任意的类作为实体类</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>支持和反馈</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/api-docs/index.html" target="_self"><span>API 文档</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_self"><span>问题反馈</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/sponsor.html" target="_self"><span>打赏作者</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher" data-reactroot=""><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/entities-and-column-binding.html">English</a></span></span></div><div class="dc-page"><div class="dc-card"><div id="doc-search-results" class="doc-search-results"><div id="doc-search-stats"></div><div id="doc-search-hits"></div><div id="doc-search-pagination"></div></div><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/zh-cn/entities-and-column-binding.md"><i class="icon fa fa-github"></i> <span class="text">编辑本页</span></a><h1 id="实体类与列绑定"><a href="#实体类与列绑定" class="headerlink" title="实体类与列绑定"></a>实体类与列绑定</h1><p>前面我们已经介绍了 SQL DSL，但是如果只有 DSL，Ktorm 还远不能称为一个 ORM 框架。接下来我们将介绍实体类的概念，了解如何将数据库中的表与实体类进行绑定，这正是 ORM 框架的核心：对象 - 关系映射。</p><h2 id="定义实体类"><a href="#定义实体类" class="headerlink" title="定义实体类"></a>定义实体类</h2><p>我们仍然以前面的部门表 <code>t_department</code> 和员工表 <code>t_employee</code> 为例，创建两个 Ktorm 的实体类，分别用来表示部门和员工这两个业务概念：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Department</span> : <span class="type">Entity</span>&lt;<span class="type">Department</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">var</span> location: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Employee</span> : <span class="type">Entity</span>&lt;<span class="type">Employee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">var</span> job: String</span><br><span class="line">    <span class="keyword">var</span> manager: Employee?</span><br><span class="line">    <span class="keyword">var</span> hireDate: LocalDate</span><br><span class="line">    <span class="keyword">var</span> salary: <span class="built_in">Long</span></span><br><span class="line">    <span class="keyword">var</span> department: Department</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Ktorm 中的实体类都继承了 <code>Entity&lt;E&gt;</code> 接口，这个接口为实体类注入了一些通用的方法。实体类的属性则使用 var 或 val 关键字直接定义即可，根据需要确定属性的类型及是否为空。有一点可能会违背你的直觉，Ktorm 中的实体类并不是 data class，甚至也不是一个普通的 class，而是 interface。这是 Ktorm 的设计要求，通过将实体类定义为 interface，Ktorm 才能够实现一些特别的功能，以后你会了解到它的意义。</p><blockquote><p>从 Ktorm 2.5 版本开始，我们也支持使用 data class 或其他任意的类定义实体类，参见<a href="./define-entities-as-any-kind-of-classes.html">使用任意的类作为实体类</a>。</p></blockquote><p>众所周知，接口并不能被实例化，既然实体类被定义为接口，我们要如何才能创建一个实体对象呢？Ktorm 提供了一个 <code>Entity.create</code> 函数，这个函数会使用 JDK 动态代理生成实体类接口的实现，并为我们创建一个实体对象。要创建一个部门对象，可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> department = Entity.create&lt;Department&gt;()</span><br></pre></td></tr></table></figure><p>如果你不喜欢这样创建实体对象，Ktorm 还提供了一个 <code>Entity.Factory</code> 抽象类，你可以在实体类中添加一个伴随对象，继承 <code>Entity.Factory</code>，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Department</span> : <span class="type">Entity</span>&lt;<span class="type">Department</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Entity.Factory&lt;Department&gt;()</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">var</span> location: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>Entity.Factory</code> 类重载了 invoke 运算符，所以你可以把这个伴随对象当函数一样直接加上括号进行调用，创建一个部门对象的代码变成了这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> department = Department()</span><br></pre></td></tr></table></figure><p>这就是 Kotlin 的魅力，<code>Department</code> 明明是一个接口，你却能创建一个它的对象，而且看起来就像在调用构造函数一样。你还可以在创建实体类的同时，为它的属性赋上初始值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> department = Department &#123;</span><br><span class="line">    name = <span class="string">"tech"</span></span><br><span class="line">    location = <span class="string">"Guangzhou"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="列绑定"><a href="#列绑定" class="headerlink" title="列绑定"></a>列绑定</h2><p>ORM 框架的一大功能就是将数据表与实体类进行绑定、将表中的列与实体类中的属性进行绑定，现在我们来了解 Ktorm 如何实现这个功能。</p><p>在前面介绍 SQL DSL 的时候，我们已经创建了两个表对象，他们分别是部门表 <code>Departments</code> 和员工表 <code>Employees</code>，在表对象中，使用 int、long、varchar 等函数声明表中的列。这些声明列的函数的返回值都是 <code>Column&lt;C&gt;</code>，在这里，<code>C</code> 代表被声明的列的类型。</p><p>要将列绑定到实体类的属性十分简单，只需要链式调用 <code>Column</code> 的 <code>bindTo</code> 函数或 <code>references</code> 扩展 函数即可，下面的代码修改了前面的两个表对象，完成了 ORM 绑定：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Departments : Table&lt;Department&gt;(<span class="string">"t_department"</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">"id"</span>).primaryKey().bindTo &#123; it.id &#125;</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">"name"</span>).bindTo &#123; it.name &#125;</span><br><span class="line">    <span class="keyword">val</span> location = varchar(<span class="string">"location"</span>).bindTo &#123; it.location &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Employees : Table&lt;Employee&gt;(<span class="string">"t_employee"</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">"id"</span>).primaryKey().bindTo &#123; it.id &#125;</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">"name"</span>).bindTo &#123; it.name &#125;</span><br><span class="line">    <span class="keyword">val</span> job = varchar(<span class="string">"job"</span>).bindTo &#123; it.job &#125;</span><br><span class="line">    <span class="keyword">val</span> managerId = int(<span class="string">"manager_id"</span>).bindTo &#123; it.manager.id &#125;</span><br><span class="line">    <span class="keyword">val</span> hireDate = date(<span class="string">"hire_date"</span>).bindTo &#123; it.hireDate &#125;</span><br><span class="line">    <span class="keyword">val</span> salary = long(<span class="string">"salary"</span>).bindTo &#123; it.salary &#125;</span><br><span class="line">    <span class="keyword">val</span> departmentId = int(<span class="string">"department_id"</span>).references(Departments) &#123; it.department &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名规约：强烈建议使用单数名词命名实体类，使用名词的复数形式命名表对象，如：Employee/Employees、Department/Departments。</p></blockquote><p>把两个表对象与修改前进行对比，我们可以发现两处不同：</p><ol><li><code>Table</code> 类的泛型参数，我们需要指定为实体类的类型，以便 Ktorm 将表对象与实体类进行绑定；在之前，我们设置为 <code>Nothing</code> 表示不绑定到任何实体类。</li><li>在每个列声明函数的调用后，都链式调用了 <code>bindTo</code> 或 <code>references</code> 函数将该列与实体类的某个属性进行绑定；如果没有这个调用，则不会绑定到任何属性。</li></ol><p>列绑定的意义在于，通过查询从数据库中获取实体对象的时候，Ktorm 会根据我们的绑定配置，将某个列的数据填充到它所绑定的属性中去；在将实体类中的修改更新回数据库中的时候（使用 <code>flushChanges</code> 函数），Ktorm 也会根据我们的绑定配置，将某个属性的变更，同步更新到绑定它的那个列。</p><p>Ktorm 提供以下几种不同的绑定类型：</p><ol><li><strong>简单绑定：</strong>使用 <code>bindTo</code> 函数将列绑定到一个简单的属性上，如 <code>c.bindTo { it.name }</code>。</li><li><strong>嵌套绑定：</strong>使用 <code>bindTo</code> 函数将列绑定到多层嵌套的某个属性上，如 <code>c.bindTo { it.manager.department.id }</code>；这样，从数据库中获取该列时，它的值会被填充到 <code>employee.manager.department.id</code> 中；把修改更新到数据库时，只要嵌套的属性中的任何一级发生变化，都会将新的值同步更新到所绑定的这个列。简单绑定其实也是嵌套绑定的一种特例，只不过嵌套的属性只有一层。</li><li><strong>引用绑定：</strong>使用 <code>references</code> 函数将列绑定到另一个表，如 <code>c.references(Departments) { it.department }</code>，相当于数据库中的外键引用。使用引用绑定的列，在通过实体查询函数从数据库中获取当前实体对象的时候，会自动递归地 left join 其关联表，并将关联的实体对象也一并获取。</li></ol><p>另外，Ktorm 2.6 及以上版本还支持了多重绑定的功能，我们可以通过连续调用 <code>bindTo</code> 或 <code>references</code> 函数把一个列绑定到多个属性上。这样，当通过查询从数据库中获取实体对象的时候，这个列的值就会同时填充到它绑定的每一个属性上去。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Config</span> : <span class="type">Entity</span>&lt;<span class="type">Config</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> key: String</span><br><span class="line">    <span class="keyword">var</span> value1: String</span><br><span class="line">    <span class="keyword">var</span> value2: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Configs : Table&lt;Config&gt;(<span class="string">"t_config"</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> key = varchar(<span class="string">"key"</span>).primaryKey().bindTo &#123; it.key &#125;</span><br><span class="line">    <span class="keyword">val</span> value = varchar(<span class="string">"value"</span>).bindTo &#123; it.value1 &#125;.bindTo &#123; it.value2 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们把 <code>value</code> 列同时绑定到了 <code>value1</code> 和 <code>value2</code> 上，因此在查询返回的实体对象中，这两个属性会包含同样的值。</p><blockquote><p>请注意：多重绑定仅在查询时有效，在执行插入或更新实体的操作时，以第一个绑定的属性为准，其他的绑定都会被忽略。</p></blockquote><h2 id="关于-Entity-接口"><a href="#关于-Entity-接口" class="headerlink" title="关于 Entity 接口"></a>关于 Entity 接口</h2><p>前面提到，Ktorm 规定，所有的实体类都应该定义为 interface，并且继承 <code>Entity</code> 接口，而实体对象的创建，则是使用 JDK 动态代理完成的。如果你对 JDK 的动态代理有所了解，你应该知道，代理对象是通过 <code>Proxy.newProxyInstance</code> 方法创建的，提供一个 <code>InvocationHandler</code> 实例作为参数，所有对接口方法的调用，都会被 JDK 代理到这个 handler 中。在 Ktorm 内部，<code>EntityImplementation</code> 就是这个 handler 的实现，它被声明为 internal，因此你无法在 Ktorm 外部使用它，但是我们可以了解一下它的基本原理。</p><h3 id="属性存取"><a href="#属性存取" class="headerlink" title="属性存取"></a>属性存取</h3><p>当我们使用 Kotlin 在实体类中定义一个属性 <code>var name: String</code>，编译成 Java 字节码后，相当于定义了两个方法，分别是 <code>public String getName()</code> 和 <code>public void setName(String name)</code>，这两个方法的调用都会被代理到 <code>EntityImplementation</code> 中。</p><p><code>EntityImplementation</code> 类中包含了一个 values 属性，它的类型是 <code>LinkedHashMap&lt;String, Any?&gt;</code>，用来保存实体中的所有属性的值。当我们使用 <code>e.name</code> 获取属性时，<code>EntityImplementation</code> 就会检测到 <code>getName()</code> 方法的调用，于是从 values 中使用“name”作为键获取属性值。当我们使用 <code>e.name = &quot;foo&quot;</code> 修改属性，同样会发生一个 <code>setName()</code> 方法的调用，于是，<code>EntityImplementation</code> 会使用“name”为键将传入的属性值保存到 values 中，同时还会记录一些额外的信息，以跟踪实体的状态变化。</p><p>也就是说，每个实体对象的背后，都有一个属性表保存了它的所有属性值，所有对实体类属性的获取或修改操作，实际上都是在操作底层的这个属性表。但是，如果在获取属性值时，属性表中不存在对应的键会怎么样呢？比如一个刚刚创建的实体对象，它底层的属性表就是空的，不存在任何键。Ktorm 针对这种情况定义了一套具体的规则：</p><ul><li>当属性表中不含有指定属性时，如果该属性为可空类型，如 <code>var name: String?</code>，则返回 null</li><li>当属性表中不含有指定属性时，如果该属性为不可空类型，如 <code>var name: String</code>，此时返回 null 会导致意料之外的空指针异常，Ktorm 会返回对应类型的默认值</li></ul><p>关于不同类型的默认值，也有一套规则：</p><ul><li>对于 <code>Boolean</code> 类型，返回 false</li><li>对于 <code>Char</code> 类型，返回 \u0000</li><li>对于数值类型，如 <code>Int</code>、<code>Long</code>、<code>Double</code> 等，返回 0</li><li>对于 <code>String</code> 类型，返回空字符串</li><li>对于实体类型，返回一个新创建的空的实体对象</li><li>对于枚举类型，返回枚举的第一个值</li><li>对于数组类型，返回一个新创建的空数组</li><li>对于集合类型，如 <code>Set</code>、<code>List</code>、<code>Map</code> 等，返回一个对应类型的新创建的空的可变集合</li><li>其他未识别类型，调用其无参构造函数创建一个对象并返回，如果没有无参构造函数，则抛出异常</li></ul><p>另外，<code>EntityImplementation</code> 内部对默认值存在一个缓存机制，即在没有修改属性值的情况下，多次调用 getter 获取到的默认值始终是同一个对象，以避免一些违反直觉的 bug。</p><h3 id="非抽象成员"><a href="#非抽象成员" class="headerlink" title="非抽象成员"></a>非抽象成员</h3><p>在领域驱动设计中，实体对象不仅仅是保存数据的属性值的集合，还可以具有一些业务逻辑，因此往往需要在实体类中定义一些业务函数。幸运的是，Kotlin 允许我们在接口中定义具有默认实现的函数，这使得 Ktorm 要求我们将实体类定义为接口并没有造成实际损失。我们可以在实体接口中增加非抽象的成员函数，像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> : <span class="type">Entity</span>&lt;<span class="type">Foo</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Entity.Factory&lt;Foo&gt;()</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，如果我们调用 <code>Foo().printName()</code>，就会输出 <code>name</code> 属性的值。</p><blockquote><p>这看起来十分自然，但其背后的实现却没那么简单。我们知道，Ktorm 使用 JDK 动态代理创建实体对象，因此，<code>printName</code> 函数的调用实际上也会转发到 <code>EntityImplementation</code> 内部。这时， <code>EntityImplementation</code> 会检测到当前调用的函数并非抽象函数，然后自动查找到 <code>DefaultImpls</code> 类中的默认实现并调用之，然而在我们看起来，这跟直接调用该函数并没有任何区别。但是，如果你在方法上添加 <code>@JvmDefault</code> 注解，就可能导致 Ktorm 无法查找 <code>DefaultImpls</code> 类，具体原因有兴趣可以参考 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index.html" target="_blank" rel="noopener">Kotlin 语言手册</a>，这对我们使用 Ktorm 并无太大影响。</p></blockquote><p>除了非抽象函数，Kotlin 也允许我们在接口中添加具有自定义 getter 或 setter 的属性。例如下面的代码，当调用 <code>upperName</code> 时，就会返回全大写的名称，其原理与前面所说的完全一致：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> : <span class="type">Entity</span>&lt;<span class="type">Foo</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="keyword">val</span> upperName <span class="keyword">get</span>() = name.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p><code>Entity</code> 接口继承了 <code>java.io.Serializable</code> 接口，所有的实体对象默认都是可序列化的，因此你可以将实体对象保存在磁盘中，或者通过网络在不同系统中传输，而不需要其他额外的工作。</p><p>唯一需要注意的是，在序列化时，Ktorm 将只会保存各个属性的值，其他用于追踪实体状态变化的数据都会丢失（被标记为 transient），因此你无法在一个系统中获取实体，然后在另一个系统中调用实体的 <code>flushChanges</code> 方法将属性变化更新到数据库。</p><blockquote><p>Java 使用 <code>ObjectOutputStream</code> 实现对象序列化，使用 <code>ObjectInputStream</code> 实现反序列化，具体可以参考这两个类的文档。</p></blockquote><p>除了 JDK 序列化，ktorm-jackson 模块还为你提供了使用 JSON 格式进行序列化的功能。该模块为 Java 中著名的 JSON 框架 Jackson 提供了一个扩展，它支持将 Ktorm 中的实体对象格式化为 JSON，以及从 JSON 中解析实体对象。我们只需要将 <code>KtormModule</code> 注册到 <code>ObjectMapper</code> 中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> objectMapper = ObjectMapper()</span><br><span class="line">objectMapper.registerModule(KtormModule())</span><br></pre></td></tr></table></figure><p>或者使用 <code>findAndRegisterModules</code> 方法自动扫描：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> objectMapper = ObjectMapper()</span><br><span class="line">objectMapper.findAndRegisterModules()</span><br></pre></td></tr></table></figure><p>现在，你就可以使用这个 <code>objectMapper</code> 对实体对象进行序列化与反序列化的操作了，具体可以参考 Jackson 框架的文档。</p><p>以上就是 Ktorm 实体类目前支持的两种序列化方式，如果希望得到更多支持，可以提出 issue，或向我们发送 PR，欢迎您的贡献！</p><div id="support-footer-container"><div class="doc-support-footer" data-reactroot=""><div class="doc-footer-link">上一篇：<a href="/zh-cn/dialects-and-native-sql.html">方言与原生 SQL</a></div><div class="doc-footer-link">下一篇：<a href="/zh-cn/entity-finding.html">实体查询</a></div>对文档内容有疑问？请在侧边栏尝试搜索或者在 GitHub <a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank" rel="noopener">提出 issue</a></div></div></article></div></div><div class="doc-footer">&copy; 2022 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm" target="_blank" rel="noopener">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/script/doc.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script><script type="text/javascript">docsearch({appId:"0DGANM0MZ3",apiKey:"071ea85fb6b0933d3f3d3925aa434e23",indexName:"ktorm",inputSelector:"#doc-search-input",algoliaOptions:{facetFilters:["lang:zh-cn","tags:doc"]},autocompleteOptions:{hint:!1,appendTo:"body"},debug:!1})</script><script>!function(){$(".kotlin .code .keyword").each(function(){var e=$(this);("where"===e.text()||"set"===e.text())&&e.removeClass("keyword")})}()</script></body></html><!-- rebuild by neat -->