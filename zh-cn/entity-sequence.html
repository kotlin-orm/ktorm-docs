<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Ktorm | 实体序列</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch-css@3.6.2/style.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"实体序列",lang:"zh-cn",related_path:"en/entity-sequence.html",path:"zh-cn/entity-sequence.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"GETTING STARTED",type:"label",isCurrent:!1},{text:"Overview",type:"link",path:"/",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!0},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",target:"_blank",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]},"navigation-zh-cn":{home:[{title:"快速上手",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"开始",type:"label",isCurrent:!1},{text:"简介",type:"link",path:"zh-cn/",isCurrent:!1},{text:"快速上手",type:"link",path:"zh-cn/quick-start.html",isCurrent:!1},{text:"连接管理",type:"label",isCurrent:!1},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html",isCurrent:!1},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html",isCurrent:!1},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html",isCurrent:!1},{text:"查询",type:"link",path:"zh-cn/query.html",isCurrent:!1},{text:"联表",type:"link",path:"zh-cn/joining.html",isCurrent:!1},{text:"增删改",type:"link",path:"zh-cn/dml.html",isCurrent:!1},{text:"运算符",type:"link",path:"zh-cn/operators.html",isCurrent:!1},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html",isCurrent:!1},{text:"实体类 API",type:"label",isCurrent:!1},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html",isCurrent:!1},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html",isCurrent:!0},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html",isCurrent:!1},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html",isCurrent:!1},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html",isCurrent:!1},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"支持和反馈",type:"label",isCurrent:!1},{text:"API 文档",type:"support-link",path:"api-docs/index.html",target:"_blank",isCurrent:!1},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank",isCurrent:!1},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html",isCurrent:!1}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc"}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation"><nav class="doc-navbar"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="doc-navbar__logo"><a href="/zh-cn/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close"></i><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/entity-sequence.html">English</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"></span></button></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>开始</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/" target="_self"><span>简介</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/quick-start.html" target="_self"><span>快速上手</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>连接管理</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/connect-to-databases.html" target="_self"><span>连接数据库</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/transaction-management.html" target="_self"><span>事务管理</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/spring-support.html" target="_self"><span>Spring 支持</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/schema-definition.html" target="_self"><span>定义表结构</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/query.html" target="_self"><span>查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/joining.html" target="_self"><span>联表</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/dml.html" target="_self"><span>增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/operators.html" target="_self"><span>运算符</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/dialects-and-native-sql.html" target="_self"><span>方言与原生 SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>实体类 API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entities-and-column-binding.html" target="_self"><span>实体类与列绑定</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-finding.html" target="_self"><span>实体查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-sequence.html" target="_self"><span>实体序列</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/sequence-aggregation.html" target="_self"><span>序列聚合</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-dml.html" target="_self"><span>实体增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/define-entities-as-any-kind-of-classes.html" target="_self"><span>使用任意的类作为实体类</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>支持和反馈</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/api-docs/index.html" target="_blank"><span>API 文档</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank"><span>问题反馈</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/sponsor.html" target="_self"><span>打赏作者</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/entity-sequence.html">English</a></span></span></div><div class="dc-page"><div class="dc-card"><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/zh-cn/entity-sequence.md"><i class="icon fa fa-github"></i> <span class="text">编辑本页</span></a><h1 id="实体序列"><a class="markdownIt-Anchor" href="#实体序列"></a> 实体序列</h1><p>在前一节中，我们简单了解了如何使用序列 API 获取实体对象，现在我们来对它进行更详细的介绍。</p><h2 id="序列简介"><a class="markdownIt-Anchor" href="#序列简介"></a> 序列简介</h2><p>要使用序列 API，首先要创建实体序列的对象。一般来说，我们会给 <code>Database</code> 定义一些扩展属性，它们使用 <code>sequenceOf</code> 函数创建序列对象并返回。这些属性可以帮助我们提高代码的可读性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Database.departments <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Departments)</span><br><span class="line"><span class="keyword">val</span> Database.employees <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Employees)</span><br></pre></td></tr></table></figure><p><code>sequenceOf</code> 函数会返回一个默认的序列，它可以获得表中的所有实体对象。但是请放心，Ktorm 并不会马上执行查询，序列对象提供了一个迭代器 <code>Iterator&lt;E&gt;</code>，当我们使用它迭代序列中的数据时，查询才会执行。下面我们使用 for-each 循环打印出序列中所有的员工：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (employee <span class="keyword">in</span> database.employees) &#123;</span><br><span class="line">    println(employee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> _ref0.id </span><br></pre></td></tr></table></figure><blockquote><p>调用 <code>sequenceOf</code> 函数时，我们可以把 <code>withReferences</code> 参数设置为 false，这样就不会自动 left join 关联表，如：<code>database.sequenceOf(Employees, withReferences = false)</code></p></blockquote><p>除了使用 for-each 循环外，我们还能用 <code>toList</code> 扩展函数将序列中的元素保存为一个列表：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.toList()</span><br></pre></td></tr></table></figure><p>我们还能在 <code>toList</code> 之前，使用 <code>filter</code> 扩展函数添加一个筛选条件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.filter &#123; it.departmentId eq <span class="number">1</span> &#125;.toList()</span><br></pre></td></tr></table></figure><p>此时生成的 SQL 会变成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> _ref0.id </span><br><span class="line"><span class="keyword">where</span> t_employee.department_id <span class="operator">=</span> ? </span><br></pre></td></tr></table></figure><p>我们再来看看最核心的 <code>EntitySequence</code> 类的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">EntitySequence</span>&lt;<span class="type">E : Any, T : BaseTable&lt;E</span>&gt;&gt;(</span><br><span class="line">    <span class="keyword">val</span> database: Database, </span><br><span class="line">    <span class="keyword">val</span> sourceTable: T,</span><br><span class="line">    <span class="keyword">val</span> expression: SelectExpression,</span><br><span class="line">    <span class="keyword">val</span> entityExtractor: (row: QueryRowSet) -&gt; E</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> query = Query(database, expression)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sql <span class="keyword">get</span>() = query.sql</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rowSet <span class="keyword">get</span>() = query.rowSet</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> totalRecords <span class="keyword">get</span>() = query.totalRecords</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asKotlinSequence</span><span class="params">()</span></span> = Sequence &#123; iterator() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span> = <span class="keyword">object</span> : Iterator&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> queryIterator = query.iterator()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queryIterator.hasNext()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: E &#123;</span><br><span class="line">            <span class="keyword">return</span> entityExtractor(queryIterator.next())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，每个实体序列中都包含了一个查询，而序列的迭代器正是包装了它内部的查询的迭代器。当序列被迭代时，会执行内部的查询，然后使用 <code>entityExtractor</code> 为每行创建一个实体对象。至于序列中的其他属性，比如 <code>sql</code>、<code>rowSet</code>、<code>totalRecords</code> 等，也都是直接来自它内部的查询对象，其功能与 <code>Query</code> 类中的同名属性完全相同。</p><p>Ktorm 的实体序列 API，大部分都是以扩展函数的方式提供的，这些扩展函数大致可以分为两类：</p><ul><li>**中间操作：**这类函数并不会执行序列中的查询，而是修改并创建一个新的序列对象，比如 <code>filter</code> 函数会使用指定的筛选条件创建一个新的序列对象。中间函数的返回值类型通常都是 <code>EntitySequence</code>，以便我们继续链式调用其他序列函数。</li><li>**终止操作：**这类函数的返回值通常是一个集合或者是某个计算的结果，他们会马上执行一个查询，然后获取它的结果并执行一定的运算，比如 <code>toList</code>、<code>reduce</code> 等。</li></ul><h2 id="中间操作"><a class="markdownIt-Anchor" href="#中间操作"></a> 中间操作</h2><p>就像 <code>kotlin.sequences</code> 一样，<code>EntitySequence</code> 的中间操作并不会迭代序列执行查询，它们都返回一个新的序列对象。<code>EntitySequence</code> 的中间操作主要有如下几个。</p><h3 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> filter</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">filter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    predicate: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">Boolean</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: EntitySequence&lt;E, T&gt;</span><br></pre></td></tr></table></figure><p>与 <code>kotlin.sequences</code> 的 <code>filter</code> 函数类似，<code>EntitySequence</code> 的 <code>filter</code> 函数也接受一个闭包作为参数，使用闭包中指定的筛选条件对序列进行过滤。不同的是，我们的闭包接受当前表对象 <code>T</code> 作为参数，因此我们在闭包中使用 <code>it</code> 访问到的并不是实体对象，而是表对象，另外，闭包的返回值也是 <code>ColumnDeclaring&lt;Boolean&gt;</code>，而不是 <code>Boolean</code>。下面使用 <code>filter</code> 获取部门 1 中的所有员工：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.filter &#123; it.departmentId eq <span class="number">1</span> &#125;.toList()</span><br></pre></td></tr></table></figure><p>可以看到，用法几乎与 <code>kotlin.sequences</code> 完全一样，不同的仅仅是在 lambda 表达式中的等号 <code>==</code> 被这里的 <code>eq</code> 函数代替了而已。<code>filter</code> 函数还可以连续使用，此时所有的筛选条件将使用 <code>and</code> 运算符进行连接，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .filter &#123; it.managerId.isNotNull() &#125;</span><br><span class="line">    .toList()</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> _ref0.id </span><br><span class="line"><span class="keyword">where</span> (t_employee.department_id <span class="operator">=</span> ?) <span class="keyword">and</span> (t_employee.manager_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>) </span><br></pre></td></tr></table></figure><p>其实，Ktorm 还提供了一个 <code>filterNot</code> 函数，它的用法与 <code>filter</code> 一样，但是会将闭包中的筛选条件取反。比如上面例子中的第二个 <code>filter</code> 调用就可以改写为 <code>filterNot &#123; it.managerId.isNull() &#125;</code>。除此之外，Ktorm 还提供了 <code>filterTo</code> 和 <code>filterNotTo</code>，但这两个函数其实是终止操作，它们会在添加筛选条件之后马上迭代这个序列，将里面的元素添加到给定的集合中，其效果相当于连续调用 <code>filter</code> 和 <code>toCollection</code> 两个函数。</p><h3 id="filtercolumns"><a class="markdownIt-Anchor" href="#filtercolumns"></a> filterColumns</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">filterColumns</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    selector: (<span class="type">T</span>) -&gt; <span class="type">List</span>&lt;<span class="type">Column</span>&lt;*&gt;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: EntitySequence&lt;E, T&gt;</span><br></pre></td></tr></table></figure><p>实体序列默认会查询当前表对象和关联表对象（如果启用的话）中的的所有列，这有时会造成一定的性能损失，如果你对这些损失比较敏感的话，可以使用 <code>filterColumns</code> 函数。这个函数支持我们定制查询中的列，比如我们需要获取公司的部门列表，但是不需要部门的地址数据，代码可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> departments = database.departments</span><br><span class="line">    .filterColumns &#123; it.columns - it.location &#125;</span><br><span class="line">    .toList()</span><br></pre></td></tr></table></figure><p>这时，返回的实体对象中将不再有 <code>location</code> 字段，生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_department.id <span class="keyword">as</span> t_department_id, t_department.name <span class="keyword">as</span> t_department_name </span><br><span class="line"><span class="keyword">from</span> t_department </span><br></pre></td></tr></table></figure><h3 id="sortedby"><a class="markdownIt-Anchor" href="#sortedby"></a> sortedBy</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">sortedBy</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    selector: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;*&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: EntitySequence&lt;E, T&gt;</span><br></pre></td></tr></table></figure><p><code>sortedBy</code> 函数用于指定查询结果的排序方式，我们在闭包中返回一个字段或一个表达式，然后 Ktorm 就会使用它对结果进行排序。下面的代码按工资从低到高对员工进行排序：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.sortedBy &#123; it.salary &#125;.toList()</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> _ref0.id </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t_employee.salary </span><br></pre></td></tr></table></figure><p><code>sortedBy</code> 函数默认按升序进行排序，如果你希望使用降序，可以改用 <code>sortedByDescending</code> 函数，它的用法是一样的。</p><p>有时候，我们的排序需要考虑多个不同的字段，这时我们可以给 <code>sortedBy</code> 函数传入多个 lambda 表达式。下面是一个使用示例，它将员工按工资从高到低排序，在工资相等的情况下，再按入职时间从远到近排序：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees</span><br><span class="line">    .sortedBy(&#123; it.salary.desc() &#125;, &#123; it.hireDate.asc() &#125;)</span><br><span class="line">    .toList()</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> _ref0.id </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t_employee.salary <span class="keyword">desc</span>, t_employee.hire_date </span><br></pre></td></tr></table></figure><h3 id="droptake"><a class="markdownIt-Anchor" href="#droptake"></a> drop/take</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">drop</span><span class="params">(n: <span class="type">Int</span>)</span></span>: EntitySequence&lt;E, T&gt;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">take</span><span class="params">(n: <span class="type">Int</span>)</span></span>: EntitySequence&lt;E, T&gt;</span><br></pre></td></tr></table></figure><p><code>drop</code> 和 <code>take</code> 函数用于实现分页的功能，<code>drop</code> 函数会丢弃序列中的前 n 个元素，<code>take</code> 函数会保留前 n 个元素丢弃后面的元素。下面是一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.drop(<span class="number">1</span>).take(<span class="number">1</span>).toList()</span><br></pre></td></tr></table></figure><p>如果我们使用 MySQL 数据库，会生成如下 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> _ref0.id </span><br><span class="line">limit ?, ? </span><br></pre></td></tr></table></figure><p>需要注意的是，这两个函数依赖于数据库本身的分页功能，然而 SQL 标准中并没有规定如何进行分页查询的语法，每种数据库提供商对其都有不同的实现。因此，使用这两个函数，我们必须开启某个方言的支持，具体请参考 <a href="./query.html#limit">查询 - limit</a> 一节的相关描述。</p><h2 id="终止操作"><a class="markdownIt-Anchor" href="#终止操作"></a> 终止操作</h2><p>实体序列的终止操作会马上执行一个查询，获取查询的结果，然后执行一定的计算，下面介绍 Ktorm 为 <code>EntitySequence</code> 提供的一些终止操作，他们其实与 <code>kotlin.sequences</code> 的终止操作几乎一样。</p><h3 id="tocollection"><a class="markdownIt-Anchor" href="#tocollection"></a> toCollection</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, C : MutableCollection&lt;in E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, *&gt;</span>.<span class="title">toCollection</span><span class="params">(destination: <span class="type">C</span>)</span></span>: C</span><br></pre></td></tr></table></figure><p><code>toCollection</code> 函数用于获取序列中的所有元素，它会马上执行查询，迭代查询结果中的元素，把它们添加到 <code>destination</code> 集合中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.toCollection(ArrayList())</span><br></pre></td></tr></table></figure><p>除此之外，Ktorm 还提供了一些简便的 <code>toXxx</code> 系列函数，用于将序列中的元素保存为特定类型的集合，它们分别是：<code>toList</code>、<code>toMutableList</code>、<code>toSet</code>、<code>toMutableSet</code>、<code>toHashSet</code>、<code>toSortedSet</code>。</p><h3 id="mapflatmap"><a class="markdownIt-Anchor" href="#mapflatmap"></a> map/flatMap</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, R&gt;</span> EntitySequence<span class="type">&lt;E, *&gt;</span>.<span class="title">map</span><span class="params">(transform: (<span class="type">E</span>) -&gt; <span class="type">R</span>)</span></span>: List&lt;R&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, R&gt;</span> EntitySequence<span class="type">&lt;E, *&gt;</span>.<span class="title">flatMap</span><span class="params">(transform: (<span class="type">E</span>) -&gt; <span class="type">Iterable</span>&lt;<span class="type">R</span>&gt;)</span></span>: List&lt;R&gt;</span><br></pre></td></tr></table></figure><p>根据以往函数式编程的经验，你很可能会认为 <code>map</code> 和 <code>flatMap</code> 是中间操作，但是很遗憾，在 Ktorm 中，它们是终止操作，这是我们在设计上的一个妥协。</p><p><code>map</code> 函数会马上执行查询，迭代查询结果中的元素，对每一个元素都应用参数 <code>transform</code> 所指定的转换，然后把转换的结果保存到一个列表中返回。<code>flatMap</code> 也会马上执行查询，它与 <code>map</code> 的区别，熟悉函数式编程的同学都能一眼看出来，在此不赘述。</p><p>下面的代码可以获取所有员工的名字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = database.employees.map &#123; it.name &#125;</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br></pre></td></tr></table></figure><p>请注意，虽然在这里我们只需要获取员工的名字，但是生成的 SQL 仍然查询了所有的字段，这是因为 Ktorm 无法通过我们传入的 <code>transform</code> 函数识别出所需的具体字段。如果你对这点性能的损失比较敏感，可以把 <code>map</code> 函数与 <code>filterColumns</code> 函数配合使用，也可以使用下面将要介绍的 <code>mapColumns</code> 函数代替。</p><p>除了基本的 <code>map</code> 函数，Ktorm 还提供了 <code>mapTo</code>、<code>mapIndexed</code>、<code>mapIndexedTo</code> 等，他们的功能与 <code>kotlin.sequences</code> 中的同名函数是一样的，在此也不再赘述。</p><h3 id="mapcolumns"><a class="markdownIt-Anchor" href="#mapcolumns"></a> mapColumns</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>, C : Any&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">mapColumns</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    isDistinct: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    columnSelector: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">C</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: List&lt;C?&gt;</span><br></pre></td></tr></table></figure><p><code>mapColumns</code> 函数的功能与 <code>map</code> 类似，不同的是，它的闭包函数接受当前表对象 <code>T</code> 作为参数，因此我们在闭包中使用 <code>it</code> 访问到的并不是实体对象，而是表对象，另外，闭包的返回值也是 <code>ColumnDeclaring&lt;C&gt;</code>，我们需要在闭包中返回希望从数据库中查询的列或表达式。还是前面的例子，使用 <code>mapColumns</code> 获取所有员工的名字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = database.employees.mapColumns &#123; it.name &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这时生成的 SQL 中就只包含了我们需要的字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.name </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br></pre></td></tr></table></figure><p>如果你希望 <code>mapColumns</code> 能一次查询多个字段，可以在闭包中使用 <code>tupleOf</code> 包装我们的这些字段，函数的返回值就相应变成了 <code>List&lt;TupleN&lt;C1?, C2?, .. Cn?&gt;&gt;</code>。下面的例子会打印出部门 1 中所有员工的 ID，姓名和入职天数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .mapColumns &#123; tupleOf(it.id, it.name, dateDiff(LocalDate.now(), it.hireDate)) &#125;</span><br><span class="line">    .forEach &#123; (id, name, days) -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$id</span>:<span class="variable">$name</span>:<span class="variable">$days</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码，会产生如下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1:vince:473</span><br><span class="line">2:marry:108</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.id, t_employee.name, datediff(?, t_employee.hire_date) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">where</span> t_employee.department_id <span class="operator">=</span> ? </span><br></pre></td></tr></table></figure><blockquote><p><code>tupleOf</code> 函数的功能是创建一个元组对象，根据参数个数的不同，它的返回值可以是 <code>Tuple2</code> 到 <code>Tuple9</code>，也就是说，我们最多可以使用 <code>mapColumns</code> 系列函数一次查询九个字段。但如果我们希望超过九个字段呢？很遗憾，Ktorm 认为这并不是一个常用的功能，如果你确实有这种特殊的需求，可以使用 <code>filterColumns</code> 函数或<a href="./query.html">查询 DSL</a> 代替。</p></blockquote><p>除了基本的 <code>mapColumns</code> 函数，Ktorm 还提供了 <code>mapColumnsTo</code>、<code>mapColumnsNotNull</code>、<code>mapColumnsNotNullTo</code>，通过名字你应该也猜到了它们的用法，在此就不重复说明了。</p><h3 id="associate"><a class="markdownIt-Anchor" href="#associate"></a> associate</h3><p><code>associate</code> 系列函数会马上执行查询，然后迭代查询的结果集，把序列转换为 <code>Map</code>。它们的用法与 <code>kotlin.sequences</code> 的同名函数一模一样，具体可以参考 Kotlin 标准库的相关文档。</p><p>除了基本的 <code>associate</code> 函数以外，Ktorm 还提供了其他的一些变体，它们分别是：<code>associateBy</code>、<code>associateWith</code>、<code>associateTo</code>、<code>associateByTo</code>、<code>associateWithTo</code>。</p><h3 id="elementatfirstlastfindfindlastsingle"><a class="markdownIt-Anchor" href="#elementatfirstlastfindfindlastsingle"></a> elementAt/first/last/find/findLast/single</h3><p>这一系列函数用于获取序列中指定位置的元素，它们的用法也与 <code>kotlin.sequences</code> 的同名函数一模一样，具体可以参考 Kotlin 标准库的相关文档。</p><p>特别的是，如果我们启用了方言支持的话，这些函数会使用分页功能，尽量只查询一条数据。假如我们使用 MySQL，并且使用 <code>elementAt(10)</code> 获取下标为 10 的记录的话，会生成 <code>limit 10, 1</code> 这样的 SQL。但如果分页功能不可用，则会查出所有的记录，然后再根据下标获取指定元素。</p><p>另外，除了基本的形式外，这些函数还具有许多的变体，这里就不一一列举了。</p><h3 id="foldreduceforeach"><a class="markdownIt-Anchor" href="#foldreduceforeach"></a> fold/reduce/forEach</h3><p>这一系列函数及其变体为序列提供了迭代、折叠等功能，它们的用法也与 <code>kotlin.sequences</code> 的同名函数一模一样，具体可以参考 Kotlin 标准库的相关文档。下面使用 <code>fold</code> 计算所有员工的工资总和：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> totalSalary = database.employees.fold(<span class="number">0L</span>) &#123; acc, employee -&gt; acc + employee.salary &#125;</span><br></pre></td></tr></table></figure><p>当然，如果仅仅为了获得工资总和，我们没必要这样做。这是性能低下的写法，它会查询出所有员工的数据，然后对它们进行迭代，这里仅用作示范，更好的写法是使用 <code>sumBy</code> 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> totalSalary = database.employees.sumBy &#123; it.salary &#125;</span><br></pre></td></tr></table></figure><h3 id="jointojointostring"><a class="markdownIt-Anchor" href="#jointojointostring"></a> joinTo/joinToString</h3><p>这两个函数提供了将序列中的元素组装为字符串的功能，它们的用法也与 <code>kotlin.sequences</code> 的同名函数一模一样，具体可以参考 Kotlin 标准库的相关文档。</p><p>下面使用 <code>joinToString</code> 把所有员工的名字拼成一个字符串：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = database.employees.joinToString(separator = <span class="string">&quot;:&quot;</span>) &#123; it.name &#125;</span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer"><div class="doc-footer-link">上一篇：<a href="/zh-cn/entity-finding.html">实体查询</a></div><div class="doc-footer-link">下一篇：<a href="/zh-cn/sequence-aggregation.html">序列聚合</a></div>对文档内容有疑问？请在侧边栏尝试搜索或者在 GitHub <a href="https://github.com/kotlin-orm/ktorm/issues/new">提出 issue</a></div></div></article></div></div><div class="doc-footer">&copy; 2024 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script></body></html>