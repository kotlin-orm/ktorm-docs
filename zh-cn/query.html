<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Ktorm | 查询</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch-css@3.6.2/style.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"查询",lang:"zh-cn",related_path:"en/query.html",path:"zh-cn/query.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"GETTING STARTED",type:"label",isCurrent:!1},{text:"Overview",type:"link",path:"/",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!0},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",target:"_blank",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]},"navigation-zh-cn":{home:[{title:"快速上手",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"开始",type:"label",isCurrent:!1},{text:"简介",type:"link",path:"zh-cn/",isCurrent:!1},{text:"快速上手",type:"link",path:"zh-cn/quick-start.html",isCurrent:!1},{text:"连接管理",type:"label",isCurrent:!1},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html",isCurrent:!1},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html",isCurrent:!1},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html",isCurrent:!1},{text:"查询",type:"link",path:"zh-cn/query.html",isCurrent:!1},{text:"联表",type:"link",path:"zh-cn/joining.html",isCurrent:!1},{text:"增删改",type:"link",path:"zh-cn/dml.html",isCurrent:!1},{text:"运算符",type:"link",path:"zh-cn/operators.html",isCurrent:!1},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html",isCurrent:!1},{text:"实体类 API",type:"label",isCurrent:!1},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html",isCurrent:!1},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html",isCurrent:!1},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html",isCurrent:!1},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html",isCurrent:!0},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html",isCurrent:!1},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"支持和反馈",type:"label",isCurrent:!1},{text:"API 文档",type:"support-link",path:"api-docs/index.html",target:"_blank",isCurrent:!1},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank",isCurrent:!1},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html",isCurrent:!1}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc"}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation"><nav class="doc-navbar"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="doc-navbar__logo"><a href="/zh-cn/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close"></i><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/query.html">English</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索文档</span></span><span class="DocSearch-Button-Keys"></span></button></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>开始</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/" target="_self"><span>简介</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/quick-start.html" target="_self"><span>快速上手</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>连接管理</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/connect-to-databases.html" target="_self"><span>连接数据库</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/transaction-management.html" target="_self"><span>事务管理</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/spring-support.html" target="_self"><span>Spring 支持</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/schema-definition.html" target="_self"><span>定义表结构</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current doc-sidebar-list__item--no-children"><a href="/zh-cn/query.html" target="_self"><span>查询</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/joining.html" target="_self"><span>联表</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/dml.html" target="_self"><span>增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/operators.html" target="_self"><span>运算符</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/dialects-and-native-sql.html" target="_self"><span>方言与原生 SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>实体类 API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entities-and-column-binding.html" target="_self"><span>实体类与列绑定</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-finding.html" target="_self"><span>实体查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-sequence.html" target="_self"><span>实体序列</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/sequence-aggregation.html" target="_self"><span>序列聚合</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/entity-dml.html" target="_self"><span>实体增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/define-entities-as-any-kind-of-classes.html" target="_self"><span>使用任意的类作为实体类</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>支持和反馈</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/api-docs/index.html" target="_blank"><span>API 文档</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank"><span>问题反馈</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/zh-cn/sponsor.html" target="_self"><span>打赏作者</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/query.html">English</a></span></span></div><div class="dc-page"><div class="dc-card"><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/zh-cn/query.md"><i class="icon fa fa-github"></i> <span class="text">编辑本页</span></a><h1 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h1><p>在前面的章节中，我们曾经创建过一个简单的查询，它查询表中所有的员工记录，然后打印出他们的名字，我们的介绍就从这里开始：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (row <span class="keyword">in</span> database.from(Employees).select()) &#123;</span><br><span class="line">    println(row[Employees.name])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="query-对象"><a class="markdownIt-Anchor" href="#query-对象"></a> Query 对象</h2><p>在上面的例子中，<code>select</code> 方法返回了一个类型为 <code>Query</code> 的对象，然后使用 for-each 循环对其进行迭代，那么除了迭代外，<code>Query</code> 类还支持什么操作呢？让我们先来看一下它的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Query</span>(<span class="keyword">val</span> database: Database, <span class="keyword">val</span> expression: QueryExpression) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> sql: String <span class="keyword">by</span> lazy &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rowSet: QueryRowSet <span class="keyword">by</span> lazy &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> totalRecords: <span class="built_in">Int</span> <span class="keyword">by</span> lazy &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;QueryRowSet&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> rowSet.iterator()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Query</code> 表示一个查询操作，Ktorm 正是以这个类为核心支持所有的查询 DSL。</p><p>可以看到，<code>Query</code> 类的构造函数接收两个参数：<code>database</code> 是执行此查询的数据库对象；<code>expression</code> 是被执行的 SQL 语句的抽象表示。一般来说，我们不需要自己使用这个构造函数创建 <code>Query</code> 对象，而是使用 <code>database.from(..).select(..)</code> 的语法，由 Ktorm 为我们构造一个查询。</p><p><code>Query</code> 类还重载了迭代运算符 <code>iterator</code>，通过重载这个运算符，我们才能够使用 for-each 循环的语法遍历查询返回的结果集。而且，Ktorm 还额外提供了一些类似 Kotlin 标准库中 <code>Iterable</code> 的扩展函数，所以我们还可以使用 <code>map</code>、 <code>flatMap</code> 等函数对结果集进行各种各样的处理，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Emp</span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>?, <span class="keyword">val</span> name: String?, <span class="keyword">val</span> salary: <span class="built_in">Long</span>?)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> query = database.from(Employees).select()</span><br><span class="line"></span><br><span class="line">query</span><br><span class="line">    .map &#123; row -&gt; Emp(row[Employees.id], row[Employees.name], row[Employees.salary]) &#125;</span><br><span class="line">    .filter &#123; it.salary &gt; <span class="number">1000</span> &#125;</span><br><span class="line">    .sortedBy &#123; it.salary &#125;</span><br><span class="line">    .forEach &#123; println(it.name) &#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，在这里 Ktorm 所完成的工作，只是生成了一句简单的 SQL <code>select * from t_employee</code> 而已，后面的 <code>.map &#123; &#125;.filter &#123; &#125;.sortedBy &#123; &#125;.forEach &#123; &#125;</code> 全部都是内存中的集合操作。</p></blockquote><p><code>Query</code> 类中还有一些有用的属性：</p><ul><li>**sql：**返回该查询生成的 SQL 字符串，可以在调试程序的时候确认生成的 SQL 是否符合预期。</li><li>**rowSet：**返回该查询的结果集对象，此字段懒初始化，在第一次获取时，执行 SQL 语句，从数据库中获取结果。</li><li>**totalRecords：**如果该查询没有使用 offset, limit 进行分页，此字段返回结果集的总行数；如果使用了分页，返回去除 offset, limit 限制后的符合条件的总记录数。Ktorm 使用此字段来支持页码计算，你可以使用 totalRecords 除以你的每页大小来计算总页数。</li></ul><h2 id="获取查询结果"><a class="markdownIt-Anchor" href="#获取查询结果"></a> 获取查询结果</h2><p>如果你用过 JDBC，你应该知道如何从 <code>ResultSet</code> 中获取你的查询结果。你需要使用一个循环不断地遍历结果集中的行，在循环中调用 <code>getInt</code> 、<code>getString</code> 等方法获取指定列中的数据，典型的用法是一个 while 循环：<code>while (rs.next()) &#123; ... &#125;</code>。而且，使用完毕后，你还得调用 <code>close</code> 方法关闭结果集。</p><p>这种写法虽说并不复杂，但重复的代码写多了也难免让人厌烦，而 Ktorm 为你提供了另一种可能。你可以使用 for-each 循环迭代 <code>Query</code> 的结果集，也可以使用 <code>map</code>、<code>flatMap</code> 等扩展函数对结果集进行二次处理，就像前面的例子一样。</p><p>你可能已经发现，<code>Query.rowSet</code> 返回的结果集并不是普通的 <code>ResultSet</code>，而是 <code>QueryRowSet</code>。这是 Ktorm 提供的特殊的 <code>ResultSet</code> 的实现，与普通的 <code>ResultSet</code> 不同，它增加了如下特性：</p><ul><li>**离线可用：**它不依赖于数据库连接，当连接关闭后，仍然可以正常使用，使用完毕也不需要调用 <code>close</code> 方法。<code>QueryRowSet</code> 在创建时，已经完整取出了结果集中的所有数据保存在内存中，因此只需要等待 GC 自动回收即可。</li><li><strong>索引访问运算符：</strong><code>QueryRowSet</code> 重载了<a href="https://kotlinlang.org/docs/reference/operator-overloading.html#indexed">索引访问运算符</a>，因此你可以使用方括号语法 <code>[]</code> ，通过传入指定的 <code>Column</code> 对象来获取这个列的数据，这种方法得益于编译器的静态检查，不易出错。不过，你仍然可以使用 <code>ResultSet</code> 中的 <code>getXxx</code> 方法，通过传入列的序号或名称字符串来获取。</li></ul><p>使用索引访问运算符获取列的方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (row <span class="keyword">in</span> database.from(Employees).select()) &#123;</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span>? = row[Employees.id]</span><br><span class="line">    <span class="keyword">val</span> name: String? = row[Employees.name]</span><br><span class="line">    <span class="keyword">val</span> salary: <span class="built_in">Long</span>? = row[Employees.salary]</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$id</span>, <span class="variable">$name</span>, <span class="variable">$salary</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果列的类型是 <code>Column&lt;Int&gt;</code>，返回的结果的类型就是 <code>Int?</code>，如果列的类型是 <code>Column&lt;String&gt;</code>，返回的结果的类型就是 <code>String?</code>。而且，列的类型并不局限于 <code>ResultSet</code> 中的 <code>getXxx</code> 方法返回的那些类型，它可以是任意类型，结果也始终是对应的类型，其中还可以包含一些对结果的必要的转换行为，具体取决于定义该列时所使用的 <a href="./schema-definition.html#SqlType">SqlType</a>。</p><h2 id="from"><a class="markdownIt-Anchor" href="#from"></a> from</h2><p><code>from</code> 是 <code>Database</code> 的扩展函数，它的功能是把一个表对象包装成 <code>QuerySource</code> 对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Database.<span class="title">from</span><span class="params">(table: <span class="type">BaseTable</span>&lt;*&gt;)</span></span>: QuerySource</span><br></pre></td></tr></table></figure><p>正如函数名 <code>from</code> 所示，<code>QuerySource</code> 表示 SQL 查询中的 from 子句。当得到一个 <code>QuerySource</code> 对象后，我们可以调用 <code>select</code> 函数创建一个查询，也可以继续调用 <code>innerJoin</code>、<code>leftJoin</code> 等函数进行联表操作。</p><p>在本文中我们将使用 <code>from</code> 函数引出所有的查询 DSL，至于<a href="./joining.html">联表</a>，请参考后面章节的内容。</p><h2 id="select"><a class="markdownIt-Anchor" href="#select"></a> select</h2><p>SQL 中的查询语句都开始于一个 select 关键字，类似地，Ktorm 中的查询也始于 <code>select</code> 函数的调用。<code>select</code> 是 <code>QuerySource</code> 的扩展函数，它的签名如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> QuerySource.<span class="title">select</span><span class="params">(<span class="keyword">vararg</span> columns: <span class="type">ColumnDeclaring</span>&lt;*&gt;)</span></span>: Query</span><br></pre></td></tr></table></figure><p>可以看到，它接受任意数量的列，返回一个 <code>Query</code> 对象，这个查询对象从当前 <code>QuerySource</code> 中查询指定的列。下面使用 <code>select</code> 函数查询员工的 id 和姓名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database.from(Employees).select(Employees.id, Employees.name)</span><br></pre></td></tr></table></figure><p>得到 <code>Query</code> 对象之后，SQL 实际上还没有运行，你可以继续链式调用 <code>where</code> 或其他扩展函数修改这个 <code>Query</code> 对象，也可以使用 <code>for-each</code> 循环或其他方式迭代它，这时，Ktorm 会执行一条 SQL，然后我们就能按照上文所述的方法获取查询结果。Ktorm 生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.id <span class="keyword">as</span> t_employee_id, t_employee.name <span class="keyword">as</span> t_employee_name </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br></pre></td></tr></table></figure><p>可以尝试删除传递给 <code>select</code> 方法的参数，即：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database.from(Employees).select()</span><br></pre></td></tr></table></figure><p>然后，生成的 SQL 就会变成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br></pre></td></tr></table></figure><p>可能你已经注意到，<code>select</code> 函数的参数类型是 <code>ColumnDeclaring</code>，而不是 <code>Column</code>，这使它不仅可以从表中查询普通的列，还支持使用复杂的表达式和聚合函数。如果我们想知道公司里最高薪员工和最低薪员工的薪水之差，查询可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(max(Employees.salary) - min(Employees.salary))</span><br><span class="line">    .forEach &#123; row -&gt; println(row.getLong(<span class="number">1</span>)) &#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了 <code>max</code> 和 <code>min</code> 两个聚合函数，他们的返回值都是 <code>AggregateExpression</code>，然后将他们相减，最终得到一个 <code>BinaryExpression</code>，它是 <code>ColumnDeclaring</code> 的子类，因此可以直接传入 <code>select</code> 方法中。最终生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(t_employee.salary) <span class="operator">-</span> <span class="built_in">min</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br></pre></td></tr></table></figure><p>可以看到，生成的 SQL 和我们写出来的 Kotlin 代码高度一致，这得益于 Kotlin 优秀的语法特性。Ktorm 提供了许多重载的运算符，这就是我们能够在上面的查询中使用减号的原因。由于运算符的重载，这里的减号并没有执行实际的减法，而是被翻译为 SQL 中的减号送到数据库中去执行。在<a href="./operators.html">运算符</a>一节中我们会介绍 Ktorm 提供的其他运算符。</p><blockquote><p>有个小遗憾：虽然 <code>select</code> 方法支持使用复杂的表达式，但是将查询的结果从 <code>QueryRowSet</code> 中取出来时，我们却不能使用前面介绍的索引访问运算符 []，只能使用继承自 <code>ResultSet</code> 中的 <code>getXxx</code> 方法，使用列的序号获取该列的值。</p></blockquote><h2 id="selectdistinct"><a class="markdownIt-Anchor" href="#selectdistinct"></a> selectDistinct</h2><p><code>selectDistinct</code> 也是 <code>QuerySource</code> 的扩展函数，顾名思义，它对应于 SQL 中的 <code>select distinct</code> 操作，会将查询的结果进行去重。除此之外，它的使用方法与 <code>select</code> 完全一致，在此不再赘述。</p><h2 id="where"><a class="markdownIt-Anchor" href="#where"></a> where</h2><p><code>where</code> 是 <code>Query</code> 类的扩展函数，我们先来看看它的签名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> Query.<span class="title">where</span><span class="params">(block: () -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">Boolean</span>&gt;)</span></span>: Query</span><br></pre></td></tr></table></figure><p>它是一个内联函数，接受一个闭包作为参数，我们在这个闭包中指定查询的 where 子句，闭包的返回值是 <code>ColumnDeclaring&lt;Boolean&gt;</code>。<code>where</code> 函数会创建一个新的 <code>Query</code> 对象，它的所有属性都复制自当前 <code>Query</code>，并使用闭包的返回值作为其筛选条件。典型的用法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.salary)</span><br><span class="line">    .<span class="keyword">where</span> &#123; (Employees.departmentId eq <span class="number">1</span>) and (Employees.name like <span class="string">&quot;%vince%&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><p>一眼明了，这个查询的目的是获得部门 1 中名字为 vince 的员工的薪水，生成的 SQL 你应该也能猜到：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.salary <span class="keyword">as</span> t_employee_salary </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">where</span> (t_employee.department_id <span class="operator">=</span> ?) <span class="keyword">and</span> (t_employee.name <span class="keyword">like</span> ?) </span><br></pre></td></tr></table></figure><p>在 <code>where</code> 闭包中，我们可以返回任何查询条件，这里我们使用 <code>eq</code>、<code>and</code> 和 <code>like</code> 运算符构造了一个。infix 是 Kotlin 提供的关键字，使用此关键字修饰的函数，在调用时可以省略点和括号，这样，代码写起来就像说话一样自然，我们这里使用的运算符正是 Ktorm 提供的 infix 函数。</p><blockquote><p>Ktorm 提供的内置运算符分为两类，一类是通过运算符重载实现的，比如加减乘除取反取余等常用运算，还有一类就是基于 infix 函数实现的，如 <code>and</code>、<code>or</code>、<code>eq</code>、<code>gt</code>、<code>lt</code>、<code>like</code> 等 Kotlin 中无法重载的运算符。</p></blockquote><p>有时候，我们的查询需要许多个筛选条件，这些条件使用 and 或 or 运算符连接，他们的数量不定，而且还会根据不同的情况启用不同的条件。为满足这种需求，许多 ORM 框架都提供了名为“动态查询”的特性，比如 MyBatis 的 <code>&lt;if&gt;</code> 标签。然而，在 Ktorm 中，这种需求根本就不是问题，因为 Ktorm 的查询都是纯 Kotlin 代码，因此天然具有这种“动态性”。我们看看下面这个查询：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.salary)</span><br><span class="line">    .<span class="keyword">where</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> conditions = ArrayList&lt;ColumnDeclaring&lt;<span class="built_in">Boolean</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (departmentId != <span class="literal">null</span>) &#123;</span><br><span class="line">            conditions += Employees.departmentId eq departmentId</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (managerId != <span class="literal">null</span>) &#123;</span><br><span class="line">            conditions += Employees.managerId eq managerId</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">            conditions += Employees.name like <span class="string">&quot;%<span class="variable">$name</span>%&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        conditions.reduce &#123; a, b -&gt; a and b &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们使用一个 <code>ArrayList</code> 保存所有查询条件，然后使用 if 语句根据不同的参数是否为空将查询条件添加到 list 中，最后使用一个 reduce 操作将所有条件用 and 连接起来。使用 Ktorm 不需要特别的操作就能够完美支持所谓的“动态查询”。</p><p>当然，上面的写法还是有一点漏洞，当所有情况都不满足，list 为空时，reduce 操作会抛出一个异常。为了避免这个异常，可以使用 <code>conditions.combineConditions()</code> 代替 reduce 操作。<code>combineConditions</code> 是 Ktorm 提供的函数，它的功能就是使用 and 将所有条件连接起来，当 list 为空时，直接返回 true，这是它的实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Iterable<span class="type">&lt;ColumnDeclaring&lt;Boolean&gt;</span>&gt;.<span class="title">combineConditions</span><span class="params">()</span></span>: ColumnDeclaring&lt;<span class="built_in">Boolean</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.any()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.reduce &#123; a, b -&gt; a and b &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ArgumentExpression(<span class="literal">true</span>, BooleanSqlType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，每次都创建一个 <code>ArrayList</code>，然后往里面添加条件，最后使用 reduce 连接的操作也挺烦的。Ktorm 提供了一个方便的函数 <code>whereWithConditions</code>，可以减少我们的这两行重复代码，使用这个函数，上面的查询可以改写成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.salary)</span><br><span class="line">    .whereWithConditions &#123;</span><br><span class="line">        <span class="keyword">if</span> (departmentId != <span class="literal">null</span>) &#123;</span><br><span class="line">            it += Employees.departmentId eq departmentId</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (managerId != <span class="literal">null</span>) &#123;</span><br><span class="line">            it += Employees.managerId eq managerId</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">            it += Employees.name like <span class="string">&quot;%<span class="variable">$name</span>%&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用 <code>whereWithConditions</code>，我们只需要在闭包中往 <code>it</code> 中添加条件就好了，这个 <code>it</code> 就是一个 <code>MutableList</code>，创建 list 和合并条件的操作就不需要重复做了。对应地，Ktorm 还提供了一个 <code>whereWithOrConditions</code> 函数，这个函数的功能其实是一样的，只不过最后是使用 or 将所有条件连接起来，而不是 and。</p><h2 id="groupbyhaving"><a class="markdownIt-Anchor" href="#groupbyhaving"></a> groupBy/having</h2><p><code>groupBy</code> 和 <code>having</code> 也都是 <code>Query</code> 类的扩展函数，他们为 SQL 中的聚合功能提供了支持，下面是一个使用的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = Employees.aliased(<span class="string">&quot;t&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(t)</span><br><span class="line">    .select(t.departmentId, avg(t.salary))</span><br><span class="line">    .groupBy(t.departmentId)</span><br><span class="line">    .having &#123; avg(t.salary) gt <span class="number">100.0</span> &#125;</span><br></pre></td></tr></table></figure><p>这个查询获取平均工资大于 100 的部门，返回他们的部门 id 以及平均工资。用法与前面介绍的 <code>select</code>、<code>where</code> 等函数相似，生成的 SQL 也是十分简单直接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id <span class="keyword">as</span> t_employee_department_id, <span class="built_in">avg</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t_employee.department_id </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(t_employee.salary) <span class="operator">&gt;</span> ?</span><br></pre></td></tr></table></figure><p>值得一提的是，如果我们在这个查询的 <code>select</code> 方法中再加一列会怎么样呢，比如我们希望再返回一下员工的名字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(t)</span><br><span class="line">    .select(t.departmentId, avg(t.salary), t.name)</span><br><span class="line">    .groupBy(t.departmentId)</span><br><span class="line">    .having &#123; avg(t.salary) gt <span class="number">100.0</span> &#125;</span><br></pre></td></tr></table></figure><p>现在生成的 SQL 是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id <span class="keyword">as</span> t_employee_department_id, <span class="built_in">avg</span>(t_employee.salary), t_employee.name <span class="keyword">as</span> t_employee_name </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t_employee.department_id </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(t_employee.salary) <span class="operator">&gt;</span> ? </span><br></pre></td></tr></table></figure><p>然而，了解 SQL 语法的人都知道，这条生成的 SQL 的语法是错误的，完全无法在数据库中执行。这是因为 SQL 语法规定，在使用 group by 时，select 子句中出现的字段，要么是 group by 中的列，要么被包含在聚合函数中。然而，这能怪 Ktorm 吗？这只能怪你对 SQL 的不了解，Ktorm 只是忠实地将你的代码翻译成了 SQL 而已。</p><blockquote><p>注意：Ktorm 虽然有 SQL 生成，但是我们的设计目标，从来都不是为了取代 SQL，我们不希望做成一个大而全的“自动化” ORM 框架，相反，我们的目标是充分使用 Kotlin 优越的语法特性，为 SQL 提供方便灵活的 DSL。这要求使用者对 SQL 有一定的了解，因为 Ktorm 的工作只是将 DSL 忠实地翻译成 SQL 而已，SQL 的正确性和性能都需要使用者自己负起责任。</p></blockquote><h2 id="orderby"><a class="markdownIt-Anchor" href="#orderby"></a> orderBy</h2><p><code>orderBy</code> 也是 <code>Query</code> 的扩展函数，它对应于 SQL 中的 order by 关键字，下面是它的签名：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Query.<span class="title">orderBy</span><span class="params">(<span class="keyword">vararg</span> orders: <span class="type">OrderByExpression</span>)</span></span>: Query</span><br></pre></td></tr></table></figure><p>可以看到，这个函数接受一个或多个 <code>OrderByExpression</code>，这就涉及到另外两个函数，它们分别是 <code>asc</code> 和 <code>desc</code>，和 SQL 中的关键字名称一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ColumnDeclaring<span class="type">&lt;*&gt;</span>.<span class="title">asc</span><span class="params">()</span></span>: OrderByExpression</span><br><span class="line"><span class="function"><span class="keyword">fun</span> ColumnDeclaring<span class="type">&lt;*&gt;</span>.<span class="title">desc</span><span class="params">()</span></span>: OrderByExpression</span><br></pre></td></tr></table></figure><p><code>orderBy</code> 的典型用法如下，这个查询获取所有员工的名字，按工资从高到低排序：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.name)</span><br><span class="line">    .orderBy(Employees.salary.desc())</span><br></pre></td></tr></table></figure><p>与 <code>select</code> 函数一样，<code>orderBy</code> 不仅支持按普通的列排序，还支持复杂的表达式，下面的查询获取每个部门的 ID 和部门内员工的平均工资，并按平均工资从高到低排序：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = Employees.aliased(<span class="string">&quot;t&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(t)</span><br><span class="line">    .select(t.departmentId, avg(t.salary))</span><br><span class="line">    .groupBy(t.departmentId)</span><br><span class="line">    .orderBy(avg(t.salary).desc())</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id <span class="keyword">as</span> t_employee_department_id, <span class="built_in">avg</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t_employee.department_id </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">avg</span>(t_employee.salary) <span class="keyword">desc</span> </span><br></pre></td></tr></table></figure><h2 id="limit"><a class="markdownIt-Anchor" href="#limit"></a> limit</h2><p>SQL 标准中并没有规定如何进行分页查询的语法，因此，每种数据库提供商对其都有不同的实现。例如，在 MySQL 中，分页是通过 <code>limit m, n</code> 语法完成的，在 PostgreSQL 中，则是 <code>limit m offset n</code>，而 Oracle 则没有提供任何关键字，我们需要在 where 子句使用 rownum 限定自己需要的数据页。</p><p>为了抹平不同数据库分页语法的差异，Ktorm 提供了一个 <code>limit</code> 函数，我们使用这个函数对查询进行分页：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Query.<span class="title">limit</span><span class="params">(offset: <span class="type">Int</span>, limit: <span class="type">Int</span>)</span></span>: Query</span><br></pre></td></tr></table></figure><p><code>limit</code> 也是 <code>Query</code> 类的扩展函数，它接收两个整形参数，分别是：</p><ul><li>offset: 需要返回的第一条记录相对于整个查询结果的位移，从 0 开始</li><li>limit: 需要返回的记录的数量</li></ul><p>使用示例如下，这个查询获取员工表的第一条记录：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database.from(Employees).select().limit(<span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>使用 <code>limit</code> 函数时，Ktorm 会根据当前使用的不同数据库（Dialect）生成合适的分页 SQL。但是如果你没有启用任何方言，你可能会得到这样一个异常：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.ktorm.<span class="keyword">database</span>.DialectFeatureNotSupportedException: Pagination <span class="keyword">is</span> <span class="keyword">not</span> supported <span class="keyword">in</span> Standard <span class="keyword">SQL</span>.</span><br></pre></td></tr></table></figure><p>这个是正常的，因为标准 SQL 中的确没有规定分页的语法，因此 Ktorm 无法为你生成这种 SQL，要避免这个异常，要么放弃使用 <code>limit</code> 函数，要么启用一个数据库方言。关于如何<a href="./dialects-and-native-sql.html#%E5%90%AF%E7%94%A8%E6%96%B9%E8%A8%80">启用方言</a>，可参考后面的章节。</p><h2 id="unionunionall"><a class="markdownIt-Anchor" href="#unionunionall"></a> union/unionAll</h2><p>Ktorm 也支持将两个或多个查询的结果进行合并，这时我们使用 <code>union</code> 或 <code>unionAll</code> 函数。其中，<code>union</code> 对应 SQL 中的 union 关键字，会对合并的结果进行去重；<code>unionAll</code> 对应 SQL 中的 union all 关键字，保留重复的结果。下面是一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.id)</span><br><span class="line">    .union(</span><br><span class="line">        database.from(Departments).select(Departments.id)</span><br><span class="line">    )</span><br><span class="line">    .unionAll(</span><br><span class="line">        database.from(Departments).select(Departments.id)</span><br><span class="line">    )</span><br><span class="line">    .orderBy(Employees.id.desc())</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">  select t_employee.id <span class="keyword">as</span> t_employee_id </span><br><span class="line">  from t_employee</span><br><span class="line">) union (</span><br><span class="line">  select t_department.id <span class="keyword">as</span> t_department_id </span><br><span class="line">  from t_department</span><br><span class="line">) union all (</span><br><span class="line">  select t_department.id <span class="keyword">as</span> t_department_id </span><br><span class="line">  from t_department</span><br><span class="line">) </span><br><span class="line">order <span class="keyword">by</span> t_employee_id desc </span><br></pre></td></tr></table></figure><h2 id="aliased"><a class="markdownIt-Anchor" href="#aliased"></a> aliased</h2><p>在 Ktorm 2.6 版本中，我们支持了列别名的功能，这个功能允许我们为查询的列指定别名，并在后续的 <code>group by</code> 和 <code>having</code> 等子句中使用它们，就像 SQL 中的 <code>as</code> 关键字一样。下面是一个例子，这个查询获取平均工资大于 100 的部门，返回他们的部门 id 以及平均工资：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> deptId = Employees.departmentId.aliased(<span class="string">&quot;dept_id&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> salaryAvg = avg(Employees.salary).aliased(<span class="string">&quot;salary_avg&quot;</span>)</span><br><span class="line"></span><br><span class="line">database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(deptId, salaryAvg)</span><br><span class="line">    .groupBy(deptId)</span><br><span class="line">    .having &#123; salaryAvg gt <span class="number">100.0</span> &#125;</span><br><span class="line">    .forEach &#123; row -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;row[deptId]&#125;</span>:<span class="subst">$&#123;row[salaryAvg]&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id <span class="keyword">as</span> dept_id, <span class="built_in">avg</span>(t_employee.salary) <span class="keyword">as</span> salary_avg </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_id </span><br><span class="line"><span class="keyword">having</span> salary_avg <span class="operator">&gt;</span> ? </span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer"><div class="doc-footer-link">上一篇：<a href="/zh-cn/schema-definition.html">定义表结构</a></div><div class="doc-footer-link">下一篇：<a href="/zh-cn/joining.html">联表</a></div>对文档内容有疑问？请在侧边栏尝试搜索或者在 GitHub <a href="https://github.com/kotlin-orm/ktorm/issues/new">提出 issue</a></div></div></article></div></div><div class="doc-footer">&copy; 2024 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script></body></html>