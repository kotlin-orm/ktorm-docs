<!-- build time:Sun Jan 01 2023 08:36:39 GMT+0800 (CST) --><!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Ktorm | 实体增删改</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch@2.6.3/docsearch.min.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"实体增删改",lang:"zh-cn",related_path:"en/entity-dml.html",path:"zh-cn/entity-dml.html"},data:{"navigation-zh-cn":{home:[{title:"快速开始",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"概述",type:"link",path:"zh-cn/",isCurrent:!1},{text:"快速开始",type:"link",path:"zh-cn/quick-start.html",isCurrent:!1},{text:"连接管理",type:"label",isCurrent:!1},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html",isCurrent:!1},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html",isCurrent:!1},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html",isCurrent:!1},{text:"查询",type:"link",path:"zh-cn/query.html",isCurrent:!1},{text:"联表",type:"link",path:"zh-cn/joining.html",isCurrent:!1},{text:"增删改",type:"link",path:"zh-cn/dml.html",isCurrent:!1},{text:"运算符",type:"link",path:"zh-cn/operators.html",isCurrent:!1},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html",isCurrent:!1},{text:"实体类 API",type:"label",isCurrent:!1},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html",isCurrent:!1},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html",isCurrent:!0},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html",isCurrent:!1},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html",isCurrent:!1},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html",isCurrent:!1},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"支持和反馈",type:"label",isCurrent:!1},{text:"API 文档",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html",isCurrent:!1}]},"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"Overview",type:"link",path:"",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!0}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc",algolia:{appId:"2W81KMSLOD",apiKey:"2a146a809de068d9b7a07ba3fb70b4e5",indexName:"ktorm",chunkSize:5e3,fields:["title","lang","date","updated","_content:truncate,0,5200","path","permalink"]}}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><span class="doc-navbar__logo"><a href="/zh-cn/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/entity-dml.html">English</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><div class="dc-search-form doc-search-form"><input type="search" id="doc-search-input" class="dc-input dc-search-form__input doc-search-form__input" placeholder="搜索文档" autofocus><button class="dc-btn dc-search-form__btn doc-search-form__btn" aria-label="Search"><i class="dc-icon dc-icon--search"></i></button></div></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/" target="_self"><span>概述</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/quick-start.html" target="_self"><span>快速开始</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>连接管理</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/connect-to-databases.html" target="_self"><span>连接数据库</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/transaction-management.html" target="_self"><span>事务管理</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/spring-support.html" target="_self"><span>Spring 支持</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/schema-definition.html" target="_self"><span>定义表结构</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/query.html" target="_self"><span>查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/joining.html" target="_self"><span>联表</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/dml.html" target="_self"><span>增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/operators.html" target="_self"><span>运算符</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/dialects-and-native-sql.html" target="_self"><span>方言与原生 SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>实体类 API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entities-and-column-binding.html" target="_self"><span>实体类与列绑定</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-finding.html" target="_self"><span>实体查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-sequence.html" target="_self"><span>实体序列</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/sequence-aggregation.html" target="_self"><span>序列聚合</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current"><a href="/zh-cn/entity-dml.html" target="_self"><span>实体增删改</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/define-entities-as-any-kind-of-classes.html" target="_self"><span>使用任意的类作为实体类</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>支持和反馈</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/api-docs/index.html" target="_self"><span>API 文档</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_self"><span>问题反馈</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/sponsor.html" target="_self"><span>打赏作者</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher" data-reactroot=""><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/entity-dml.html">English</a></span></span></div><div class="dc-page"><div class="dc-card"><div id="doc-search-results" class="doc-search-results"><div id="doc-search-stats"></div><div id="doc-search-hits"></div><div id="doc-search-pagination"></div></div><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/zh-cn/entity-dml.md"><i class="icon fa fa-github"></i> <span class="text">编辑本页</span></a><h1 id="实体增删改"><a href="#实体增删改" class="headerlink" title="实体增删改"></a>实体增删改</h1><p>除了查询以外，序列 API 还支持实体对象的增删改操作。当然，我们首先要定义一些扩展属性，它们使用 <code>sequenceOf</code> 函数创建序列对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Database.departments <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Departments)</span><br><span class="line"><span class="keyword">val</span> Database.employees <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Employees)</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>序列 API 提供了一个扩展函数 <code>add</code>，用来将实体对象插入到数据库，插入成功后，返回受影响的记录数，这个函数的签名如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Entity&lt;E&gt;</span>, T : Table<span class="type">&lt;E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">add</span><span class="params">(entity: <span class="type">E</span>)</span></span>: <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><p>要调用这个函数，我们首先需要创建一个实体对象。根据前面章节的介绍，实体对象的创建既可以调用 <code>Entity.create</code> 函数，也可以选择为实体类添加一个继承于 <code>Entity.Factory</code> 的伴随对象，这里我们选择第二种方式。下面的代码创建了一个员工对象，并将它插入到数据库中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = Employee &#123;</span><br><span class="line">    name = <span class="string">"jerry"</span></span><br><span class="line">    job = <span class="string">"trainee"</span></span><br><span class="line">    hireDate = LocalDate.now()</span><br><span class="line">    salary = <span class="number">50</span></span><br><span class="line">    department = database.departments.find &#123; it.name eq <span class="string">"tech"</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">database.employees.add(employee)</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们创建了一个员工对象，并为它的各个属性设置了初始值。值得注意的是 <code>department</code> 这个属性，它是员工所属的部门，它的值是通过序列 API 从数据库中查询获得的实体对象，在调用 <code>add</code> 函数的时候，它的 ID 会被保存在 <code>Employees</code> 表中。生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_employee (<span class="keyword">name</span>, job, hire_date, salary, department_id) </span><br><span class="line"><span class="keyword">values</span> (?, ?, ?, ?, ?)</span><br></pre></td></tr></table></figure><p>可以看到，生成的 SQL 包含了 <code>Employee</code> 实体对象中的所有已赋值的属性，如果我们将某个字段的赋值代码去掉，那么生成的 insert SQL 中就不会出现这个字段。例如，创建实体对象时只设置员工名称 <code>Employee { name = &quot;jerry&quot; }</code>，那么生成的 SQL 也只会插入这一个字段 <code>insert into t_employee (name) values (?)</code>。</p><p>如果我们使用了数据库的自增主键功能，那么只要在表对象中使用 <code>primaryKey</code> 指定了主键列，<code>add</code> 函数在执行完插入之后，会自动从数据库中获取生成的主键，并填充到相应的属性中。但是这个功能要求我们不能事先设置了主键属性的值，如果你这样做了，所设置的值会被插入到数据库中，并且不会触发自增主键的生成。</p><p>还是以上面的代码为例，我们在创建实体对象时没有为其设置 <code>id</code> 属性，那么在执行完 <code>add</code> 方法之后，通过 <code>employee.id</code> 即可获取生成的主键。如果我们事先设置其 <code>id</code> 为某个值，那么生成的 SQL 就会包含该列，将它插入到数据库，插入后使用 <code>employee.id</code> 获取到的也是我们事先设置的这个值。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>我们知道，Ktorm 的实体类都定义为接口，并且继承 <code>Entity</code>。<code>Entity</code> 接口为实体对象注入了许多有用的函数，我们先来看一下它的定义，看看都有哪些函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Entity</span>&lt;<span class="type">E : Entity&lt;E</span>&gt;&gt; : <span class="type">Serializable &#123;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">flushChanges</span><span class="params">()</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">discardChanges</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">()</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(name: <span class="type">String</span>)</span></span>: Any?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">set</span><span class="params">(name: <span class="type">String</span>, value: <span class="type">Any</span>?)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面有一个 <code>flushChanges</code> 函数，它的功能正是将实体对象的修改更新到数据库，执行后返回受影响的记录数。典型用法是先使用序列 API 从数据库中获取实体对象，然后按需修改它们的属性值，最后再调用 <code>flushChanges</code> 保存这些修改。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123; it.id eq <span class="number">5</span> &#125; ?: <span class="keyword">return</span></span><br><span class="line">employee.job = <span class="string">"engineer"</span></span><br><span class="line">employee.salary = <span class="number">100</span></span><br><span class="line">employee.flushChanges()</span><br></pre></td></tr></table></figure><p>上面的代码会生成两句 SQL，第一句是 <code>find</code> 前面已经介绍过，不必多说，<code>flushChanges</code> 生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_employee <span class="keyword">set</span> job = ?, salary = ? <span class="keyword">where</span> <span class="keyword">id</span> = ?</span><br></pre></td></tr></table></figure><p>如果我们删除 <code>employee.salary = 100</code> 一行，只修改 <code>job</code> 属性，那么生成的 SQL 就会变成 <code>update t_employee set job = ? where id = ?</code>；如果我们不修改任何属性，直接调用 <code>flushChanges</code>，那么什么也不会发生，<code>flushChanges</code> 会直接返回 0。可见 Ktorm 会在内部跟踪实体对象的状态变化，这个跟踪是通过 JDK 动态代理来实现的，这正是 Ktorm 要求将实体类定义为接口的原因。</p><p><code>discardChanges</code> 方法会清除 Ktorm 内部保存的该实体对象的状态变化信息，调用此函数之后，再调用 <code>flushChanges</code> 不会发生任何事情，因为 Ktorm 已经检测不到任何属性的变化。另外，如果连续对同一个实体对象调用两次 <code>flushChanges</code>，第一次调用之后，由于属性的变化已经保存到数据库，因此 Ktorm 会在内部清除它的状态数据，第二次 <code>flushChanges</code> 调用也不会发生任何事情。</p><p>使用 <code>flushChanges</code> 函数还有以下两个注意事项：</p><ol><li>该函数要求在表对象中必须使用 <code>primaryKey</code> 函数指定主键列，否则 Ktorm 无法确定实体对象的唯一标识，在调用 <code>flushChanges</code> 的时候就会抛出异常。</li><li>调用 <code>flushChanges</code> 的实体对象必须首先”与数据库关联“。在 Ktorm 的实现中，实体对象的内部持有一个数据库对象的引用 <code>fromDatabase</code>。使用序列 API 获取的实体对象，其内部的 <code>fromDatabase</code> 引用都指向查询的当前数据库。使用 <code>Entity.create</code> 函数或 <code>Entity.Factory</code> 新创建的实体对象，其 <code>fromDatabase</code> 引用初始为空，因此不能对其调用 <code>flushChanges</code>，但是在使用 <code>add</code> 或 <code>update</code> 函数将其保存到数据库后，<code>fromDatabase</code> 会被修改为当前数据库对象，再调用 <code>flushChanges</code> 函数就没有问题了。</li></ol><blockquote><p>对于以上第二点，通俗来说，调用 <code>flushChanges</code> 函数的实体对象，必须来自序列 API 或者已被 <code>add</code> 或 <code>update</code> 函数保存到数据库。还有一点需要注意，在序列化时，Ktorm 只会保存各个属性的值，包括 <code>fromDatabase</code> 在内的用于追踪实体状态变化的数据都会丢失（被标记为 transient），因此你无法在一个系统中获取实体，然后在另一个系统中调用实体的 <code>flushChanges</code> 方法将属性变化更新到数据库。</p></blockquote><p>在 Ktorm 3.1 版本中，序列 API 还提供了一个 <code>update</code> 函数，可以把指定实体对象中的所有已赋值的属性都更新到数据库。使用这个函数，我们不需要先把实体对象“与数据库关联”，也就是说，执行更新操作之前，可以省去一次查询。使用方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = Employee &#123;</span><br><span class="line">    id = <span class="number">5</span></span><br><span class="line">    job = <span class="string">"engineer"</span></span><br><span class="line">    salary = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">database.employees.update(employee)</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_employee <span class="keyword">set</span> job = ?, salary = ? <span class="keyword">where</span> <span class="keyword">id</span> = ?</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><code>Entity</code> 接口中还有一个 <code>delete</code> 函数，它的功能是从数据库中删除该实体对象，执行后返回受影响的记录数。典型用法是先使用序列 API 从数据库中获取实体对象，然后根据条件按需调用 <code>delete</code> 函数将其删除：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123; it.id eq <span class="number">5</span> &#125; ?: <span class="keyword">return</span></span><br><span class="line">employee.delete()</span><br></pre></td></tr></table></figure><p><code>delete</code> 函数生成的 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t_employee <span class="keyword">where</span> <span class="keyword">id</span> = ?</span><br></pre></td></tr></table></figure><p>与 <code>flushChanges</code> 相同， 使用 <code>delete</code> 函数也有两个注意事项：</p><ol><li>在表对象中必须使用 <code>primaryKey</code> 函数指定主键列，否则 Ktorm 无法确定实体对象的唯一标识。</li><li>调用 <code>delete</code> 函数的实体对象必须首先”与数据库关联“。</li></ol><p>最后，序列 API 还提供了 <code>removeIf</code> 和 <code>clear</code> 两个函数，<code>removeIf</code> 可以删除表中符合条件的记录，<code>clear</code> 可以删除表中的所有记录。下面使用 <code>removeIf</code> 删除部门 1 中的所有员工：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">database.employees.removeIf &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t_employee <span class="keyword">where</span> department_id = ?</span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer" data-reactroot=""><div class="doc-footer-link">上一篇：<a href="/zh-cn/sequence-aggregation.html">序列聚合</a></div><div class="doc-footer-link">下一篇：<a href="/zh-cn/define-entities-as-any-kind-of-classes.html">使用任意的类作为实体类</a></div>对文档内容有疑问？请在侧边栏尝试搜索或者在 GitHub <a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank" rel="noopener">提出 issue</a></div></div></article></div></div><div class="doc-footer">&copy; 2023 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm" target="_blank" rel="noopener">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script><script type="text/javascript" src="/vendors/docsearch@2.6.3/docsearch.min.js"></script><script type="text/javascript">docsearch({appId:"0DGANM0MZ3",apiKey:"071ea85fb6b0933d3f3d3925aa434e23",indexName:"ktorm",inputSelector:"#doc-search-input",algoliaOptions:{facetFilters:["lang:zh-cn","tags:doc"]},autocompleteOptions:{hint:!1,appendTo:"body"},debug:!1})</script><script>!function(){$(".kotlin .code .keyword").each(function(){var e=$(this);("where"===e.text()||"set"===e.text())&&e.removeClass("keyword")})}()</script></body></html><!-- rebuild by neat -->