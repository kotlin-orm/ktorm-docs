<!-- build time:Sun Jun 19 2022 23:51:59 GMT+0800 (CST) --><!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Ktorm | 序列聚合</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch@2.6.3/docsearch.min.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"序列聚合",lang:"zh-cn",related_path:"en/sequence-aggregation.html",path:"zh-cn/sequence-aggregation.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"Overview",type:"link",path:"",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!0},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]},"navigation-zh-cn":{home:[{title:"快速开始",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"概述",type:"link",path:"zh-cn/",isCurrent:!1},{text:"快速开始",type:"link",path:"zh-cn/quick-start.html",isCurrent:!1},{text:"连接管理",type:"label",isCurrent:!1},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html",isCurrent:!1},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html",isCurrent:!1},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html",isCurrent:!0},{text:"查询",type:"link",path:"zh-cn/query.html",isCurrent:!1},{text:"联表",type:"link",path:"zh-cn/joining.html",isCurrent:!1},{text:"增删改",type:"link",path:"zh-cn/dml.html",isCurrent:!1},{text:"运算符",type:"link",path:"zh-cn/operators.html",isCurrent:!1},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html",isCurrent:!1},{text:"实体类 API",type:"label",isCurrent:!1},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html",isCurrent:!1},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html",isCurrent:!1},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html",isCurrent:!1},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html",isCurrent:!1},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html",isCurrent:!1},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"支持和反馈",type:"label",isCurrent:!1},{text:"API 文档",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html",isCurrent:!1}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc",algolia:{appId:"2W81KMSLOD",apiKey:"2a146a809de068d9b7a07ba3fb70b4e5",indexName:"ktorm",chunkSize:5e3,fields:["title","lang","date","updated","_content:truncate,0,5200","path","permalink"]}}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><span class="doc-navbar__logo"><a href="/zh-cn/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/sequence-aggregation.html">English</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><div class="dc-search-form doc-search-form"><input type="search" id="doc-search-input" class="dc-input dc-search-form__input doc-search-form__input" placeholder="搜索文档" autofocus><button class="dc-btn dc-search-form__btn doc-search-form__btn" aria-label="Search"><i class="dc-icon dc-icon--search"></i></button></div></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/" target="_self"><span>概述</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/quick-start.html" target="_self"><span>快速开始</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>连接管理</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/connect-to-databases.html" target="_self"><span>连接数据库</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/transaction-management.html" target="_self"><span>事务管理</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/spring-support.html" target="_self"><span>Spring 支持</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/schema-definition.html" target="_self"><span>定义表结构</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/query.html" target="_self"><span>查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/joining.html" target="_self"><span>联表</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/dml.html" target="_self"><span>增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/operators.html" target="_self"><span>运算符</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/dialects-and-native-sql.html" target="_self"><span>方言与原生 SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>实体类 API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entities-and-column-binding.html" target="_self"><span>实体类与列绑定</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-finding.html" target="_self"><span>实体查询</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-sequence.html" target="_self"><span>实体序列</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current"><a href="/zh-cn/sequence-aggregation.html" target="_self"><span>序列聚合</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/entity-dml.html" target="_self"><span>实体增删改</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/define-entities-as-any-kind-of-classes.html" target="_self"><span>使用任意的类作为实体类</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>支持和反馈</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/api-docs/index.html" target="_self"><span>API 文档</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_self"><span>问题反馈</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/zh-cn/sponsor.html" target="_self"><span>打赏作者</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher" data-reactroot=""><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/sequence-aggregation.html">English</a></span></span></div><div class="dc-page"><div class="dc-card"><div id="doc-search-results" class="doc-search-results"><div id="doc-search-stats"></div><div id="doc-search-hits"></div><div id="doc-search-pagination"></div></div><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/zh-cn/sequence-aggregation.md"><i class="icon fa fa-github"></i> <span class="text">编辑本页</span></a><h1 id="序列聚合"><a href="#序列聚合" class="headerlink" title="序列聚合"></a>序列聚合</h1><p>实体序列 API 不仅可以让我们使用类似 <code>kotlin.sequences</code> 的方式获取数据库中的实体对象，它还支持丰富的聚合功能，让我们可以方便地对指定字段进行计数、求和、求平均值等操作。</p><h2 id="简单聚合"><a href="#简单聚合" class="headerlink" title="简单聚合"></a>简单聚合</h2><p>我们首先来看看 <code>aggregateColumns</code> 函数的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>, C : Any&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">aggregateColumns</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    aggregationSelector: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">C</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: C?</span><br></pre></td></tr></table></figure><p>这是一个终止操作，它接收一个闭包作为参数，在闭包中，我们需要返回一个聚合表达式。Ktorm 会使用我们返回的聚合表达式，根据当前序列的查询条件创建一个聚合查询， 然后执行这个查询，获取聚合的结果。下面的代码获取部门 1 中工资的最大值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .aggregateColumns &#123; max(it.salary) &#125;</span><br></pre></td></tr></table></figure><p>如果你希望同时获取多个聚合结果，可以在闭包中使用 <code>tupleOf</code> 包装我们的这些聚合表达式，函数的返回值就相应变成了 <code>TupleN&lt;C1?, C2?, .. Cn?&gt;</code>。下面的例子获取部门 1 中工资的平均值和极差：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (avg, diff) = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .aggregateColumns &#123; tupleOf(avg(it.salary), max(it.salary) - min(it.salary)) &#125;</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(t_employee.salary), <span class="keyword">max</span>(t_employee.salary) - <span class="keyword">min</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">where</span> t_employee.department_id = ?</span><br></pre></td></tr></table></figure><blockquote><p>与 <code>mapColumns</code> 类似，由于 <code>tupleOf</code> 函数的返回值是 <code>Tuple2</code> 到 <code>Tuple9</code>，我们最多可以使用 <code>aggregateColumns</code> 系列函数一次获得九个聚合结果。</p></blockquote><p>除了直接使用 <code>aggregateColumns</code> 函数以外，Ktorm 还为序列提供了许多方便的辅助函数，他们都是基于 <code>aggregateColumns</code> 函数实现的。比如 <code>maxBy { it.salary }</code> 即可获得工资的最大值，相当于 <code>aggregateColumns { max(it.salary) }</code>。下面是这些函数的一个列表：</p><table><thead><tr><th>函数名</th><th>使用示例</th><th>示例描述</th><th>相当于</th></tr></thead><tbody><tr><td>count</td><td><code>count { it.salary gt 1000 }</code></td><td>获取薪水超 1000 的员工数</td><td><code>filter { it.salary gt 1000 }</code><br><code>.aggregateColumns { count() }</code></td></tr><tr><td>any</td><td><code>any { it.salary gt 1000 }</code></td><td>判断是否存在薪水大于 1000 的员工</td><td><code>count { it.salary gt 1000 } &gt; 0</code></td></tr><tr><td>none</td><td><code>none { it.salary gt 1000 }</code></td><td>判断是否不存在薪水大于 1000 的员工</td><td><code>count { it.salary gt 1000 } == 0</code></td></tr><tr><td>all</td><td><code>all { it.salary gt 1000 }</code></td><td>判断是否所有员工的薪水都大于 1000</td><td><code>count { it.salary lte 1000 } == 0</code></td></tr><tr><td>sumBy</td><td><code>sumBy { it.salary }</code></td><td>获得员工的薪水总和</td><td><code>aggregateColumns { sum(it.salary) }</code></td></tr><tr><td>maxBy</td><td><code>maxBy { it.salary }</code></td><td>获得员工薪水的最大值</td><td><code>aggregateColumns { max(it.salary) }</code></td></tr><tr><td>minBy</td><td><code>minBy { it.salary }</code></td><td>获得员工薪水的最小值</td><td><code>aggregateColumns { min(it.salary) }</code></td></tr><tr><td>averageBy</td><td><code>averageBy { it.salary }</code></td><td>获得员工薪水的平均值</td><td><code>aggregateColumns { avg(it.salary) }</code></td></tr></tbody></table><h2 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h2><p>要使用分组聚合，我们首先要学习如何对序列中的元素进行分组。Ktorm 为实体序列提供了两个不同的分组函数，它们是 <code>groupBy</code> 和 <code>groupingBy</code>。</p><h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, K&gt;</span> EntitySequence<span class="type">&lt;E, *&gt;</span>.<span class="title">groupBy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    keySelector: (<span class="type">E</span>) -&gt; <span class="type">K</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Map&lt;K, List&lt;E&gt;&gt;</span><br></pre></td></tr></table></figure><p>很明显，这是一个终止操作，它会马上执行查询，迭代所有返回的实体对象，通过闭包传入的 <code>keySelector</code> 获取实体对象的分组 key，按照这个 key 对它们进行分组，将每个元素添加到所属组的集合中。下面的代码获取所有员工对象，并按部门进行分组：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.groupBy &#123; it.department.id &#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>employees</code> 的类型是 <code>Map&lt;Int, List&lt;Employee&gt;&gt;</code>，其中，key 是部门 ID，value 是在这个部门下的所有员工的列表。现在我们已经有了所有部门下的员工列表，然后就可以使用这些数据进行一些聚合计算。比如下面的代码可以计算出所有部门的平均工资：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageSalaries = database.employees</span><br><span class="line">    .groupBy &#123; it.department.id &#125;</span><br><span class="line">    .mapValues &#123; (_, employees) -&gt; employees.map &#123; it.salary &#125;.average() &#125;</span><br></pre></td></tr></table></figure><p>但可惜的是，我们这里的聚合计算是在 JVM 完成的，所生成的 SQL 依然获取了所有的员工数据，尽管我们并不需要他们：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee</span><br></pre></td></tr></table></figure><p>如果仅仅需要计算平均工资，却不得不获取数据库中的所有员工数据，这个性能开销在大多数时候都是不可忍受的。那么我们能不能利用 SQL 中自带的 group by 和聚合功能，生成恰当的 SQL，让数据库来帮我们进行聚合计算呢？这时我们应该使用下面将要介绍的 <code>groupingBy</code> 函数。</p><blockquote><p>请注意 <code>groupBy</code> 和 <code>groupingBy</code> 函数的区别，它们设计的使用场景是完全不同的。<code>groupBy</code> 是终止操作，它会获取当前序列中的所有实体对象，在 JVM 内存中对它们进行分组；<code>groupingBy</code> 是中间操作，它会为最终生成的 SQL 添加一个 group by 子句，具体执行的聚合操作需要在后续使用 <code>EntityGrouping</code> 的扩展函数来指定。</p></blockquote><h3 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>, K : Any&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">groupingBy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    keySelector: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">K</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: EntityGrouping&lt;E, T, K&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> EntityGrouping(<span class="keyword">this</span>, keySelector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>groupingBy</code> 是一个中间操作，它接收一个闭包作为参数，我们需要在闭包中返回一个 <code>ColumnDeclaring&lt;K&gt;</code> 作为 SQL group by 子句中的列。实际上，<code>groupingBy</code> 函数什么也没做，它只是使用我们传入的 <code>keySelector</code> 创建了一个 <code>EntityGrouping</code> 对象而已。<code>EntityGrouping</code> 的定义也十分简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityGrouping</span>&lt;<span class="type">E : Any, T : BaseTable&lt;E</span>&gt;, <span class="type">K : Any&gt;</span></span>(</span><br><span class="line">    <span class="keyword">val</span> sequence: EntitySequence&lt;E, T&gt;,</span><br><span class="line">    <span class="keyword">val</span> keySelector: (T) -&gt; ColumnDeclaring&lt;K&gt;</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asKotlinGrouping</span><span class="params">()</span></span>: kotlin.collections.Grouping&lt;E, K?&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分 <code>EntityGrouping</code> 的 API，都是以扩展函数的方式来提供的，我们首先来看看最基本的 <code>aggregateColumns</code> 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>, K : Any, C : Any&gt; EntityGrouping<span class="type">&lt;E, T, K&gt;</span>.<span class="title">aggregateColumns</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    aggregationSelector: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">C</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Map&lt;K?, C?&gt;</span><br></pre></td></tr></table></figure><p>与 <code>EntitySequence</code> 的 <code>aggregateColumns</code> 函数类似，这是一个终止操作，它接收一个闭包作为参数，在闭包中，我们需要返回一个聚合表达式。Ktorm 会使用我们返回的聚合表达式，根据当前序列的查询条件和分组条件创建一个聚合查询，然后执行这个查询，获取聚合的结果。它的返回值是 <code>Map&lt;K?, C?&gt;</code>，其中，key 是我们的分组列的值，value 是该组中的聚合结果。下面的代码可以获取所有部门的平均工资：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .aggregateColumns &#123; avg(it.salary) &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这时生成的 SQL 就使用了 group by 子句，把聚合计算放到了数据库中执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id, <span class="keyword">avg</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t_employee.department_id</span><br></pre></td></tr></table></figure><p>如果你希望同时获取多个聚合结果，可以在闭包中使用 <code>tupleOf</code> 包装我们的这些聚合表达式，函数的返回值就相应变成了 <code>Map&lt;K?, TupleN&lt;C1?, C2?, .. Cn?&gt;&gt;</code>。下面的例子会打印出所有部门工资的平均值和极差：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .aggregateColumns &#123; tupleOf(avg(it.salary), max(it.salary) - min(it.salary)) &#125;</span><br><span class="line">    .forEach &#123; departmentId, (avg, diff) -&gt;</span><br><span class="line">        println(<span class="string">"<span class="variable">$departmentId</span>:<span class="variable">$avg</span>:<span class="variable">$diff</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生成 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id, <span class="keyword">avg</span>(t_employee.salary), <span class="keyword">max</span>(t_employee.salary) - <span class="keyword">min</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t_employee.department_id</span><br></pre></td></tr></table></figure><p>除了直接使用 <code>aggregateColumns</code> 函数以外，Ktorm 还提供了许多方便的辅助函数，它们都是基于 <code>aggregateColumns</code> 函数实现的，下面是这些函数的列表：</p><table><thead><tr><th>函数名</th><th>使用示例</th><th>示例描述</th><th>相当于</th></tr></thead><tbody><tr><td>eachCount(To)</td><td><code>eachCount()</code></td><td>获取每个分组的记录数量</td><td><code>aggregateColumns { count() }</code></td></tr><tr><td>eachSumBy(To)</td><td><code>eachSumBy { it.salary }</code></td><td>获取每个分组的工资总和</td><td><code>aggregateColumns { sum(it.salary) }</code></td></tr><tr><td>eachMaxBy(To)</td><td><code>eachMaxBy { it.salary }</code></td><td>获取每个分组的最高工资</td><td><code>aggregateColumns { max(it.salary) }</code></td></tr><tr><td>eachMinBy(To)</td><td><code>eachMinBy { it.salary }</code></td><td>获取每个分组的最低工资</td><td><code>aggregateColumns { min(it.salary) }</code></td></tr><tr><td>eachAverageBy(To)</td><td><code>eachAverageBy { it.salary }</code></td><td>获取每个分组的平均工资</td><td><code>aggregateColumns { avg(it.salary) }</code></td></tr></tbody></table><p>有了这些辅助函数，上面获取所有部门平均工资的代码就可以改写成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .eachAverageBy &#123; it.salary &#125;</span><br></pre></td></tr></table></figure><p>除此之外，Ktorm 还提供了 <code>aggregate</code>、<code>fold</code>、<code>reduce</code> 等函数，它们与 <code>kotlin.collections.Grouping</code> 的相应函数同名，功能也完全一样。下面的代码使用 <code>fold</code> 函数计算每个部门工资的总和：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> totalSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .fold(<span class="number">0L</span>) &#123; acc, employee -&gt; </span><br><span class="line">        acc + employee.salary </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当然，如果仅仅为了获得工资总和，我们没必要这样做。这是性能低下的写法，它会查询出所有员工的数据，然后对它们进行迭代，这里仅用作示范，更好的写法是使用 <code>eachSumBy</code> 函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> totalSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .eachSumBy &#123; it.salary &#125;</span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer" data-reactroot=""><div class="doc-footer-link">上一篇：<a href="/zh-cn/entity-sequence.html">实体序列</a></div><div class="doc-footer-link">下一篇：<a href="/zh-cn/entity-dml.html">实体增删改</a></div>对文档内容有疑问？请在侧边栏尝试搜索或者在 GitHub <a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank" rel="noopener">提出 issue</a></div></div></article></div></div><div class="doc-footer">&copy; 2022 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm" target="_blank" rel="noopener">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script><script type="text/javascript" src="/vendors/docsearch@2.6.3/docsearch.min.js"></script><script type="text/javascript">docsearch({appId:"0DGANM0MZ3",apiKey:"071ea85fb6b0933d3f3d3925aa434e23",indexName:"ktorm",inputSelector:"#doc-search-input",algoliaOptions:{facetFilters:["lang:zh-cn","tags:doc"]},autocompleteOptions:{hint:!1,appendTo:"body"},debug:!1})</script><script>!function(){$(".kotlin .code .keyword").each(function(){var e=$(this);("where"===e.text()||"set"===e.text())&&e.removeClass("keyword")})}()</script></body></html><!-- rebuild by neat -->