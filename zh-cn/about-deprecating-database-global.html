<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>Ktorm | 关于废弃 Database.global 对象的说明</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch@2.6.3/docsearch.min.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"关于废弃 Database.global 对象的说明",lang:"zh-cn",related_path:"en/about-deprecating-database-global.html",path:"zh-cn/about-deprecating-database-global.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"GETTING STARTED",type:"label"},{text:"Overview",type:"link",path:"/"},{text:"Quick Start",type:"link",path:"en/quick-start.html"},{text:"CONNECTION MANAGEMENT",type:"label"},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html"},{text:"Transaction Management",type:"link",path:"en/transaction-management.html"},{text:"Spring Support",type:"link",path:"en/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"Schema Definition",type:"link",path:"en/schema-definition.html"},{text:"Query",type:"link",path:"en/query.html"},{text:"Joining",type:"link",path:"en/joining.html"},{text:"Data Manipulation",type:"link",path:"en/dml.html"},{text:"Operators",type:"link",path:"en/operators.html"},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html"},{text:"ENTITY API",type:"label"},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html"},{text:"Entity Query",type:"link",path:"en/entity-finding.html"},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html"},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html"},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html"},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html"},{text:"SUPPORT & FEEDBACK",type:"label"},{text:"API Documents",type:"support-link",path:"api-docs/index.html",target:"_blank"},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank"},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html"}]},"navigation-zh-cn":{home:[{title:"快速上手",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"开始",type:"label"},{text:"简介",type:"link",path:"zh-cn/"},{text:"快速上手",type:"link",path:"zh-cn/quick-start.html"},{text:"连接管理",type:"label"},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html"},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html"},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html"},{text:"查询",type:"link",path:"zh-cn/query.html"},{text:"联表",type:"link",path:"zh-cn/joining.html"},{text:"增删改",type:"link",path:"zh-cn/dml.html"},{text:"运算符",type:"link",path:"zh-cn/operators.html"},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html"},{text:"实体类 API",type:"label"},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html"},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html"},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html"},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html"},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html"},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html"},{text:"支持和反馈",type:"label"},{text:"API 文档",type:"support-link",path:"api-docs/index.html",target:"_blank"},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank"},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html"}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc"}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation"><nav class="doc-navbar"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="doc-navbar__logo"><a href="/zh-cn/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close"></i><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/about-deprecating-database-global.html">English</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><div class="dc-search-form doc-search-form"><input type="search" id="doc-search-input" class="dc-input dc-search-form__input doc-search-form__input" placeholder="搜索文档" autofocus><button class="dc-btn dc-search-form__btn doc-search-form__btn" aria-label="Search"><i class="dc-icon dc-icon--search"></i></button></div></div><ul class="doc-sidebar-list"></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher"><span><img src="/images/cn.png"><span>简体中文</span></span><span class="lang-divider"> | </span><span><img src="/images/us.png"><a href="/en/about-deprecating-database-global.html">English</a></span></span></div><div class="dc-page"><div class="dc-card"><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/zh-cn/about-deprecating-database-global.md"><i class="icon fa fa-github"></i> <span class="text">编辑本页</span></a><h1 id="关于废弃-databaseglobal-对象的说明"><a class="markdownIt-Anchor" href="#关于废弃-databaseglobal-对象的说明"></a> 关于废弃 Database.global 对象的说明</h1><p>在 Ktorm 2.7 版本中，我们对代码进行了一次重构，这次重构废弃掉了 <code>Database.global</code> 以及基于它实现的一系列函数，使 Ktorm 的 API 设计更加直观、更易扩展。</p><h2 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h2><p>在之前的版本中，<code>Database.connect</code> 函数会自动把最近一次创建的 <code>Database</code> 对象保存到一个全局变量中，在需要的时候，Ktorm 会通过 <code>Database.global</code> 获取到这个对象进行操作。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Database.global.useConnection &#123; conn -&gt; </span><br><span class="line">    <span class="comment">// 使用连接进行操作...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有时候，我们需要在一个 App 中操作多个数据库，这时就需要创建多个 <code>Database</code> 对象，在执行具体的操作时，指定你要使用哪个数据库。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mysql = Database.connect(<span class="string">&quot;jdbc:mysql://localhost:3306/ktorm&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> h2 = Database.connect(<span class="string">&quot;jdbc:h2:mem:ktorm;DB_CLOSE_DELAY=-1&quot;</span>)</span><br><span class="line"></span><br><span class="line">mysql &#123;</span><br><span class="line">    <span class="comment">// 获取 MySQL 数据库中的员工列表</span></span><br><span class="line">    <span class="keyword">for</span> (employee <span class="keyword">in</span> Employees.asSequence()) &#123;</span><br><span class="line">        println(employee)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h2 &#123;</span><br><span class="line">    <span class="comment">// 获取 H2 数据库中的员工列表</span></span><br><span class="line">    <span class="keyword">for</span> (employee <span class="keyword">in</span> Employees.asSequence()) &#123;</span><br><span class="line">        println(employee)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们使用 <code>db &#123; &#125;</code> 的语法实现了多数据源的切换，但是现在看来，这并不是一个很好的设计，理由如下：</p><ul><li><code>db &#123; &#125;</code> 使用 <code>ThreadLocal</code> 实现，这种切换数据源的方式过于隐蔽，可能会导致一些误解，产生一些意料之外的 bug，比如 <a href="https://github.com/kotlin-orm/ktorm/issues/65">#65</a>, <a href="https://github.com/kotlin-orm/ktorm/issues/27">#27</a></li><li>使用全局变量是糟糕的设计模式，这样写出来的代码会与全局的状态耦合，不方便进行单元测试，也不方便以后的扩展，相关的讨论有 <a href="https://github.com/kotlin-orm/ktorm/issues/47">#47</a>, <a href="https://github.com/kotlin-orm/ktorm/issues/41">#41</a></li></ul><h2 id="修改点"><a class="markdownIt-Anchor" href="#修改点"></a> 修改点</h2><p>这次重构，我们的主要目标就是废弃掉 <code>Database.global</code> 全局变量以及与之相关的一系列 API，让用户在操作数据库的时候，显式地指定要使用的 <code>Database</code> 对象，而不是隐式地使用 <code>Database.global</code>。</p><p>在之前，虽然 <code>Database.connect</code> 函数会返回一个 <code>Database</code> 对象，但是我们通常都会忽略它，因为 Ktorm 会自动把它保存到内部的全局变量中。但是现在，我们必须自己定义一个变量去接收它的返回值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> database = Database.connect(<span class="string">&quot;jdbc:mysql://localhost:3306/ktorm&quot;</span>, user = <span class="string">&quot;root&quot;</span>, password = <span class="string">&quot;***&quot;</span>)</span><br></pre></td></tr></table></figure><p>在之前，我们直接使用 <code>Table.select</code> 扩展函数就可以创建一个查询：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧 API</span></span><br><span class="line"><span class="keyword">for</span> (row <span class="keyword">in</span> Employees.select()) &#123;</span><br><span class="line">    println(row[Employees.name])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个查询使用 <code>Database.global</code> 对象，从 <code>Employees</code> 表中获取所有的记录，可以看到，这确实十分隐蔽。现在，我们必须要显式指定数据源对象，改用 <code>database.from(..).select(..)</code> 的语法创建查询：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (row <span class="keyword">in</span> database.from(Employees).select()) &#123;</span><br><span class="line">    println(row[Employees.name])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个稍微复杂的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = Employees.aliased(<span class="string">&quot;t&quot;</span>)</span><br><span class="line">database</span><br><span class="line">    .from(t)</span><br><span class="line">    .select(t.departmentId, avg(t.salary))</span><br><span class="line">    .groupBy(t.departmentId)</span><br><span class="line">    .having &#123; avg(t.salary) greater <span class="number">100.0</span> &#125;</span><br><span class="line">    .forEach &#123; row -&gt; </span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;row.getInt(<span class="number">1</span>)&#125;</span>:<span class="subst">$&#123;row.getDouble(<span class="number">2</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出，SQL DSL 的修改十分简单，我们只需要把原来 <code>Table.select</code> 的语法改成 <code>database.from(..).select(..)</code> 即可。至于序列 API，我们之前是通过 <code>asSequence</code> 扩展函数获取序列对象，现在也只需要改成 <code>sequenceOf</code> 函数，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.sequenceOf(Employees).toList()</span><br></pre></td></tr></table></figure><p>再举一个稍微复杂的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database</span><br><span class="line">    .sequenceOf(Employees)</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .filter &#123; it.managerId.isNotNull() &#125;</span><br><span class="line">    .sortedBy &#123; it.salary &#125;</span><br><span class="line">    .toList()</span><br></pre></td></tr></table></figure><p>以上就是本次重构中最明显的两个变化，Ktorm 官网中的文档现在都已经针对 2.7 版本做了更新，您可以查阅最新的文档获取你感兴趣的内容。</p><p>下面附上本次重构废弃的所有 API 的列表，这些 API 在 2.7 版本中仍然可用，但是已经被标记为 <code>@Deprecated</code>，并且将会在未来的版本中彻底移除。</p><table><thead><tr><th>废弃用法</th><th>新的用法</th></tr></thead><tbody><tr><td>Database.global</td><td>-</td></tr><tr><td>Employees.select()</td><td>database.from(Employees).select()</td></tr><tr><td>Employees.xxxJoin(Departments)</td><td>database.from(Employees).xxxJoin(Departments)</td></tr><tr><td>Employees.joinReferencesAndSelect()</td><td>database.from(Employees).joinReferencesAndSelect()</td></tr><tr><td>Employees.createEntityWithoutReferences(row)</td><td>Employees.createEntity(row, withReferences = false)</td></tr><tr><td>Employees.asSequence()</td><td>database.sequenceOf(Employees)</td></tr><tr><td>Employees.asSequenceWithoutReferences()</td><td>database.sequenceOf(Employees, withReferences = false)</td></tr><tr><td>Employees.findList { … }</td><td>database.sequenceOf(Employees).filter { … }.toList()</td></tr><tr><td>Employees.findAll()</td><td>database.sequenceOf(Employees).toList()</td></tr><tr><td>Employees.findOne { … }</td><td>database.sequenceOf(Employees).find { … }</td></tr><tr><td>Employees.findById(id)</td><td>database.sequenceOf(Employees).find { <a href="http://it.id">it.id</a> eq id }</td></tr><tr><td>Employees.findListByIds(ids)</td><td>database.sequenceOf(Employees).filter { <a href="http://it.id">it.id</a> inList ids }.toList()</td></tr><tr><td>Employees.findMapByIds(ids)</td><td>database.sequenceOf(Employees).filter { <a href="http://it.id">it.id</a> inList ids }.associateBy { <a href="http://it.id">it.id</a> }</td></tr><tr><td>Employees.update { … }</td><td>database.update(Employees) { … }</td></tr><tr><td>Employees.batchUpdate { … }</td><td>database.batchUpdate(Employees) { … }</td></tr><tr><td>Employees.insert { … }</td><td>database.insert(Employees) { … }</td></tr><tr><td>Employees.batchInsert { … }</td><td>database.batchInsert(Employees) { … }</td></tr><tr><td>Employees.insertAndGenerateKey { … }</td><td>database.insertAndGenerateKey(Employees) { … }</td></tr><tr><td>Employees.delete { … }</td><td>database.delete(Employees) { … }</td></tr><tr><td>Employees.deleteAll()</td><td>database.deleteAll(Employees)</td></tr><tr><td>Employees.add(entity)</td><td>database.sequenceOf(Employees).add(entity)</td></tr><tr><td>Employees.all { … }</td><td>database.sequenceOf(Employees).all { … }</td></tr><tr><td>Employees.any { … }</td><td>database.sequenceOf(Employees).any { … }</td></tr><tr><td>Employees.none { … }</td><td>database.sequenceOf(Employees).none { … }</td></tr><tr><td>Employees.count { … }</td><td>database.sequenceOf(Employees).count { … }</td></tr><tr><td>Employees.sumBy { … }</td><td>database.sequenceOf(Employees).sumBy { … }</td></tr><tr><td>Employees.maxBy { … }</td><td>database.sequenceOf(Employees).maxBy { … }</td></tr><tr><td>Employees.minBy { … }</td><td>database.sequenceOf(Employees).minBy { … }</td></tr><tr><td>Employees.averageBy { … }</td><td>database.sequenceOf(Employees).averageBy { … }</td></tr></tbody></table><h2 id="ktorm-global"><a class="markdownIt-Anchor" href="#ktorm-global"></a> ktorm-global</h2><p>在未来的 Ktorm 3.0 版本中，这些废弃的 API 将会彻底移除。但是，它们其实也有一些可取之处，比如使用全局对象之后，某些 API 的设计可以变得更简洁。为了尽可能满足更多用户的需求，在 Ktorm 3.0 版本中，我们将增加一个 ktorm-global 模块。</p><p>届时，在 2.7 版本中废弃掉的 API 都会放到 ktorm-global 模块中重新实现。这个模块会作为 Ktorm 的扩展，提供基于全局对象设计的更简洁的 API，这样，在 Ktorm 的核心模块中就可以彻底移除全局变量相关的 API，如果要使用全局变量，额外添加 ktorm-global 的依赖即可。通过这种方式，我们希望能够找到一个微妙的平衡。敬请期待！</p><blockquote><p>ktorm-global 模块现已发布，请参见 <a href="./break-changes-in-ktorm-3.0.html">Ktorm 3.0 不兼容更新</a>。</p></blockquote><div id="support-footer-container"><div class="doc-support-footer">对文档内容有疑问？请在侧边栏尝试搜索或者在 GitHub <a href="https://github.com/kotlin-orm/ktorm/issues/new">提出 issue</a></div></div></article></div></div><div class="doc-footer">&copy; 2024 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script><script type="text/javascript" src="/vendors/docsearch@2.6.3/docsearch.min.js"></script><script type="text/javascript">docsearch({appId:"0DGANM0MZ3",apiKey:"071ea85fb6b0933d3f3d3925aa434e23",indexName:"ktorm",inputSelector:"#doc-search-input",algoliaOptions:{facetFilters:["lang:zh-cn","tags:doc"]},autocompleteOptions:{hint:!1,appendTo:"body"},debug:!1})</script><script>$(".kotlin .code .keyword").each(function(){var e=$(this);"where"!==e.text()&&"set"!==e.text()||e.removeClass("keyword")})</script></body></html>