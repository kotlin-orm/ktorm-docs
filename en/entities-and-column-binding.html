<!-- build time:Wed Jun 15 2022 23:14:09 GMT+0800 (CST) --><!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Ktorm | Entities and Column Binding</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch@2.6.3/docsearch.min.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"Entities and Column Binding",lang:"en",related_path:"zh-cn/entities-and-column-binding.html",path:"en/entities-and-column-binding.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"Overview",type:"link",path:"",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!0},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]},"navigation-zh-cn":{home:[{title:"快速开始",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"概述",type:"link",path:"zh-cn/"},{text:"快速开始",type:"link",path:"zh-cn/quick-start.html"},{text:"连接管理",type:"label"},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html"},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html"},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html"},{text:"查询",type:"link",path:"zh-cn/query.html"},{text:"联表",type:"link",path:"zh-cn/joining.html"},{text:"增删改",type:"link",path:"zh-cn/dml.html"},{text:"运算符",type:"link",path:"zh-cn/operators.html"},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html"},{text:"实体类 API",type:"label"},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html"},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html"},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html"},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html"},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html"},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html"},{text:"支持和反馈",type:"label"},{text:"API 文档",type:"support-link",path:"api-docs/index.html"},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new"},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html"}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc",algolia:{appId:"2W81KMSLOD",apiKey:"2a146a809de068d9b7a07ba3fb70b4e5",indexName:"ktorm",chunkSize:5e3,fields:["title","lang","date","updated","_content:truncate,0,5200","path","permalink"]}}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><span class="doc-navbar__logo"><a href="/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="lang-switcher"><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/entities-and-column-binding.html">简体中文</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><div class="dc-search-form doc-search-form"><input type="search" id="doc-search-input" class="dc-input dc-search-form__input doc-search-form__input" placeholder="Search documents" autofocus><button class="dc-btn dc-search-form__btn doc-search-form__btn" aria-label="Search"><i class="dc-icon dc-icon--search"></i></button></div></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/" target="_self"><span>Overview</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/quick-start.html" target="_self"><span>Quick Start</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>CONNECTION MANAGEMENT</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/connect-to-databases.html" target="_self"><span>Connect to Databases</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/transaction-management.html" target="_self"><span>Transaction Management</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/spring-support.html" target="_self"><span>Spring Support</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/schema-definition.html" target="_self"><span>Schema Definition</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/query.html" target="_self"><span>Query</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/joining.html" target="_self"><span>Joining</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/dml.html" target="_self"><span>Data Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/operators.html" target="_self"><span>Operators</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/dialects-and-native-sql.html" target="_self"><span>Dialects &amp; Native SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>ENTITY API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current"><a href="/en/entities-and-column-binding.html" target="_self"><span>Entities &amp; Column Binding</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-finding.html" target="_self"><span>Entity Query</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-sequence.html" target="_self"><span>Entity Sequence</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/sequence-aggregation.html" target="_self"><span>Sequence Aggregation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-dml.html" target="_self"><span>Entity Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/define-entities-as-any-kind-of-classes.html" target="_self"><span>Define Entities as Any Class</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SUPPORT &amp; FEEDBACK</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/api-docs/index.html" target="_self"><span>API Documents</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_self"><span>Issue Feedback</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/sponsor.html" target="_self"><span>Sponsor the Project</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher" data-reactroot=""><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/entities-and-column-binding.html">简体中文</a></span></span></div><div class="dc-page"><div class="dc-card"><div id="doc-search-results" class="doc-search-results"><div id="doc-search-stats"></div><div id="doc-search-hits"></div><div id="doc-search-pagination"></div></div><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/en/entities-and-column-binding.md"><i class="icon fa fa-github"></i> <span class="text">Edit Page</span></a><h1 id="Entities-amp-Column-Binding"><a href="#Entities-amp-Column-Binding" class="headerlink" title="Entities &amp; Column Binding"></a>Entities &amp; Column Binding</h1><p>We’ve learned Ktorm’s SQL DSL in former sections, but Ktorm is still far from being an ORM framework if it only provides the DSL. Now, we will introduce entities, and learn how to bind relational tables to them. That’s exactly the core of an ORM framework: object-relational mapping.</p><h2 id="Define-Entities"><a href="#Define-Entities" class="headerlink" title="Define Entities"></a>Define Entities</h2><p>We still take the two tables <code>t_department</code> and <code>t_employee</code> as an example, creating two entity classes with Ktorm to present our departments and employees:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Department</span> : <span class="type">Entity</span>&lt;<span class="type">Department</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">var</span> location: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Employee</span> : <span class="type">Entity</span>&lt;<span class="type">Employee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">var</span> job: String</span><br><span class="line">    <span class="keyword">var</span> manager: Employee?</span><br><span class="line">    <span class="keyword">var</span> hireDate: LocalDate</span><br><span class="line">    <span class="keyword">var</span> salary: <span class="built_in">Long</span></span><br><span class="line">    <span class="keyword">var</span> department: Department</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can see classes above both extends from <code>Entity&lt;E&gt;</code> interface, which injects some useful functions into entities. Their properties are defined by keyword <em>var</em> or <em>val</em>, you can mark the types as nullable or not depending on your business requirements. It may be counterintuitive that entities in Ktorm are not data classes, even not normal classes, but interfaces instead, that’s a design requirement of Ktorm. By defining entities as interfaces, Ktorm can implement some special features, you will see the significance later.</p><blockquote><p>Since Ktorm 2.5, it’s also supported to define entities as data classes or any other classes, see <a href="./define-entities-as-any-kind-of-classes.html">Define Entities as Any Kind of Classes</a>.</p></blockquote><p>As everyone knows, interfaces cannot be instantiated, now that all entities are interfaces, how can we create their instances? Ktorm provides an <code>Entity.create</code> function, which generates implementations for entity interfaces via JDK dynamic proxy, and creates their instances for us. To create a department object, we can do this:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> department = Entity.create&lt;Department&gt;()</span><br></pre></td></tr></table></figure><p>If you don’t like creating objects in that way, Ktorm also provides an abstract class <code>Entity.Factory</code>. We can add a companion object to our entity class extending from <code>Entity.Factory</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Department</span> : <span class="type">Entity</span>&lt;<span class="type">Department</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Entity.Factory&lt;Department&gt;()</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">var</span> location: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>Entity.Factory</code> class overloads the <code>invoke</code> operator, so we can use brackets to call the companion object as it’s a function. The code creating a department object:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> department = Department()</span><br></pre></td></tr></table></figure><p>That’s the charm of Kotlin, <code>Department</code> is an interface, but we can still create its instances, just like calling a constructor function. Moreover, we can also init some properties when creating entity objects:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> department = Department &#123;</span><br><span class="line">    name = <span class="string">"tech"</span></span><br><span class="line">    location = <span class="string">"Guangzhou"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Column-Binding"><a href="#Column-Binding" class="headerlink" title="Column Binding"></a>Column Binding</h2><p>The core feature of an ORM framework is to bind database tables to entities, bind tables’ columns to entities’ properties. Now let’s learn how to do that with Ktorm.</p><p>In former sections learning SQL DSL, we created two table objects, they are <code>Departments</code> and <code>Employees</code>. In these table objects, we defined columns by calling column definition functions such as <code>int</code>, <code>long</code>, <code>varchar</code>, etc. The return type of them is <code>Column&lt;C&gt;</code>, in which, <code>C</code> is the declaring column’s type.</p><p>It’s easy to bind a column to an entity’s property, we just need to chaining call the <code>bindTo</code> or <code>references</code> extension function on the <code>Column</code> instance. The code below modifies those two table objects and completes the O-R bindings:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Departments : Table&lt;Department&gt;(<span class="string">"t_department"</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">"id"</span>).primaryKey().bindTo &#123; it.id &#125;</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">"name"</span>).bindTo &#123; it.name &#125;</span><br><span class="line">    <span class="keyword">val</span> location = varchar(<span class="string">"location"</span>).bindTo &#123; it.location &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Employees : Table&lt;Employee&gt;(<span class="string">"t_employee"</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">"id"</span>).primaryKey().bindTo &#123; it.id &#125;</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">"name"</span>).bindTo &#123; it.name &#125;</span><br><span class="line">    <span class="keyword">val</span> job = varchar(<span class="string">"job"</span>).bindTo &#123; it.job &#125;</span><br><span class="line">    <span class="keyword">val</span> managerId = int(<span class="string">"manager_id"</span>).bindTo &#123; it.manager.id &#125;</span><br><span class="line">    <span class="keyword">val</span> hireDate = date(<span class="string">"hire_date"</span>).bindTo &#123; it.hireDate &#125;</span><br><span class="line">    <span class="keyword">val</span> salary = long(<span class="string">"salary"</span>).bindTo &#123; it.salary &#125;</span><br><span class="line">    <span class="keyword">val</span> departmentId = int(<span class="string">"department_id"</span>).references(Departments) &#123; it.department &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Naming Strategy: It’s highly recommended to name your entity classes by singular nouns, name table objects by plurals (eg. Employee/Employees, Department/Departments).</p></blockquote><p>Comparing the table objects with before, we can find two differences:</p><ol><li>The type parameter of <code>Table</code> is specified to the entity’s type now, that’s the way we bind table objects to entity classes. We set this parameter to <code>Nothing</code> before, that meant the table object was not bound to any entity class.</li><li>After calling the column definition functions, we chaining call <code>bindTo</code> or <code>references</code> functions to bind the current column to a property in the entity class. If we don’t do that, the column won’t be bound to any property.</li></ol><p>The significance of column bindings is that, while obtaining entities from databases, Ktorm will use our binding configurations to fill columns’ values to their corresponding properties, and while updating entities’ changes back to the databases (using <code>flushChanges</code> function), Ktorm will also use the configurations to find corresponding columns of entity properties.</p><p>Ktorm provides the following different binding types:</p><ol><li><strong>Simple Binding:</strong> Use <code>bindTo</code> function to bind a column to a simple property, eg. <code>c.bindTo { it.name }</code>.</li><li><strong>Nested Binding:</strong> Use <code>bindTo</code> function to bind a column to nested properties, for example <code>c.bindTo { it.manager.department.id }</code>. While obtaining entities from databases, the value of this column will be filled to <code>employee.manager.department.id</code>. With only a single level of properties, simple binding is a special case of nested binding.</li><li><strong>Reference Binding:</strong> Use <code>references</code> function to bind a column to another table, eg. <code>c.references(Departments) { it.department }</code>, equivalent to the foreign key in databases. Using reference binding, while obtaining entities from databases, Ktorm will auto left join all its reference tables, obtaining the referenced entity objects at the same time.</li></ol><p>Additionally, multiple bindings are supported since Ktorm version 2.6, so we can bind a column to multiple properties by calling the <code>bindTo</code> or <code>references</code> functions continuously. In this way, when an entity object is retrieved from the database, the value of this column will be filled to each property it binds.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Config</span> : <span class="type">Entity</span>&lt;<span class="type">Config</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> key: String</span><br><span class="line">    <span class="keyword">var</span> value1: String</span><br><span class="line">    <span class="keyword">var</span> value2: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Configs : Table&lt;Config&gt;(<span class="string">"t_config"</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> key = varchar(<span class="string">"key"</span>).primaryKey().bindTo &#123; it.key &#125;</span><br><span class="line">    <span class="keyword">val</span> value = varchar(<span class="string">"value"</span>).bindTo &#123; it.value1 &#125;.bindTo &#123; it.value2 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the example above, we bound the <code>value</code> column to both <code>value1</code> and <code>value2</code>, so the values of these two properties would be the same in an entity object obtained from the database.</p><blockquote><p>Please note that multiple bindings are only available for query operations. When we are inserting or updating an entity, the first binding will prevail, and other bindings will be ignored.</p></blockquote><h2 id="More-About-Entities"><a href="#More-About-Entities" class="headerlink" title="More About Entities"></a>More About Entities</h2><p>We know that Ktorm’s entity classes should be defined as interfaces extending from <code>Entity</code>, and we create entity objects via JDK dynamic proxy. If you have used dynamic proxy before, you may know proxy objects are created by <code>Proxy.newProxyInstance</code> method, providing an instance of <code>InvocationHandler</code>. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invocation handler. In Ktorm, <code>EntityImplementation</code> is the implementation of entities’ invocation handler. It’s marked as internal, so we can not use it outside Ktorm, but we can still learn its basic principles.</p><h3 id="Getting-and-Setting-Properties"><a href="#Getting-and-Setting-Properties" class="headerlink" title="Getting and Setting Properties"></a>Getting and Setting Properties</h3><p>When we define a property <code>var name: String</code> in Kotlin, we actually define two methods in Java byte code, they are <code>public String getName()</code> and <code>public void setName(String name)</code>. The invocations on these two methods will also be dispatched to <code>EntityImplementation</code>.</p><p>There is a <code>values</code> property in <code>EntityImplementation</code>, its type is <code>LinkedHashMap&lt;String, Any?&gt;</code>, and it holds all property values of the entity object. When we use <code>e.name</code> to obtain the property’s value, <code>EntityImplementation</code> receives an invocation on <code>getName()</code> method, then it will get the value from the <code>values</code> using the key “name”. When we use <code>e.name = &quot;foo&quot;</code> to modify the property, <code>EntityImplementation</code> also receives an invocation on <code>setName()</code> method, then it will put the given value to <code>values</code> and save some additional information to track the entity’s status changes.</p><p>That is to say, behind every entity object, there is a value table that holds all the values of its properties. Any operation of getting or setting a property is actually operating the underlying value table. However, what if the value doesn’t exist while we are getting a property? It’s possible because any new-created entity object has an empty underlying value table. Ktorm defines a set of rules for this situation:</p><ul><li>If the value doesn’t exist and the property’s type is marked nullable, eg <code>var name: String?</code>, then we’ll return null.</li><li>If the value doesn’t exist and the property’s type is not nullable, eg <code>var name: String</code>, then we can not return null anymore, because the null value here can cause an unexpected null pointer exception, we’ll return the type’s default value instead.</li></ul><p>The default values of different types are well-defined:</p><ul><li>For <code>Boolean</code> type, the default value is false.</li><li>For <code>Char</code> type, the default value is \u0000.</li><li>For number types (such as <code>Int</code>, <code>Long</code>, <code>Double</code>, etc), the default value is zero.</li><li>For <code>String</code> type, the default value is an empty string.</li><li>For entity types, the default value is a new-created entity object which is empty.</li><li>For enum types, the default value is the first value of the enum, whose ordinal is 0.</li><li>For array types, the default value is a new-created empty array.</li><li>For collection types (such as <code>Set</code>, <code>List</code>, <code>Map</code>, etc), the default value is a new created mutable collection of the concrete type.</li><li>For any other types, the default value is an instance created by its no-args constructor. If the constructor doesn’t exist, an exception is thrown.</li></ul><p>Moreover, there is a cache mechanism for default values in <code>EntityImplementation</code>, that ensures a property always returns the same default value instance even if it’s called twice or more. This can avoid some counterintuitive bugs.</p><h3 id="Non-abstract-Members"><a href="#Non-abstract-Members" class="headerlink" title="Non-abstract Members"></a>Non-abstract Members</h3><p>If we are using domain driven design, then entities are not only data containers that hold property values, there are also some behaviors, so we need to add some business functions to our entities. Fortunately, Kotlin allows us to define non-abstract functions in interfaces, that’s why we don’t lose anything even if Ktorm’s entity classes are all interfaces. Here is an example:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> : <span class="type">Entity</span>&lt;<span class="type">Foo</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Entity.Factory&lt;Foo&gt;()</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then if we call <code>Foo().printName()</code>, the value of the property <code>name</code> will be printed.</p><blockquote><p>That looks natural, but the underlying implementation is not that simple. We know that Ktorm creates entity objects via JDK dynamic proxy, and the invocation on <code>printName</code> function will also be delegated into <code>EntityImplementation</code>. As the calling function is not abstract, when <code>EntityImplementation</code> receives the invocation, we will find out the default implementation by some tricks and call it. That’s transparent to us, just like directly calling the function. If you are interested in the underlying story, you can refer to our <a href="https://github.com/kotlin-orm/ktorm/blob/master/ktorm-core/src/main/kotlin/org/ktorm/entity/DefaultMethodHandler.kt" target="_blank" rel="noopener">source code</a>.</p></blockquote><p>Besides of non-abstract functions, Kotlin also allows us to define properties with custom getters or setters in interfaces. For example, in the following code, if we call the <code>upperName</code> property, then the value of the <code>name</code> property will be returned in upper case. The principle is the same as we discussed above.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Foo</span> : <span class="type">Entity</span>&lt;<span class="type">Foo</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="keyword">val</span> upperName <span class="keyword">get</span>() = name.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h3><p>The <code>Entity</code> interface extends from <code>java.io.Serializable</code>, so all entity objects are serializable by default. We can save them to our disks, or transfer them between systems through networks.</p><p>Note that Ktorm only saves entities’ property values when serialization, any other data that used to track entity status are lost (marked as transient). So we can not obtain an entity object from one system, then flush its changes into the database in another system.</p><blockquote><p>Java uses <code>ObjectOutputStream</code> to serialize objects, and uses <code>ObjectInputStream</code> to deserialize them, you can refer to their documentation for more details.</p></blockquote><p>Besides of JDK serialization, the ktorm-jackson module also supports serializing entities in JSON format. This module provides an extension for Jackson, the famous JSON framework in Java word. It supports serializing entity objects into JSON format and parsing JSONs as entity objects. We just need to register the <code>KtormModule</code> into an <code>ObjectMapper</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> objectMapper = ObjectMapper()</span><br><span class="line">objectMapper.registerModule(KtormModule())</span><br></pre></td></tr></table></figure><p>Or use <code>findAndRegisterModules</code> method to auto detect and register it:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> objectMapper = ObjectMapper()</span><br><span class="line">objectMapper.findAndRegisterModules()</span><br></pre></td></tr></table></figure><p>Now, we can use this <code>objectMapper</code> to do the serialization and deserialization for entities, please refer to Jackson’s documentation for more details.</p><p>That’s the two serialization formats supported by Ktorm, if you need more serialization formats, please raise your issue, or you can do it by yourself and send a pull request to me. Welcome for your contributions!</p><div id="support-footer-container"><div class="doc-support-footer" data-reactroot=""><div class="doc-footer-link">Prev Article: <a href="/en/dialects-and-native-sql.html">Dialects &amp; Native SQL</a></div><div class="doc-footer-link">Next Article: <a href="/en/entity-finding.html">Entity Query</a></div>Any questions about the document? Try searching again on the left menu or <a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank" rel="noopener">Raise an issue on Github</a></div></div></article></div></div><div class="doc-footer">&copy; 2022 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm" target="_blank" rel="noopener">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script><script type="text/javascript" src="/vendors/docsearch@2.6.3/docsearch.min.js"></script><script type="text/javascript">docsearch({appId:"0DGANM0MZ3",apiKey:"071ea85fb6b0933d3f3d3925aa434e23",indexName:"ktorm",inputSelector:"#doc-search-input",algoliaOptions:{facetFilters:["lang:en","tags:doc"]},autocompleteOptions:{hint:!1,appendTo:"body"},debug:!1})</script><script>!function(){$(".kotlin .code .keyword").each(function(){var e=$(this);("where"===e.text()||"set"===e.text())&&e.removeClass("keyword")})}()</script></body></html><!-- rebuild by neat -->