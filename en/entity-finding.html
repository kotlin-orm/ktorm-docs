<!-- build time:Sun Jan 01 2023 08:36:38 GMT+0800 (CST) --><!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Ktorm | Entity Query</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch@2.6.3/docsearch.min.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"Entity Query",lang:"en",related_path:"zh-cn/entity-finding.html",path:"en/entity-finding.html"},data:{"navigation-zh-cn":{home:[{title:"快速开始",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"概述",type:"link",path:"zh-cn/"},{text:"快速开始",type:"link",path:"zh-cn/quick-start.html"},{text:"连接管理",type:"label"},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html"},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html"},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html"},{text:"查询",type:"link",path:"zh-cn/query.html"},{text:"联表",type:"link",path:"zh-cn/joining.html"},{text:"增删改",type:"link",path:"zh-cn/dml.html"},{text:"运算符",type:"link",path:"zh-cn/operators.html"},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html"},{text:"实体类 API",type:"label"},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html"},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html"},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html"},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html"},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html"},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html"},{text:"支持和反馈",type:"label"},{text:"API 文档",type:"support-link",path:"api-docs/index.html"},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new"},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html"}]},"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"Overview",type:"link",path:"",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!0},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc",algolia:{appId:"2W81KMSLOD",apiKey:"2a146a809de068d9b7a07ba3fb70b4e5",indexName:"ktorm",chunkSize:5e3,fields:["title","lang","date","updated","_content:truncate,0,5200","path","permalink"]}}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><span class="doc-navbar__logo"><a href="/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="lang-switcher"><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/entity-finding.html">简体中文</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><div class="dc-search-form doc-search-form"><input type="search" id="doc-search-input" class="dc-input dc-search-form__input doc-search-form__input" placeholder="Search documents" autofocus><button class="dc-btn dc-search-form__btn doc-search-form__btn" aria-label="Search"><i class="dc-icon dc-icon--search"></i></button></div></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/" target="_self"><span>Overview</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/quick-start.html" target="_self"><span>Quick Start</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>CONNECTION MANAGEMENT</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/connect-to-databases.html" target="_self"><span>Connect to Databases</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/transaction-management.html" target="_self"><span>Transaction Management</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/spring-support.html" target="_self"><span>Spring Support</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/schema-definition.html" target="_self"><span>Schema Definition</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/query.html" target="_self"><span>Query</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/joining.html" target="_self"><span>Joining</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/dml.html" target="_self"><span>Data Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/operators.html" target="_self"><span>Operators</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/dialects-and-native-sql.html" target="_self"><span>Dialects &amp; Native SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>ENTITY API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entities-and-column-binding.html" target="_self"><span>Entities &amp; Column Binding</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current"><a href="/en/entity-finding.html" target="_self"><span>Entity Query</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-sequence.html" target="_self"><span>Entity Sequence</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/sequence-aggregation.html" target="_self"><span>Sequence Aggregation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-dml.html" target="_self"><span>Entity Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/define-entities-as-any-kind-of-classes.html" target="_self"><span>Define Entities as Any Class</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SUPPORT &amp; FEEDBACK</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/api-docs/index.html" target="_self"><span>API Documents</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_self"><span>Issue Feedback</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/sponsor.html" target="_self"><span>Sponsor the Project</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher" data-reactroot=""><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/entity-finding.html">简体中文</a></span></span></div><div class="dc-page"><div class="dc-card"><div id="doc-search-results" class="doc-search-results"><div id="doc-search-stats"></div><div id="doc-search-hits"></div><div id="doc-search-pagination"></div></div><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/en/entity-finding.md"><i class="icon fa fa-github"></i> <span class="text">Edit Page</span></a><h1 id="Entity-Query"><a href="#Entity-Query" class="headerlink" title="Entity Query"></a>Entity Query</h1><p>Ktorm provides a set of APIs named <em>Entity Sequence</em>, which can be used to obtain entity objects from databases. As the name implies, its style and use pattern are highly similar to the sequence APIs in Kotlin standard lib, as it provides many extension functions with the same names, such as <code>filter</code>, <code>map</code>, <code>reduce</code>, etc.</p><h2 id="Get-Entities-by-Sequences"><a href="#Get-Entities-by-Sequences" class="headerlink" title="Get Entities by Sequences"></a>Get Entities by Sequences</h2><p>To use sequence APIs, we need to create sequence objects first. In general, we’d like to define some extension properties for <code>Database</code>. These properties return new created sequence objects via <code>sequenceOf</code> and they can help us improve the readability of the code:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Database.departments <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Departments)</span><br><span class="line"><span class="keyword">val</span> Database.employees <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Employees)</span><br></pre></td></tr></table></figure><p>The following code uses the <code>find</code> function to obtain an employee by its name:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123; it.name eq <span class="string">"vince"</span> &#125;</span><br></pre></td></tr></table></figure><p>This is natural, just like finding from a collection via Kotlin’s built-in extension functions, the only difference is the <code>==</code> in the lambda is replace by the <code>eq</code> function.</p><p>The <code>find</code> function accepts a closure typed of <code>(T) -&gt; ColumnDeclaring&lt;Boolean&gt;</code>, executes a query with the filter condition returned by the closure, then returns the first entity object obtained from the result set. The closure function itself as the parameter also accepts a parameter typed of <code>T</code>, which is the current table object, so we can use <code>it</code> to access the table in the closure.</p><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.id <span class="keyword">as</span> t_employee_id, t_employee.name <span class="keyword">as</span> t_employee_name, t_employee.job <span class="keyword">as</span> t_employee_job, t_employee.manager_id <span class="keyword">as</span> t_employee_manager_id, t_employee.hire_date <span class="keyword">as</span> t_employee_hire_date, t_employee.salary <span class="keyword">as</span> t_employee_salary, t_employee.department_id <span class="keyword">as</span> t_employee_department_id, _ref0.id <span class="keyword">as</span> _ref0_id, _ref0.name <span class="keyword">as</span> _ref0_name, _ref0.location <span class="keyword">as</span> _ref0_location </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id = _ref0.id </span><br><span class="line"><span class="keyword">where</span> t_employee.id = ?</span><br></pre></td></tr></table></figure><blockquote><p>The generated SQL contains a very long field list, that’s necessary, Ktorm tries its best to avoid using <code>select *</code>. But for the sake of presentation, in later documents, we will still replace those field lists with <code>select *</code>.</p></blockquote><p>Reading the generated SQL, we can find that Ktorm auto left joins <code>t_employee</code>‘s reference table <code>t_department</code> using a foreign key. That’s because we bind the <code>departmentId</code> column to <code>Departments</code> table by a reference binding in the table object. By using the reference binding, when we obtain employees via sequence APIs, Ktorm will auto left join the referenced table, obtaining the departments at the same time, and filling them into property <code>Employee.department</code>.</p><blockquote><p>Note: please avoid circular references while using reference bindings. For instance, now that <code>Employees</code> references <code>Departments</code>, then <code>Departments</code> cannot reference <code>Employees</code> directly or indirectly, otherwise a stack overflow will occur when Ktorm tries to left join <code>Departments</code>.</p></blockquote><p>Now that referenced tables are auto left joined, we can also use their columns in our filter conditions. The code below uses <code>Column.referenceTable</code> to access <code>departmentId</code>‘s referenced table and obtains an employee who works at Guangzhou:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123;</span><br><span class="line">    <span class="keyword">val</span> dept = it.departmentId.referenceTable <span class="keyword">as</span> Departments</span><br><span class="line">    dept.location eq <span class="string">"Guangzhou"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To make it more elegant, we can add a get property to <code>Employees</code> table. The following code is completely equivalent to the above’s, but it reads more natural:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Employees</span></span>(alias: String?) : Table&lt;Employee&gt;(<span class="string">"t_employee"</span>, alias) &#123;</span><br><span class="line">    <span class="comment">// Omit columns definitions here...</span></span><br><span class="line">    <span class="keyword">val</span> department <span class="keyword">get</span>() = departmentId.referenceTable <span class="keyword">as</span> Departments</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123; it.department.location eq <span class="string">"Guangzhou"</span> &#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id = _ref0.id </span><br><span class="line"><span class="keyword">where</span> _ref0.location = ?</span><br></pre></td></tr></table></figure><blockquote><p>Note: here we get the referenced table object via <code>it.departmentId.referenceTable</code> and cast it as <code>Departments</code>, which requires us to define tables as classes instead of singleton objects and to override the <code>aliased</code> function. More details can be found in the documentation of <a href="./joining.html#Self-Joining-amp-Table-Aliases">table aliases</a>.</p></blockquote><p>Besides the <code>find</code> function, <em>Entity Sequence</em> also provides many convenient functions for us. For example, using <code>filter</code> to find elements that matches the given condition, using <code>groupingBy</code> to group elements and do some aggregation, etc.. Comparing with SQL DSL, sequence APIs are more functional, and can be used just like operating a collection in memory, so we recommend it as your first choice. For more documents, see <a href="./entity-sequence.html">Entity Sequence</a> and <a href="./sequence-aggregation.html">Sequence Aggregation</a>.</p><h2 id="Get-Entities-by-Query-DSL"><a href="#Get-Entities-by-Query-DSL" class="headerlink" title="Get Entities by Query DSL"></a>Get Entities by Query DSL</h2><p>Sequence APIs will auto left join reference tables, that may be unnecessary in some cases. If you want more fine-grained control over the queries, you can use the query DSL introduced in the former sections. Ktorm provides a way to create entity objects from query DSL.</p><p>The example below uses <code>createEntity</code> function to obtain a list of entities from a query:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select()</span><br><span class="line">    .orderBy(Employees.id.asc())</span><br><span class="line">    .map &#123; row -&gt; Employees.createEntity(row) &#125;</span><br><span class="line"></span><br><span class="line">employees.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure><p>Here, we use the <code>map</code> function to iterate the query and create an entity object from the result set via <code>createEntity</code> for each row. <code>createEntity</code> is a function of <code>Table</code> class, it will create an entity object from the result set, using the binding configurations of the table, filling columns’ values into corresponding entities’ properties. And if there are any reference bindings to other tables, it will also create the referenced entity objects recursively.</p><p>However, the selected columns in query DSL are customizable, and there may be no columns from referenced tables. In this case, the function provides a parameter named <code>withReferences</code>, which is defaultly <code>true</code>. But if we set it to <code>false</code>, it will not obtain referenced entities’ data anymore, it will treat all reference bindings as nested bindings to the referenced entities’ primary keys. For example the binding <code>c.references(Departments) { it.department }</code>, it is equivalent to <code>c.bindTo { it.department.id }</code> for it, that avoids some unnecessary object creations.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employees.createEntity(row, withReferences = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>Get back the above example that we didn’t join any tables, so no matter we set the parameter to <code>true</code> or <code>false</code>, Ktorm will generate a simple SQL <code>select * from t_employee order by t_employee.id</code> and print the same results:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Employee&#123;id=1, name=vince, job=engineer, hireDate=2018-01-01, salary=100, department=Department&#123;id=1&#125;&#125;</span><br><span class="line">Employee&#123;id=2, name=marry, job=trainee, manager=Employee&#123;id=1&#125;, hireDate=2019-01-01, salary=50, department=Department&#123;id=1&#125;&#125;</span><br><span class="line">Employee&#123;id=3, name=tom, job=director, hireDate=2018-01-01, salary=200, department=Department&#123;id=2&#125;&#125;</span><br><span class="line">Employee&#123;id=4, name=penny, job=assistant, manager=Employee&#123;id=3&#125;, hireDate=2019-01-01, salary=100, department=Department&#123;id=2&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="joinReferencesAndSelect"><a href="#joinReferencesAndSelect" class="headerlink" title="joinReferencesAndSelect"></a>joinReferencesAndSelect</h2><p><code>joinReferencesAndSelect</code> is an extension function of <code>QuerySource</code>, it returns a new-created <code>Query</code> object, left joining all the reference tables recursively, and selecting all columns of them. Not only we can use the returned query to obtain all entity objects, but also we can call any other extension functions of <code>Query</code> to modify it. Actually, sequence APIs are based on this function to implement the auto joining of reference tables.</p><p>The example below queries all the employees along with their departments, sorting them by their IDs ascending:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .joinReferencesAndSelect()</span><br><span class="line">    .orderBy(Employees.id.asc())</span><br><span class="line">    .map &#123; row -&gt; Employees.createEntity(row) &#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id = _ref0.id </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t_employee.id</span><br></pre></td></tr></table></figure><p>We can see in the SQL that the query above is equivalent to calling the <code>leftJoin</code> function manually, the following query is completely equal to the example above. Using <code>joinReferencesAndSelect</code> can help us to reduce some boilerplate code.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> emp = Employees</span><br><span class="line"><span class="keyword">val</span> dept = emp.departmentId.referenceTable <span class="keyword">as</span> Departments</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> employees = database</span><br><span class="line">    .from(emp)</span><br><span class="line">    .leftJoin(dept, on = emp.departmentId eq dept.id)</span><br><span class="line">    .select(emp.columns + dept.columns)</span><br><span class="line">    .orderBy(emp.id.asc())</span><br><span class="line">    .map &#123; row -&gt; emp.createEntity(row) &#125;</span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer" data-reactroot=""><div class="doc-footer-link">Prev Article: <a href="/en/entities-and-column-binding.html">Entities &amp; Column Binding</a></div><div class="doc-footer-link">Next Article: <a href="/en/entity-sequence.html">Entity Sequence</a></div>Any questions about the document? Try searching again on the left menu or <a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank" rel="noopener">Raise an issue on Github</a></div></div></article></div></div><div class="doc-footer">&copy; 2023 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm" target="_blank" rel="noopener">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script><script type="text/javascript" src="/vendors/docsearch@2.6.3/docsearch.min.js"></script><script type="text/javascript">docsearch({appId:"0DGANM0MZ3",apiKey:"071ea85fb6b0933d3f3d3925aa434e23",indexName:"ktorm",inputSelector:"#doc-search-input",algoliaOptions:{facetFilters:["lang:en","tags:doc"]},autocompleteOptions:{hint:!1,appendTo:"body"},debug:!1})</script><script>!function(){$(".kotlin .code .keyword").each(function(){var e=$(this);("where"===e.text()||"set"===e.text())&&e.removeClass("keyword")})}()</script></body></html><!-- rebuild by neat -->