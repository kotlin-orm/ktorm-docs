<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Ktorm | Quick Start</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch-css@3.6.2/style.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"Quick Start",lang:"en",related_path:"zh-cn/quick-start.html",path:"en/quick-start.html"},data:{"navigation-zh-cn":{home:[{title:"快速上手",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"开始",type:"label"},{text:"简介",type:"link",path:"zh-cn/"},{text:"快速上手",type:"link",path:"zh-cn/quick-start.html"},{text:"连接管理",type:"label"},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html"},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html"},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html"},{text:"查询",type:"link",path:"zh-cn/query.html"},{text:"联表",type:"link",path:"zh-cn/joining.html"},{text:"增删改",type:"link",path:"zh-cn/dml.html"},{text:"运算符",type:"link",path:"zh-cn/operators.html"},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html"},{text:"实体类 API",type:"label"},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html"},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html"},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html"},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html"},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html"},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html"},{text:"支持和反馈",type:"label"},{text:"API 文档",type:"support-link",path:"api-docs/index.html",target:"_blank"},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank"},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html"}]},"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"GETTING STARTED",type:"label"},{text:"Overview",type:"link",path:"/"},{text:"Quick Start",type:"link",path:"en/quick-start.html"},{text:"CONNECTION MANAGEMENT",type:"label"},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html"},{text:"Transaction Management",type:"link",path:"en/transaction-management.html"},{text:"Spring Support",type:"link",path:"en/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"Schema Definition",type:"link",path:"en/schema-definition.html"},{text:"Query",type:"link",path:"en/query.html"},{text:"Joining",type:"link",path:"en/joining.html"},{text:"Data Manipulation",type:"link",path:"en/dml.html"},{text:"Operators",type:"link",path:"en/operators.html"},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html"},{text:"ENTITY API",type:"label"},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html"},{text:"Entity Query",type:"link",path:"en/entity-finding.html"},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html"},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html"},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html"},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html"},{text:"SUPPORT & FEEDBACK",type:"label"},{text:"API Documents",type:"support-link",path:"api-docs/index.html",target:"_blank"},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank"},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html"}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc"}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation"><nav class="doc-navbar"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="doc-navbar__logo"><a href="/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close"></i><span class="lang-switcher"><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/quick-start.html">简体中文</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search documents</span></span><span class="DocSearch-Button-Keys"></span></button></div><ul class="doc-sidebar-list"></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher"><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/quick-start.html">简体中文</a></span></span></div><div class="dc-page"><div class="dc-card"><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/en/quick-start.md"><i class="icon fa fa-github"></i> <span class="text">Edit Page</span></a><h1 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h1><p>Ktorm was deployed to maven central, so you just need to add a dependency to your <code>pom.xml</code> file if you are using maven:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ktorm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ktorm-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;ktorm.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Or Gradle:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">&quot;org.ktorm:ktorm-core:$&#123;ktorm.version&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>Firstly, create Kotlin objects to <a href="./schema-definition.html">describe your table schemas</a>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Departments : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">&quot;t_department&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">&quot;id&quot;</span>).primaryKey()</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> location = varchar(<span class="string">&quot;location&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Employees : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">&quot;t_employee&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">&quot;id&quot;</span>).primaryKey()</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = varchar(<span class="string">&quot;job&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> managerId = int(<span class="string">&quot;manager_id&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> hireDate = date(<span class="string">&quot;hire_date&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> salary = long(<span class="string">&quot;salary&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> departmentId = int(<span class="string">&quot;department_id&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then, connect to your database and write a simple query:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> database = Database.connect(<span class="string">&quot;jdbc:mysql://localhost:3306/ktorm&quot;</span>, user = <span class="string">&quot;root&quot;</span>, password = <span class="string">&quot;***&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (row <span class="keyword">in</span> database.from(Employees).select()) &#123;</span><br><span class="line">        println(row[Employees.name])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now you can run this program, Ktorm will generate a SQL <code>select * from t_employee</code>, selecting all employees in the table and printing their names. You can use the for-each loop here because the query object returned by the <code>select</code> function overloads the iteration operator.</p><h2 id="sql-dsl"><a class="markdownIt-Anchor" href="#sql-dsl"></a> SQL DSL</h2><p>Let’s add some filter conditions to the query:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.name)</span><br><span class="line">    .<span class="keyword">where</span> &#123; (Employees.departmentId eq <span class="number">1</span>) and (Employees.name like <span class="string">&quot;%vince%&quot;</span>) &#125;</span><br><span class="line">    .forEach &#123; row -&gt; </span><br><span class="line">        println(row[Employees.name])</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.name <span class="keyword">as</span> t_employee_name </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">where</span> (t_employee.department_id <span class="operator">=</span> ?) <span class="keyword">and</span> (t_employee.name <span class="keyword">like</span> ?) </span><br></pre></td></tr></table></figure><p>That’s the magic of Kotlin, writing a query with Ktorm is easy and natural, the generated SQL is exactly corresponding to the origin Kotlin code. And moreover, it’s strong-typed, the compiler will check your code before it runs, and you will be benefited from the IDE’s intelligent sense and code completion.</p><p>Dynamic query that will apply different filter conditions in different situations:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.name)</span><br><span class="line">    .whereWithConditions &#123;</span><br><span class="line">        <span class="keyword">if</span> (someCondition) &#123;</span><br><span class="line">            it += Employees.managerId.isNull()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (otherCondition) &#123;</span><br><span class="line">            it += Employees.departmentId eq <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Aggregation:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = Employees.aliased(<span class="string">&quot;t&quot;</span>)</span><br><span class="line">database</span><br><span class="line">    .from(t)</span><br><span class="line">    .select(t.departmentId, avg(t.salary))</span><br><span class="line">    .groupBy(t.departmentId)</span><br><span class="line">    .having &#123; avg(t.salary) gt <span class="number">100.0</span> &#125;</span><br><span class="line">    .forEach &#123; row -&gt; </span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;row.getInt(<span class="number">1</span>)&#125;</span>:<span class="subst">$&#123;row.getDouble(<span class="number">2</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Union:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.id)</span><br><span class="line">    .unionAll(</span><br><span class="line">        database.from(Departments).select(Departments.id)</span><br><span class="line">    )</span><br><span class="line">    .unionAll(</span><br><span class="line">        database.from(Departments).select(Departments.id)</span><br><span class="line">    )</span><br><span class="line">    .orderBy(Employees.id.desc())</span><br></pre></td></tr></table></figure><p>Joining:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Names</span>(<span class="keyword">val</span> name: String?, <span class="keyword">val</span> managerName: String?, <span class="keyword">val</span> departmentName: String?)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> emp = Employees.aliased(<span class="string">&quot;emp&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> mgr = Employees.aliased(<span class="string">&quot;mgr&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> dept = Departments.aliased(<span class="string">&quot;dept&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> results = database</span><br><span class="line">    .from(emp)</span><br><span class="line">    .leftJoin(dept, on = emp.departmentId eq dept.id)</span><br><span class="line">    .leftJoin(mgr, on = emp.managerId eq mgr.id)</span><br><span class="line">    .select(emp.name, mgr.name, dept.name)</span><br><span class="line">    .orderBy(emp.id.asc())</span><br><span class="line">    .map &#123; row -&gt; </span><br><span class="line">        Names(</span><br><span class="line">            name = row[emp.name],</span><br><span class="line">            managerName = row[mgr.name],</span><br><span class="line">            departmentName = row[dept.name]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Insert:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">database.insert(Employees) &#123;</span><br><span class="line">    <span class="keyword">set</span>(it.name, <span class="string">&quot;jerry&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.job, <span class="string">&quot;trainee&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.managerId, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.hireDate, LocalDate.now())</span><br><span class="line">    <span class="keyword">set</span>(it.salary, <span class="number">50</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.departmentId, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Update:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">database.update(Employees) &#123;</span><br><span class="line">    <span class="keyword">set</span>(it.job, <span class="string">&quot;engineer&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.managerId, <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">set</span>(it.salary, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">where</span> &#123;</span><br><span class="line">        it.id eq <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Delete:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">database.delete(Employees) &#123; it.id eq <span class="number">4</span> &#125;</span><br></pre></td></tr></table></figure><p>Refer to <a href="./query.html">detailed documentation</a> for more usages about SQL DSL.</p><h2 id="entities-column-binding"><a class="markdownIt-Anchor" href="#entities-column-binding"></a> Entities &amp; Column Binding</h2><p>In addition to SQL DSL, entity objects are also supported just like other ORM frameworks do. We need to define entity classes firstly and bind table objects to them. In Ktorm, entity classes are defined as interfaces extending from <code>Entity&lt;E&gt;</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Department</span> : <span class="type">Entity</span>&lt;<span class="type">Department</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Entity.Factory&lt;Department&gt;()</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">var</span> location: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Employee</span> : <span class="type">Entity</span>&lt;<span class="type">Employee</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Entity.Factory&lt;Employee&gt;()</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: String</span><br><span class="line">    <span class="keyword">var</span> job: String</span><br><span class="line">    <span class="keyword">var</span> manager: Employee?</span><br><span class="line">    <span class="keyword">var</span> hireDate: LocalDate</span><br><span class="line">    <span class="keyword">var</span> salary: <span class="built_in">Long</span></span><br><span class="line">    <span class="keyword">var</span> department: Department</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Modify the table objects above, binding database columns to entity properties:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Departments : Table&lt;Department&gt;(<span class="string">&quot;t_department&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">&quot;id&quot;</span>).primaryKey().bindTo &#123; it.id &#125;</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>).bindTo &#123; it.name &#125;</span><br><span class="line">    <span class="keyword">val</span> location = varchar(<span class="string">&quot;location&quot;</span>).bindTo &#123; it.location &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Employees : Table&lt;Employee&gt;(<span class="string">&quot;t_employee&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">&quot;id&quot;</span>).primaryKey().bindTo &#123; it.id &#125;</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>).bindTo &#123; it.name &#125;</span><br><span class="line">    <span class="keyword">val</span> job = varchar(<span class="string">&quot;job&quot;</span>).bindTo &#123; it.job &#125;</span><br><span class="line">    <span class="keyword">val</span> managerId = int(<span class="string">&quot;manager_id&quot;</span>).bindTo &#123; it.manager.id &#125;</span><br><span class="line">    <span class="keyword">val</span> hireDate = date(<span class="string">&quot;hire_date&quot;</span>).bindTo &#123; it.hireDate &#125;</span><br><span class="line">    <span class="keyword">val</span> salary = long(<span class="string">&quot;salary&quot;</span>).bindTo &#123; it.salary &#125;</span><br><span class="line">    <span class="keyword">val</span> departmentId = int(<span class="string">&quot;department_id&quot;</span>).references(Departments) &#123; it.department &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Naming Strategy: It’s highly recommended to name your entity classes by singular nouns, name table objects by plurals (eg. Employee/Employees, Department/Departments).</p></blockquote><p>Now that column bindings are configured, so we can use <a href="#Entity-Sequence-APIs">sequence APIs</a> to perform many operations on entities. Let’s add two extension properties for <code>Database</code> first. These properties return new created sequence objects via <code>sequenceOf</code> and they can help us improve the readability of the code:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Database.departments <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Departments)</span><br><span class="line"><span class="keyword">val</span> Database.employees <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Employees)</span><br></pre></td></tr></table></figure><p>The following code uses the <code>find</code> function to obtain an employee by its name:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123; it.name eq <span class="string">&quot;vince&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>We can also filter the sequence by the function <code>filter</code>. For example, obtaining all the employees whose names are vince:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.filter &#123; it.name eq <span class="string">&quot;vince&quot;</span> &#125;.toList()</span><br></pre></td></tr></table></figure><p>The <code>find</code> and <code>filter</code> functions both accept a lambda expression, generating a select sql with the condition returned by the lambda. The generated SQL auto left joins the referenced table <code>t_department</code>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> _ref0.id </span><br><span class="line"><span class="keyword">where</span> t_employee.name <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>Save entities to database:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = Employee &#123;</span><br><span class="line">    name = <span class="string">&quot;jerry&quot;</span></span><br><span class="line">    job = <span class="string">&quot;trainee&quot;</span></span><br><span class="line">    hireDate = LocalDate.now()</span><br><span class="line">    salary = <span class="number">50</span></span><br><span class="line">    department = database.departments.find &#123; it.name eq <span class="string">&quot;tech&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">database.employees.add(employee)</span><br></pre></td></tr></table></figure><p>Flush property changes in memory to database:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123; it.id eq <span class="number">2</span> &#125; ?: <span class="keyword">return</span></span><br><span class="line">employee.job = <span class="string">&quot;engineer&quot;</span></span><br><span class="line">employee.salary = <span class="number">100</span></span><br><span class="line">employee.flushChanges()</span><br></pre></td></tr></table></figure><p>Delete an entity from database:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employee = database.employees.find &#123; it.id eq <span class="number">2</span> &#125; ?: <span class="keyword">return</span></span><br><span class="line">employee.delete()</span><br></pre></td></tr></table></figure><p>Detailed usages of entity APIs can be found in the documentation of <a href="./entities-and-column-binding.html">column binding</a> and <a href="./entity-finding.html">entity query</a>.</p><h2 id="entity-sequence-apis"><a class="markdownIt-Anchor" href="#entity-sequence-apis"></a> Entity Sequence APIs</h2><p>Ktorm provides a set of APIs named <em>Entity Sequence</em>, which can be used to obtain entity objects from databases. As the name implies, its style and use pattern are highly similar to the sequence APIs in Kotlin standard lib, as it provides many extension functions with the same names, such as <code>filter</code>, <code>map</code>, <code>reduce</code>, etc.</p><p>Most of the entity sequence APIs are provided as extension functions, which can be divided into two groups, they are intermediate operations and terminal operations.</p><h3 id="intermediate-operations"><a class="markdownIt-Anchor" href="#intermediate-operations"></a> Intermediate Operations</h3><p>These functions don’t execute the internal queries but return new-created sequence objects applying some modifications. For example, the <code>filter</code> function creates a new sequence object with the filter condition given by its parameter. The following code obtains all the employees in department 1 by using <code>filter</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.filter &#123; it.departmentId eq <span class="number">1</span> &#125;.toList()</span><br></pre></td></tr></table></figure><p>We can see that the usage is almost the same as <code>kotlin.sequences</code>, the only difference is the <code>==</code> in the lambda is replaced by the <code>eq</code> function. The <code>filter</code> function can also be called continuously, as all the filter conditions are combined with the <code>and</code> operator.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .filter &#123; it.managerId.isNotNull() &#125;</span><br><span class="line">    .toList()</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> _ref0.id </span><br><span class="line"><span class="keyword">where</span> (t_employee.department_id <span class="operator">=</span> ?) <span class="keyword">and</span> (t_employee.manager_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><p>Use <code>sortedBy</code> or <code>soretdByDescending</code> to sort entities in a sequence:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.sortedBy &#123; it.salary &#125;.toList()</span><br></pre></td></tr></table></figure><p>Use <code>drop</code> and <code>take</code> for pagination:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.drop(<span class="number">1</span>).take(<span class="number">1</span>).toList()</span><br></pre></td></tr></table></figure><h3 id="terminal-operations"><a class="markdownIt-Anchor" href="#terminal-operations"></a> Terminal Operations</h3><p>Terminal operations of entity sequences execute the queries right now, then obtain the query results and perform some calculations on them. The for-each loop is a typical terminal operation, and the following code uses it to print all employees in the sequence:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (employee <span class="keyword">in</span> database.employees) &#123;</span><br><span class="line">    println(employee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> _ref0.id</span><br></pre></td></tr></table></figure><p>The <code>toCollection</code> functions (including <code>toList</code>, <code>toSet</code>, etc.) are used to collect all the elements into a collection:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.toCollection(ArrayList())</span><br></pre></td></tr></table></figure><p>The <code>mapColumns</code> function is used to obtain the results of a column:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = database.employees.mapColumns &#123; it.name &#125;</span><br></pre></td></tr></table></figure><p>Additionally, if we want to select two or more columns, we just need to wrap our selected columns by <code>tupleOf</code> in the closure, and the function’s return type becomes <code>List&lt;TupleN&lt;C1?, C2?, .. Cn?&gt;&gt;</code>.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .mapColumns &#123; tupleOf(it.id, it.name) &#125;</span><br><span class="line">    .forEach &#123; (id, name) -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$id</span>:<span class="variable">$name</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.id, t_employee.name</span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">where</span> t_employee.department_id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>Other familiar functions are also supported, such as <code>fold</code>, <code>reduce</code>, <code>forEach</code>, etc. The following code calculates the total salary of all employees:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> totalSalary = database.employees.fold(<span class="number">0L</span>) &#123; acc, employee -&gt; acc + employee.salary &#125;</span><br></pre></td></tr></table></figure><h3 id="sequence-aggregation"><a class="markdownIt-Anchor" href="#sequence-aggregation"></a> Sequence Aggregation</h3><p>The entity sequence APIs not only allow us to obtain entities from databases just like using <code>kotlin.sequences</code>, but they also provide rich support for aggregations, so we can conveniently count the columns, sum them, or calculate their averages, etc.</p><p>The following code obtains the max salary in department 1:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .aggregateColumns &#123; max(it.salary) &#125;</span><br></pre></td></tr></table></figure><p>Also, if we want to aggregate two or more columns, we just need to wrap our aggregate expressions by <code>tupleOf</code> in the closure, and the function’s return type becomes <code>TupleN&lt;C1?, C2?, .. Cn?&gt;</code>. The example below obtains the average and the range of salaries in department 1:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (avg, diff) = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .aggregateColumns &#123; tupleOf(avg(it.salary), max(it.salary) - min(it.salary)) &#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(t_employee.salary), <span class="built_in">max</span>(t_employee.salary) <span class="operator">-</span> <span class="built_in">min</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">where</span> t_employee.department_id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>Ktorm also provides many convenient helper functions implemented based on <code>aggregateColumns</code>, they are <code>count</code>, <code>any</code>, <code>none</code>, <code>all</code>, <code>sumBy</code>, <code>maxBy</code>, <code>minBy</code>, <code>averageBy</code>.</p><p>The following code obtains the max salary in department 1 using <code>maxBy</code> instead:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .maxBy &#123; it.salary &#125;</span><br></pre></td></tr></table></figure><p>Additionally, grouping aggregations are also supported, we just need to call <code>groupingBy</code> before calling <code>aggregateColumns</code>. The following code obtains the average salaries for each department. Here, the result’s type is <code>Map&lt;Int?, Double?&gt;</code>, in which the keys are departments’ IDs, and the values are the average salaries of the departments.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .aggregateColumns &#123; avg(it.salary) &#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id, <span class="built_in">avg</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t_employee.department_id</span><br></pre></td></tr></table></figure><p>Ktorm also provides many convenient helper functions for grouping aggregations, they are <code>eachCount(To)</code>, <code>eachSumBy(To)</code>, <code>eachMaxBy(To)</code>, <code>eachMinBy(To)</code>, <code>eachAverageBy(To)</code>. With these functions, we can write the code below to obtain average salaries for each department:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .eachAverageBy &#123; it.salary &#125;</span><br></pre></td></tr></table></figure><p>Other familiar functions are also supported, such as <code>aggregate</code>, <code>fold</code>, <code>reduce</code>, etc. They have the same names as the extension functions of <code>kotlin.collections.Grouping</code>, and the usages are totally the same. The following code calculates the total salaries for each department using <code>fold</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> totalSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .fold(<span class="number">0L</span>) &#123; acc, employee -&gt; </span><br><span class="line">        acc + employee.salary </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Detailed usages of entity sequence APIs can be found in the documentation of <a href="./entity-sequence.html">entity sequence</a> and <a href="./sequence-aggregation.html">sequence aggregation</a>.</p><div id="support-footer-container"><div class="doc-support-footer"><div class="doc-footer-link">Prev Article: <a href="/">Overview</a></div><div class="doc-footer-link">Next Article: <a href="/en/connect-to-databases.html">Connect to Databases</a></div>Any questions about the document? Try searching again on the left menu or <a href="https://github.com/kotlin-orm/ktorm/issues/new">raise an issue on GitHub</a></div></div></article></div></div><div class="doc-footer">&copy; 2024 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script></body></html>