<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Ktorm | Joining</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch-css@3.6.2/style.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"Joining",lang:"en",related_path:"zh-cn/joining.html",path:"en/joining.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"GETTING STARTED",type:"label",isCurrent:!1},{text:"Overview",type:"link",path:"/",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!0},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",target:"_blank",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]},"navigation-zh-cn":{home:[{title:"快速上手",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",target:"_blank",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"开始",type:"label"},{text:"简介",type:"link",path:"zh-cn/"},{text:"快速上手",type:"link",path:"zh-cn/quick-start.html"},{text:"连接管理",type:"label"},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html"},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html"},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html"},{text:"查询",type:"link",path:"zh-cn/query.html"},{text:"联表",type:"link",path:"zh-cn/joining.html"},{text:"增删改",type:"link",path:"zh-cn/dml.html"},{text:"运算符",type:"link",path:"zh-cn/operators.html"},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html"},{text:"实体类 API",type:"label"},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html"},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html"},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html"},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html"},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html"},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html"},{text:"支持和反馈",type:"label"},{text:"API 文档",type:"support-link",path:"api-docs/index.html",target:"_blank"},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",target:"_blank"},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html"}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc"}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation"><nav class="doc-navbar"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="doc-navbar__logo"><a href="/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close"></i><span class="lang-switcher"><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/joining.html">简体中文</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search documents</span></span><span class="DocSearch-Button-Keys"></span></button></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>GETTING STARTED</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/" target="_self"><span>Overview</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/quick-start.html" target="_self"><span>Quick Start</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>CONNECTION MANAGEMENT</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/connect-to-databases.html" target="_self"><span>Connect to Databases</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/transaction-management.html" target="_self"><span>Transaction Management</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/spring-support.html" target="_self"><span>Spring Support</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/schema-definition.html" target="_self"><span>Schema Definition</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/query.html" target="_self"><span>Query</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current doc-sidebar-list__item--no-children"><a href="/en/joining.html" target="_self"><span>Joining</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/dml.html" target="_self"><span>Data Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/operators.html" target="_self"><span>Operators</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/dialects-and-native-sql.html" target="_self"><span>Dialects &amp; Native SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>ENTITY API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/entities-and-column-binding.html" target="_self"><span>Entities &amp; Column Binding</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/entity-finding.html" target="_self"><span>Entity Query</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/entity-sequence.html" target="_self"><span>Entity Sequence</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/sequence-aggregation.html" target="_self"><span>Sequence Aggregation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/entity-dml.html" target="_self"><span>Entity Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/define-entities-as-any-kind-of-classes.html" target="_self"><span>Define Entities as Any Class</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label doc-sidebar-list__item--no-children"><span>SUPPORT &amp; FEEDBACK</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/api-docs/index.html" target="_blank"><span>API Documents</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank"><span>Issue Feedback</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--no-children"><a href="/en/sponsor.html" target="_self"><span>Sponsor the Project</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher"><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/joining.html">简体中文</a></span></span></div><div class="dc-page"><div class="dc-card"><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/en/joining.md"><i class="icon fa fa-github"></i> <span class="text">Edit Page</span></a><h1 id="joining"><a class="markdownIt-Anchor" href="#joining"></a> Joining</h1><p>We have talked about the SQL DSL for querying in the former section, there were all single-table queries, and that was enough in most cases. However, only a single table is not possible to support our business systems, that’s why joining is an essential feature for an ORM framework.</p><h2 id="joining-functions"><a class="markdownIt-Anchor" href="#joining-functions"></a> Joining Functions</h2><p>Ktorm supports joining queries by some extension functions, there are four built-in join types provided in the core module:</p><figure class="table-wrapper"><table><thead><tr><th>Join Type</th><th>Extension Function Name</th><th>Corresponding SQL Key Word</th></tr></thead><tbody><tr><td>cross join</td><td>crossJoin</td><td>cross join</td></tr><tr><td>inner join</td><td>innerJoin</td><td>inner join</td></tr><tr><td>left join</td><td>leftJoin</td><td>left join</td></tr><tr><td>right join</td><td>rightJoin</td><td>right join</td></tr><tr><td>full join</td><td>fullJoin</td><td>full join</td></tr></tbody></table></figure><p>The functions above are all extensions of <code>QuerySource</code>, a simple usage is given as follows:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> joining = database.from(Employees).crossJoin(Departments)</span><br></pre></td></tr></table></figure><p>Here, the function <code>from</code> wraps a table object as a <code>QuerySource</code> instance, then <code>crossJoin</code> cross joins the instance to another table and returns a new <code>QuerySource</code> as the result. For most of the time, it’s useless for us to hold a <code>QuerySource</code> instance, we need a <code>Query</code> object instead to perform a query and obtain our results.</p><p>Remember how to create a <code>Query</code> from a <code>QuerySource</code>? Yes, we just need to call <code>select</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database.from(Employees).crossJoin(Departments).select()</span><br></pre></td></tr></table></figure><p>This query cross joins the <code>Employees</code> table to the <code>Departments</code> table and returns all records of the joining (cartesian product). Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">join</span> t_department </span><br></pre></td></tr></table></figure><p>That’s so simple, but honestly, such a simple joining query doesn’t make any sense to us in practical use. Here is a more practical example, we want to list those employees whose salary is greater than 100, and return their names and the departments they are from. Here, we specify the second parameter <code>on</code> of the function <code>leftJoin</code>, that’s the joining condition.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .leftJoin(Departments, on = Employees.departmentId eq Departments.id)</span><br><span class="line">    .select(Employees.name, Departments.name)</span><br><span class="line">    .<span class="keyword">where</span> &#123; Employees.salary gt <span class="number">100L</span> &#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.name <span class="keyword">as</span> t_employee_name, t_department.name <span class="keyword">as</span> t_department_name </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department <span class="keyword">on</span> t_employee.department_id <span class="operator">=</span> t_department.id </span><br><span class="line"><span class="keyword">where</span> t_employee.salary <span class="operator">&gt;</span> ? </span><br></pre></td></tr></table></figure><h2 id="self-joining-table-aliases"><a class="markdownIt-Anchor" href="#self-joining-table-aliases"></a> Self Joining &amp; Table Aliases</h2><p>Self joining is a special usage of SQL joining, it joins a table to itself as if the table were two tables. The SQL below uses self joining and returns all employees’ names, their immediate managers, and the departments they are from:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.name <span class="keyword">as</span> emp_name, mgr.name <span class="keyword">as</span> mgr_name, dept.name <span class="keyword">as</span> dept_name </span><br><span class="line"><span class="keyword">from</span> t_employee emp </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_employee mgr <span class="keyword">on</span> emp.manager_id <span class="operator">=</span> mgr.id </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department dept <span class="keyword">on</span> emp.department_id <span class="operator">=</span> dept.id </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> emp.id </span><br></pre></td></tr></table></figure><p>It can be seen that the <code>t_employee</code> table appears twice with different aliases, <code>emp</code> and <code>mgr</code>, in the SQL above. It is exactly the aliases that distinguish the two same tables in the self joining query. Then how can we achieve this with Ktorm?</p><p>You might have noticed that there is an <code>aliased</code> function in the <code>Table</code> class, this function returns a new created table object with all properties (including the table name and columns and so on) being copied from current table, but applying a new alias given by the parameter. Using the <code>aliased</code> function, try to implement the self joining above, we may write code like this:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Names</span>(<span class="keyword">val</span> name: String?, <span class="keyword">val</span> managerName: String?, <span class="keyword">val</span> departmentName: String?)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> emp = Employees.aliased(<span class="string">&quot;emp&quot;</span>) <span class="comment">// Line 3, give an alias to the Employees table. </span></span><br><span class="line"><span class="keyword">val</span> mgr = Employees.aliased(<span class="string">&quot;mgr&quot;</span>) <span class="comment">// Line 4, give another alias to the Employees table. </span></span><br><span class="line"><span class="keyword">val</span> dept = Departments.aliased(<span class="string">&quot;dept&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> results = database</span><br><span class="line">    .from(emp)</span><br><span class="line">    .leftJoin(mgr, on = emp.managerId eq mgr.id) <span class="comment">// Line 8, join one Employees table to the other. </span></span><br><span class="line">    .leftJoin(dept, on = emp.departmentId eq dept.id)</span><br><span class="line">    .select(emp.name, mgr.name, dept.name)</span><br><span class="line">    .orderBy(emp.id.asc())</span><br><span class="line">    .map &#123; row -&gt; </span><br><span class="line">        Names(</span><br><span class="line">            name = row[emp.name],</span><br><span class="line">            managerName = row[mgr.name],</span><br><span class="line">            departmentName = row[dept.name]</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>It’s intuitive and actually the code style recommended by Ktorm’s SQL DSL, but unfortunately, it may not compile. To help us analyze the error, the definition of <code>Employees</code> table is given below, being copied from <a href="./schema-definition.html#Table-Objects">Schema Definition - Table Objects</a>.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Employees : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">&quot;t_employee&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">&quot;id&quot;</span>).primaryKey()</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = varchar(<span class="string">&quot;job&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> managerId = int(<span class="string">&quot;manager_id&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> hireDate = date(<span class="string">&quot;hire_date&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> salary = long(<span class="string">&quot;salary&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> departmentId = int(<span class="string">&quot;department_id&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here is the signature of the <code>aliased</code> function in the super class <code>Table</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">aliased</span><span class="params">(alias: <span class="type">String</span>)</span></span>: Table&lt;E&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>Obviously, according to the signature of the <code>aliased</code> function, the return value’s type of <code>Employees.aliased(&quot;emp&quot;)</code> at line 3 should be <code>Table&lt;E&gt;</code>, and the type of the variable <code>mgr</code> at line 4 is also <code>Table&lt;E&gt;</code>. Then, the <code>emp.managerId eq mrg.id</code> at line 8 is clearly incorrect because properties <code>id</code> and <code>managerId</code> are defined in the <code>Employees</code> object, and the two aliased table objects are typed of <code>Table&lt;E&gt;</code> instead of <code>Employees</code>.</p><p>Limited to the Kotlin language, although the <code>Table.aliased</code> can create a copied table object with a specific alias, it’s return type cannot be the same as the caller’s type but only <code>Table&lt;E&gt;</code>. Here we define the <code>Employees</code> table by an object keyword, and because the keyword defines a singleton object, it’s not possible for Ktorm to create a new object of type <code>Employees</code>.</p><p>To use self joining normally, we recommend that <strong>if we need to use table aliases, please don’t define tables as Kotlin’s singleton objects, please use classes instead, and override the <code>aliased</code> function to return the same type as the concrete table classes:</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employees</span>(alias: String?) : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">&quot;t_employee&quot;</span>, alias) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">aliased</span><span class="params">(alias: <span class="type">String</span>)</span></span> = Employees(alias)</span><br><span class="line">    <span class="comment">// Omit column definitions here...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>However, there can be problems by changing objects to classes, for example, we can not use <code>Employees.name</code> to obtain a column object anymore because an instance is needed to access a class member. So we also recommend that <strong>while defining our tables as classes, please also provide a companion object for each class as the default table object without an alias.</strong> Finally the definition of <code>Employees</code> is:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Employees</span>(alias: String?) : Table&lt;<span class="built_in">Nothing</span>&gt;(<span class="string">&quot;t_employee&quot;</span>, alias) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : Employees(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">aliased</span><span class="params">(alias: <span class="type">String</span>)</span></span> = Employees(alias)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> id = int(<span class="string">&quot;id&quot;</span>).primaryKey()</span><br><span class="line">    <span class="keyword">val</span> name = varchar(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> job = varchar(<span class="string">&quot;job&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> managerId = int(<span class="string">&quot;manager_id&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> hireDate = date(<span class="string">&quot;hire_date&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> salary = long(<span class="string">&quot;salary&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> departmentId = int(<span class="string">&quot;department_id&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>That’s the Ktorm’s support for table aliases. Now you can try to run the self joining query above again, it should be able to generate a SQL perfectly and obtaining your results.</p><h2 id="more-joining-types"><a class="markdownIt-Anchor" href="#more-joining-types"></a> More Joining Types</h2><p>Ktorm only provides four built-in join types in its core module (see <a href="#Joining-Functions">Joining Functions</a>). That’s enough in most cases, but what if we want to use some special join types provided by a special database? Let’s take MySQL’s natural join as an example, learning how to extend more joining types with Ktorm.</p><p>By reading the source code, we can know that the <code>JoinExpression</code> extends from an abstract class <code>QuerySourceExpression</code>. We can also create a class extending from the abstract class by ourselves, let’s name it as <code>NaturalJoinExpression</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">NaturalJoinExpression</span>(</span><br><span class="line">    <span class="keyword">val</span> left: QuerySourceExpression,</span><br><span class="line">    <span class="keyword">val</span> right: QuerySourceExpression,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> isLeafNode: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">) : QuerySourceExpression()</span><br></pre></td></tr></table></figure><p>Having the custom expression type, we also need an extension function to replace the value of <code>expression</code> property in <code>QuerySource</code> instances, just like the functions of <code>crossJoin</code>, <code>leftJoin</code> in the core module.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> QuerySource.<span class="title">naturalJoin</span><span class="params">(right: <span class="type">BaseTable</span>&lt;*&gt;)</span></span>: QuerySource &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.copy(expression = NaturalJoinExpression(left = expression, right = right.asExpression()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>By default, Ktorm cannot recognize our custom expression type <code>NaturalJoinExpression</code>, and are not able to generate SQLs using <code>natural join</code>. To solve the problem, we can extend the <code>SqlFormatter</code> class, override the <code>visitUnknown</code> function, detect our custom expression types and generate proper SQLs:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomSqlFormatter</span>(database: Database, beautifySql: <span class="built_in">Boolean</span>, indentSize: <span class="built_in">Int</span>)</span><br><span class="line">    : MySqlFormatter(database, beautifySql, indentSize) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitUnknown</span><span class="params">(expr: <span class="type">SqlExpression</span>)</span></span>: SqlExpression &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr <span class="keyword">is</span> NaturalJoinExpression) &#123;</span><br><span class="line">            visitQuerySource(expr.left)</span><br><span class="line">            newLine(Indentation.SAME)</span><br><span class="line">            write(<span class="string">&quot;natural join &quot;</span>)</span><br><span class="line">            visitQuerySource(expr.right)</span><br><span class="line">            <span class="keyword">return</span> expr</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitUnknown(expr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Finally, register this custom SQL formatter into the <code>Database</code> object by dialect support. Refer to the later chapters for more details about <a href="./dialects-and-native-sql.html">dialects</a>.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> database = Database.connect(</span><br><span class="line">    url = <span class="string">&quot;jdbc:mysql://localhost:3306/ktorm&quot;</span>, user = <span class="string">&quot;root&quot;</span>, password = <span class="string">&quot;***&quot;</span>,</span><br><span class="line">    dialect = <span class="keyword">object</span> : SqlDialect &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createSqlFormatter</span><span class="params">(database: <span class="type">Database</span>, beautifySql: <span class="type">Boolean</span>, indentSize: <span class="type">Int</span>)</span></span>: SqlFormatter &#123;</span><br><span class="line">            <span class="keyword">return</span> CustomSqlFormatter(database, beautifySql, indentSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>All done! The usage of <code>naturalJoin</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database.from(Employees).naturalJoin(Departments).select()</span><br></pre></td></tr></table></figure><p>In this way, Ktorm supports natural join now. Actually, this is one of the features of ktorm-support-mysql module, if you really need to use natural join, you don’t have to repeat the code above, please add the dependency to your project.</p><p>Maven dependency:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ktorm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ktorm-support-mysql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;ktorm.version&#125;</span><span class="language-xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Or Gradle:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">&quot;org.ktorm:ktorm-support-mysql:$&#123;ktorm.version&#125;&quot;</span></span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer"><div class="doc-footer-link">Prev Article: <a href="/en/query.html">Query</a></div><div class="doc-footer-link">Next Article: <a href="/en/dml.html">Data Manipulation</a></div>Any questions about the document? Try searching again on the left menu or <a href="https://github.com/kotlin-orm/ktorm/issues/new">raise an issue on GitHub</a></div></div></article></div></div><div class="doc-footer">&copy; 2024 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script></body></html>