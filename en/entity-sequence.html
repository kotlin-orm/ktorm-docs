<!-- build time:Sun Jun 05 2022 16:42:51 GMT+0800 (CST) --><!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Ktorm | Entity Sequence</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"Entity Sequence",lang:"en",related_path:"zh-cn/entity-sequence.html",path:"en/entity-sequence.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"Overview",type:"link",path:"",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!0},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]},"navigation-zh-cn":{home:[{title:"快速开始",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"概述",type:"link",path:"zh-cn/"},{text:"快速开始",type:"link",path:"zh-cn/quick-start.html"},{text:"连接管理",type:"label"},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html"},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html"},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html"},{text:"查询",type:"link",path:"zh-cn/query.html"},{text:"联表",type:"link",path:"zh-cn/joining.html"},{text:"增删改",type:"link",path:"zh-cn/dml.html"},{text:"运算符",type:"link",path:"zh-cn/operators.html"},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html"},{text:"实体类 API",type:"label"},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html"},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html"},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html"},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html"},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html"},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html"},{text:"支持和反馈",type:"label"},{text:"API 文档",type:"support-link",path:"api-docs/index.html"},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new"},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html"}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc",algolia:{appId:"2W81KMSLOD",apiKey:"2a146a809de068d9b7a07ba3fb70b4e5",indexName:"ktorm",chunkSize:5e3,fields:["title","lang","date","updated","_content:truncate,0,5200","path","permalink"]}}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><span class="doc-navbar__logo"><a href="/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="lang-switcher"><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/entity-sequence.html">简体中文</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><div class="dc-search-form doc-search-form"><input type="search" id="doc-search-input" class="dc-input dc-search-form__input doc-search-form__input" placeholder="Search documents" autofocus><button class="dc-btn dc-search-form__btn doc-search-form__btn" aria-label="Search"><i class="dc-icon dc-icon--search"></i></button></div></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/" target="_self"><span>Overview</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/quick-start.html" target="_self"><span>Quick Start</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>CONNECTION MANAGEMENT</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/connect-to-databases.html" target="_self"><span>Connect to Databases</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/transaction-management.html" target="_self"><span>Transaction Management</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/spring-support.html" target="_self"><span>Spring Support</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/schema-definition.html" target="_self"><span>Schema Definition</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/query.html" target="_self"><span>Query</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/joining.html" target="_self"><span>Joining</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/dml.html" target="_self"><span>Data Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/operators.html" target="_self"><span>Operators</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/dialects-and-native-sql.html" target="_self"><span>Dialects &amp; Native SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>ENTITY API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entities-and-column-binding.html" target="_self"><span>Entities &amp; Column Binding</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-finding.html" target="_self"><span>Entity Query</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current"><a href="/en/entity-sequence.html" target="_self"><span>Entity Sequence</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/sequence-aggregation.html" target="_self"><span>Sequence Aggregation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-dml.html" target="_self"><span>Entity Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/define-entities-as-any-kind-of-classes.html" target="_self"><span>Define Entities as Any Class</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SUPPORT &amp; FEEDBACK</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/api-docs/index.html" target="_self"><span>API Documents</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_self"><span>Issue Feedback</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/sponsor.html" target="_self"><span>Sponsor the Project</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher" data-reactroot=""><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/entity-sequence.html">简体中文</a></span></span></div><div class="dc-page"><div class="dc-card"><div id="doc-search-results" class="doc-search-results"><div id="doc-search-stats"></div><div id="doc-search-hits"></div><div id="doc-search-pagination"></div></div><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/en/entity-sequence.md"><i class="icon fa fa-github"></i> <span class="text">Edit Page</span></a><h1 id="Entity-Sequence"><a href="#Entity-Sequence" class="headerlink" title="Entity Sequence"></a>Entity Sequence</h1><p>In the previous section, we briefly learned how to obtain entity objects via sequence APIs. Now we will introduce them in more detail.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>To use sequence APIs, we need to create sequence objects first. In general, we’d like to define some extension properties for <code>Database</code>. These properties return new created sequence objects via <code>sequenceOf</code> and they can help us improve the readability of the code:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> Database.departments <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Departments)</span><br><span class="line"><span class="keyword">val</span> Database.employees <span class="keyword">get</span>() = <span class="keyword">this</span>.sequenceOf(Employees)</span><br></pre></td></tr></table></figure><p>The function <code>sequenceOf</code> returns default sequences, by which we can obtain all entity objects from the table. Please know that Ktorm doesn’t execute the queries right now. The sequence provides an iterator of type <code>Iterator&lt;E&gt;</code>, only when we iterate the sequence using the iterator, the query is executed. The following code prints all employees using a for-each loop:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (employee <span class="keyword">in</span> database.employees) &#123;</span><br><span class="line">    println(employee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id = _ref0.id</span><br></pre></td></tr></table></figure><blockquote><p>While calling <code>sequenceOf</code>, we can set the parameter <code>withReferences</code> to <code>false</code> to disable the auto-joining of reference tables, eg: <code>database.sequenceOf(Employees, withReferences = false)</code></p></blockquote><p>In addition to the for-each loop, we can also use the extension function <code>toList</code> to save all the items from the sequence into a list:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.toList()</span><br></pre></td></tr></table></figure><p>We can even add a filter condition by the <code>filter</code> function before calling <code>toList</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.filter &#123; it.departmentId eq <span class="number">1</span> &#125;.toList()</span><br></pre></td></tr></table></figure><p>Now the generated SQL is:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id = _ref0.id </span><br><span class="line"><span class="keyword">where</span> t_employee.department_id = ?</span><br></pre></td></tr></table></figure><p>Now let’s learn the definition of the core class <code>EntitySequence</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">EntitySequence</span>&lt;<span class="type">E : Any, T : BaseTable&lt;E</span>&gt;&gt;</span>(</span><br><span class="line">    <span class="keyword">val</span> database: Database, </span><br><span class="line">    <span class="keyword">val</span> sourceTable: T,</span><br><span class="line">    <span class="keyword">val</span> expression: SelectExpression,</span><br><span class="line">    <span class="keyword">val</span> entityExtractor: (row: QueryRowSet) -&gt; E</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> query = Query(database, expression)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sql <span class="keyword">get</span>() = query.sql</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rowSet <span class="keyword">get</span>() = query.rowSet</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> totalRecords <span class="keyword">get</span>() = query.totalRecords</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asKotlinSequence</span><span class="params">()</span></span> = Sequence &#123; iterator() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span> = <span class="keyword">object</span> : Iterator&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> queryIterator = query.iterator()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queryIterator.hasNext()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span>: E &#123;</span><br><span class="line">            <span class="keyword">return</span> entityExtractor(queryIterator.next())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can see this class wraps a <code>Query</code> object, and it’s iterator exactly wraps the query’s iterator. While an entity sequence is iterated, its internal query is executed, and the <code>entityExtractor</code> function is applied to create an entity object for each row. As for other properties in sequences (such as <code>sql</code>, <code>rowSet</code>, <code>totalRecords</code>, etc), all of them delegates the callings to their internal query objects, and their usages are totally the same as the corresponding properties in <code>Query</code> class.</p><p>Most of the entity sequence APIs are provided as extension functions, which can be divided into two groups:</p><ul><li><strong>Intermediate operations:</strong> these functions don’t execute the internal queries but return new-created sequence objects applying some modifications. For example, the <code>filter</code> function creates a new sequence object with the filter condition given by its parameter. The return types of intermediate operations are usually <code>EntitySequence</code>, so we can chaining call other sequence functions continuously.</li><li><strong>Terminal operations:</strong> the return types of these functions are usually a collection or a computed result, as they execute the queries right now, obtain their results and perform some calculations on them. Eg. <code>toList</code>, <code>reduce</code>, etc.</li></ul><h2 id="Intermediate-Operations"><a href="#Intermediate-Operations" class="headerlink" title="Intermediate Operations"></a>Intermediate Operations</h2><p>Just like <code>kotlin.sequences</code>, the intermediate operations of <code>EntitySequence</code> doesn’t iterate the sequences and execute the internal queries, they all return new-created sequence objects instead. These intermediate operations are listed below:</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">filter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    predicate: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">Boolean</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: EntitySequence&lt;E, T&gt;</span><br></pre></td></tr></table></figure><p>Similar to the <code>filter</code> function of <code>kotlin.sequences</code>, the <code>filter</code> function here also accepts a closure as its parameter, and the returned value from the closure will be used as a filter condition. Differently, our closure has a parameter of type <code>T</code>, the current table object, so what we get in the closure by <code>it</code> is the table object instead of an entity element. Besides, the closure’s return type is <code>ColumnDeclaring&lt;Boolean&gt;</code> instead of <code>Boolean</code>. The following code obtains all the employees in department 1 by using <code>filter</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.filter &#123; it.departmentId eq <span class="number">1</span> &#125;.toList()</span><br></pre></td></tr></table></figure><p>We can see that the usage is almost the same as <code>kotlin.sequences</code>, the only difference is the <code>==</code> in the lambda is replaced by the <code>eq</code> function. The <code>filter</code> function can also be called continuously, as all the filter conditions are combined with the <code>and</code> operator.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .filter &#123; it.managerId.isNotNull() &#125;</span><br><span class="line">    .toList()</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id = _ref0.id </span><br><span class="line"><span class="keyword">where</span> (t_employee.department_id = ?) <span class="keyword">and</span> (t_employee.manager_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>Actually, Ktorm provides a <code>filterNot</code> function, its usage is totally the same as <code>filter</code>, but negates the returned filter condition in the closure. For example, the second <code>filter</code> call in the code above can be replaced as <code>filterNot { it.managerId.isNull() }</code>. Additionally, Ktorm also provides <code>filterTo</code> and <code>filterNotTo</code>. But they are terminal operations, as they will iterate the sequence and collect the elements into a collection after applying the filter condition, that’s equivalent to call <code>toCollection</code> immediately after calling <code>filter</code>.</p><h3 id="filterColumns"><a href="#filterColumns" class="headerlink" title="filterColumns"></a>filterColumns</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">filterColumns</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    selector: (<span class="type">T</span>) -&gt; <span class="type">List</span>&lt;<span class="type">Column</span>&lt;*&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: EntitySequence&lt;E, T&gt;</span><br></pre></td></tr></table></figure><p>By default, an entity sequence selects all the columns from the current table and referenced tables (if enabled), that may lead to unnecessary performance costs. If we are sensitive to the performance issue, we can use the <code>filterColumns</code> function, which supports us to custom the selected columns in the query. Assuming we want to get a list of departments, but their location data is not required, we can write codes like:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> departments = database.departments</span><br><span class="line">    .filterColumns &#123; it.columns - it.location &#125;</span><br><span class="line">    .toList()</span><br></pre></td></tr></table></figure><p>Now, the location data is removed from the returned entity objects, generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_department.id <span class="keyword">as</span> t_department_id, t_department.name <span class="keyword">as</span> t_department_name </span><br><span class="line"><span class="keyword">from</span> t_department</span><br></pre></td></tr></table></figure><h3 id="sortedBy"><a href="#sortedBy" class="headerlink" title="sortedBy"></a>sortedBy</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">sortedBy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    selector: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;*&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: EntitySequence&lt;E, T&gt;</span><br></pre></td></tr></table></figure><p>Ktorm provides a <code>sortedBy</code> function, which allows us to specify the <em>order by</em> clause for the sequence’s internal query. The function accepts a closure as its parameter in which we need to return a column or expression. The following code obtains all the employees and sorts them by their salaries:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.sortedBy &#123; it.salary &#125;.toList()</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id = _ref0.id </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t_employee.salary</span><br></pre></td></tr></table></figure><p>The <code>sortedBy</code> function defaultly sorts entities in ascending order, if we need descending order, we can use <code>sortedByDescending</code> instead.</p><p>Sometimes, we need to sort entities by two or more columns, then we can call the <code>sortedBy</code> function with multiple closures. The example below sorts the employees firstly by salaries descending, then by hire dates ascending:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees</span><br><span class="line">    .sortedBy(&#123; it.salary.desc() &#125;, &#123; it.hireDate.asc() &#125;)</span><br><span class="line">    .toList()</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id = _ref0.id </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t_employee.salary <span class="keyword">desc</span>, t_employee.hire_date</span><br></pre></td></tr></table></figure><h3 id="drop-take"><a href="#drop-take" class="headerlink" title="drop/take"></a>drop/take</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">drop</span><span class="params">(n: <span class="type">Int</span>)</span></span>: EntitySequence&lt;E, T&gt;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">take</span><span class="params">(n: <span class="type">Int</span>)</span></span>: EntitySequence&lt;E, T&gt;</span><br></pre></td></tr></table></figure><p>The <code>drop</code> and <code>take</code> functions are designed for pagination. The <code>drop</code> function returns a new sequence containing all elements except first n elements, while the <code>take</code> function returns a new sequence only containing first n elements. Usage example:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.drop(<span class="number">1</span>).take(<span class="number">1</span>).toList()</span><br></pre></td></tr></table></figure><p>If we are using MySQL, the generated SQL is:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> t_department _ref0 <span class="keyword">on</span> t_employee.department_id = _ref0.id </span><br><span class="line"><span class="keyword">limit</span> ?, ?</span><br></pre></td></tr></table></figure><p>Note that these two functions are implemented based on the pagination feature of the specific databases. However, the SQL standard doesn’t say how to implement paging queries, and different databases provide different implementations on that. So we have to enable a dialect if we need to use these two functions, more details can be found in the section <a href="./query.html#limit">Query - limit</a>.</p><h2 id="Terminal-Operations"><a href="#Terminal-Operations" class="headerlink" title="Terminal Operations"></a>Terminal Operations</h2><p>Terminal operations of entity sequences execute the queries right now, then obtain the query results and perform some calculations on them, the usage of which is almost the same as <code>kotlin.sequences</code>.</p><h3 id="toCollection"><a href="#toCollection" class="headerlink" title="toCollection"></a>toCollection</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, C : MutableCollection&lt;in E&gt;</span>&gt; EntitySequence<span class="type">&lt;E, *&gt;</span>.<span class="title">toCollection</span><span class="params">(destination: <span class="type">C</span>)</span></span>: C</span><br></pre></td></tr></table></figure><p>The <code>toCollection</code> function is used to collect all the elements in a sequence. It’ll execute the internal query right now and iterate the results, adding them to the <code>destination</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.toCollection(ArrayList())</span><br></pre></td></tr></table></figure><p>In addition, Ktorm also provides some convenient <code>toXxx</code> functions based on <code>toCollection</code> to convert sequences to particular type of collections, they are <code>toList</code>, <code>toMutableList</code>, <code>toSet</code>, <code>toMutableSet</code>, <code>toHashSet</code>, <code>toSortedSet</code>.</p><h3 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map/flatMap"></a>map/flatMap</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, R&gt;</span> EntitySequence<span class="type">&lt;E, *&gt;</span>.<span class="title">map</span><span class="params">(transform: (<span class="type">E</span>) -&gt; <span class="type">R</span>)</span></span>: List&lt;R&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, R&gt;</span> EntitySequence<span class="type">&lt;E, *&gt;</span>.<span class="title">flatMap</span><span class="params">(transform: (<span class="type">E</span>) -&gt; <span class="type">Iterable</span>&lt;<span class="type">R</span>&gt;)</span></span>: List&lt;R&gt;</span><br></pre></td></tr></table></figure><p>According to our experience of functional programming, we might consider the <code>map</code> and <code>flatMap</code> functions as intermediate. However, they are terminal instead, which is a compromise of Ktorm’s design.</p><p>The <code>map</code> function will execute the internal query and iterate the query results right now, then perform the transformation specified by the <code>transform</code> closure for each element, finally collect the transforming results into a list. The <code>flatMap</code> function will also execute the query immediately, and the difference between <code>map</code> and <code>flatMap</code> is obvious to those who are familiar with functional programming, so I won’t go into details here.</p><p>The following code obtains all the employees’ names:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = database.employees.map &#123; it.name &#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee</span><br></pre></td></tr></table></figure><p>Note that although we only need the names here, the generated SQL still selects all columns, that’s because Ktorm doesn’t know which columns are required. If we are sensitive to that performance issue, we can use the <code>filterColumns</code> function cooperatively, or we can also use the <code>mapColumns</code> function instead.</p><p>In addition to the basic form of <code>map</code> function, Ktorm also provides <code>mapTo</code>, <code>mapIndexed</code>, <code>mapIndexedTo</code>, etc. they have the same names as the extension functions of <code>kotlin.sequences</code> in Kotlin standard lib and their usages are totally the same.</p><h3 id="mapColumns"><a href="#mapColumns" class="headerlink" title="mapColumns"></a>mapColumns</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>, C : Any&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">mapColumns</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    isDistinct: <span class="type">Boolean</span> = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    columnSelector: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">C</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: List&lt;C?&gt;</span><br></pre></td></tr></table></figure><p>The <code>mapColumns</code> function is similar to <code>map</code>. Differently, its closure accepts the current table object <code>T</code> as the parameter, so what we get in the closure by <code>it</code> is the table object instead of an entity element. Besides, the closure’s return type is <code>ColumnDeclaring&lt;C&gt;</code>, and we should return a column or expression needed to be selected from the database. Let’s implement the same example as the previous one, the following code obtains all employees’ names:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = database.employees.mapColumns &#123; it.name &#125;</span><br></pre></td></tr></table></figure><p>Now we can see there is only the required column in the generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.name </span><br><span class="line"><span class="keyword">from</span> t_employee</span><br></pre></td></tr></table></figure><p>If we want to select two or more columns, we just need to wrap our selected columns by <code>tupleOf</code> in the closure, then the function’s return type becomes <code>List&lt;TupleN&lt;C1?, C2?, .. Cn?&gt;&gt;</code>. The example below prints the IDs, names and hired days of the employees in department 1:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .mapColumns &#123; tupleOf(it.id, it.name, dateDiff(LocalDate.now(), it.hireDate)) &#125;</span><br><span class="line">    .forEach &#123; (id, name, days) -&gt;</span><br><span class="line">        println(<span class="string">"<span class="variable">$id</span>:<span class="variable">$name</span>:<span class="variable">$days</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>The standard output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1:vince:473</span><br><span class="line">2:marry:108</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.id, t_employee.name, <span class="keyword">datediff</span>(?, t_employee.hire_date) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">where</span> t_employee.department_id = ?</span><br></pre></td></tr></table></figure><blockquote><p><code>tupleOf</code> creates a tuple of the given arguments. Its return type can be from <code>Tuple2</code> to <code>Tuple9</code> depending on the number of its parameters. That’s to say, we are able to select a maximum of nine columns at once with <code>mapColumns</code> function. But what if we want ten columns or more? I’m sorry to say no. Ktorm doesn’t think it’s a frequent-used feature. If you really need that, you can use <code>filterColumns</code> or <a href="./query.html">query DSL</a> instead.</p></blockquote><p>In addition to the basic form of <code>mapColumns</code> function, Ktorm also provides <code>mapColumnsTo</code>, <code>mapColumnsNotNull</code>, <code>mapColumnsNotNullTo</code>. It’s easy to know their usages by the names, so we won’t repeat it.</p><h3 id="associate"><a href="#associate" class="headerlink" title="associate"></a>associate</h3><p>The <code>associate</code> function executes the internal query, then iterate the query results and collect them into a <code>Map</code>. Its usage is totally the same as the corresponding extension function of <code>kotlin.sequences</code>, more details can be found in Kotlin’s documents.</p><p>In addition to the basic form of <code>associate</code> function, Ktorm also provides <code>associateBy</code>, <code>associateWith</code>, <code>associateTo</code>, <code>associateByTo</code>, <code>associateWithTo</code>.</p><h3 id="elementAt-first-last-find-findLast-single"><a href="#elementAt-first-last-find-findLast-single" class="headerlink" title="elementAt/first/last/find/findLast/single"></a>elementAt/first/last/find/findLast/single</h3><p>These functions are used to get the element at a specific position from the sequence. Their usages are also the same as the corresponding ones of <code>kotlin.sequences</code>.</p><p>Especially, if a dialect is enabled, these functions will use the pagination feature to obtain the very record only. Assuming we are using MySQL and calling the <code>elementAt</code> with an index 10, a SQL containing <code>limit 10, 1</code> will be generated. But if there are no dialects enabled, then all records will be obtained to ensure the functions just works.</p><p>In addition to the basic forms, there are also many variants for these functions, but it’s not so necessary to list them here.</p><h3 id="fold-reduce-forEach"><a href="#fold-reduce-forEach" class="headerlink" title="fold/reduce/forEach"></a>fold/reduce/forEach</h3><p>This serial of functions provide features of iteration and folding, and their usages are also the same as the corresponding ones of <code>kotlin.sequences</code>. The following code calculates the total salary of all employees:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> totalSalary = database.employees.fold(<span class="number">0L</span>) &#123; acc, employee -&gt; acc + employee.salary &#125;</span><br></pre></td></tr></table></figure><p>Of course, if only the total salary is needed, we don’t have to write codes in that way. Because the performance is really poor, as all employees are obtained from the database. Here we just show you the usage of the <code>fold</code> function. It’s better to use <code>sumBy</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> totalSalary = database.employees.sumBy &#123; it.salary &#125;</span><br></pre></td></tr></table></figure><h3 id="joinTo-joinToString"><a href="#joinTo-joinToString" class="headerlink" title="joinTo/joinToString"></a>joinTo/joinToString</h3><p>These two functions provide the feature of joining the sequence elements to strings, and their usages are also the same as the corresponding ones of <code>kotlin.sequences</code>. The following code joins all the employees’ names to a string:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = database.employees.joinToString(separator = <span class="string">":"</span>) &#123; it.name &#125;</span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer" data-reactroot=""><div class="doc-footer-link">Prev Article: <a href="/en/entity-finding.html">Entity Query</a></div><div class="doc-footer-link">Next Article: <a href="/en/sequence-aggregation.html">Sequence Aggregation</a></div>Any questions about the document? Try searching again on the left menu or <a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank" rel="noopener">Raise an issue on Github</a></div></div></article></div></div><div class="doc-footer">&copy; 2022 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm" target="_blank" rel="noopener">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script><script src="/script/doc.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script><script type="text/javascript">docsearch({appId:"0DGANM0MZ3",apiKey:"071ea85fb6b0933d3f3d3925aa434e23",indexName:"ktorm",inputSelector:"#doc-search-input",algoliaOptions:{facetFilters:["lang:en","tags:doc"]},autocompleteOptions:{hint:!1,appendTo:"body"},debug:!1})</script><script>!function(){$(".kotlin .code .keyword").each(function(){var e=$(this);("where"===e.text()||"set"===e.text())&&e.removeClass("keyword")})}()</script></body></html><!-- rebuild by neat -->