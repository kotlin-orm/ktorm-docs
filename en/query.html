<!-- build time:Wed Jun 15 2022 23:14:10 GMT+0800 (CST) --><!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Ktorm | Query</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch@2.6.3/docsearch.min.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"Query",lang:"en",related_path:"zh-cn/query.html",path:"en/query.html"},data:{"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"Overview",type:"link",path:"",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!0},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]},"navigation-zh-cn":{home:[{title:"快速开始",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"概述",type:"link",path:"zh-cn/"},{text:"快速开始",type:"link",path:"zh-cn/quick-start.html"},{text:"连接管理",type:"label"},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html"},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html"},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html"},{text:"查询",type:"link",path:"zh-cn/query.html"},{text:"联表",type:"link",path:"zh-cn/joining.html"},{text:"增删改",type:"link",path:"zh-cn/dml.html"},{text:"运算符",type:"link",path:"zh-cn/operators.html"},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html"},{text:"实体类 API",type:"label"},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html"},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html"},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html"},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html"},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html"},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html"},{text:"支持和反馈",type:"label"},{text:"API 文档",type:"support-link",path:"api-docs/index.html"},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new"},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html"}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc",algolia:{appId:"2W81KMSLOD",apiKey:"2a146a809de068d9b7a07ba3fb70b4e5",indexName:"ktorm",chunkSize:5e3,fields:["title","lang","date","updated","_content:truncate,0,5200","path","permalink"]}}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><span class="doc-navbar__logo"><a href="/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="lang-switcher"><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/query.html">简体中文</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><div class="dc-search-form doc-search-form"><input type="search" id="doc-search-input" class="dc-input dc-search-form__input doc-search-form__input" placeholder="Search documents" autofocus><button class="dc-btn dc-search-form__btn doc-search-form__btn" aria-label="Search"><i class="dc-icon dc-icon--search"></i></button></div></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/" target="_self"><span>Overview</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/quick-start.html" target="_self"><span>Quick Start</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>CONNECTION MANAGEMENT</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/connect-to-databases.html" target="_self"><span>Connect to Databases</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/transaction-management.html" target="_self"><span>Transaction Management</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/spring-support.html" target="_self"><span>Spring Support</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/schema-definition.html" target="_self"><span>Schema Definition</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current"><a href="/en/query.html" target="_self"><span>Query</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/joining.html" target="_self"><span>Joining</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/dml.html" target="_self"><span>Data Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/operators.html" target="_self"><span>Operators</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/dialects-and-native-sql.html" target="_self"><span>Dialects &amp; Native SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>ENTITY API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entities-and-column-binding.html" target="_self"><span>Entities &amp; Column Binding</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-finding.html" target="_self"><span>Entity Query</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-sequence.html" target="_self"><span>Entity Sequence</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/sequence-aggregation.html" target="_self"><span>Sequence Aggregation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-dml.html" target="_self"><span>Entity Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/define-entities-as-any-kind-of-classes.html" target="_self"><span>Define Entities as Any Class</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SUPPORT &amp; FEEDBACK</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/api-docs/index.html" target="_self"><span>API Documents</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_self"><span>Issue Feedback</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/sponsor.html" target="_self"><span>Sponsor the Project</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher" data-reactroot=""><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/query.html">简体中文</a></span></span></div><div class="dc-page"><div class="dc-card"><div id="doc-search-results" class="doc-search-results"><div id="doc-search-stats"></div><div id="doc-search-hits"></div><div id="doc-search-pagination"></div></div><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/en/query.md"><i class="icon fa fa-github"></i> <span class="text">Edit Page</span></a><h1 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h1><p>In former chapters, we have created a simple query, it selected all employees in the table and printed their names. Let’s start from this query:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (row <span class="keyword">in</span> database.from(Employees).select()) &#123;</span><br><span class="line">    println(row[Employees.name])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Query-Objects"><a href="#Query-Objects" class="headerlink" title="Query Objects"></a>Query Objects</h2><p>In the example above, we get a <code>Query</code> from <code>select</code> function and iterates it with a for-each loop. There are also some other operations supported by <code>Query</code> besides iteration. Let’s start our learning with its definition below:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span></span>(<span class="keyword">val</span> database: Database, <span class="keyword">val</span> expression: QueryExpression) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> sql: String <span class="keyword">by</span> lazy &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rowSet: QueryRowSet <span class="keyword">by</span> lazy &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> totalRecords: <span class="built_in">Int</span> <span class="keyword">by</span> lazy &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;QueryRowSet&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> rowSet.iterator()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Query</code> is an abstraction of query operations and the core of Ktorm’s query DSL. Its constructor accepts two parameters: <code>database</code> is the database instance that this query is running on; <code>expression</code> is the abstract representation of the executing SQL statement. Usually, we don’t use the constructor to create <code>Query</code> objects but use the <code>database.from(..).select(..)</code> syntax instead.</p><p><code>Query</code> overloads the <code>iterator</code> operator, that’s why we can iterate the results by a for-each loop. Moreover, we also provide some additional extension functions just like <code>Iterable</code> in the Kotlin standard lib, so we can also process the results via functions such as <code>map</code>, <code>flatMap</code>, etc. Here is an example:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Emp</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>?, <span class="keyword">val</span> name: String?, <span class="keyword">val</span> salary: <span class="built_in">Long</span>?)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> query = database.from(Employees).select()</span><br><span class="line"></span><br><span class="line">query</span><br><span class="line">    .map &#123; row -&gt; Emp(row[Employees.id], row[Employees.name], row[Employees.salary]) &#125;</span><br><span class="line">    .filter &#123; it.salary &gt; <span class="number">1000</span> &#125;</span><br><span class="line">    .sortedBy &#123; it.salary &#125;</span><br><span class="line">    .forEach &#123; println(it.name) &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Please note: In the example above, all the work Ktorm does is just to generate a simple SQL <code>select * from t_employee</code>. The following <code>.map { }.filter { }.sortedBy { }.forEach { }</code> are just collection operations in memory.</p></blockquote><p>There are some other useful properties in the <code>Query</code> class:</p><ul><li><strong>sql:</strong> Return the generated SQL string of this query, can be used to ensure whether the generated SQL is expected while debugging.</li><li><strong>rowSet:</strong> Return the <code>ResultSet</code> object of this query, lazy initialized after first access, obtained from database by executing the generated SQL.</li><li><strong>totalRecords:</strong> If the query doesn’t limits the results via <em>offset</em> and <em>limit</em>, return the size of the result set. Or if it does, return the total record count of the query ignoring the <em>offset</em> and <em>limit</em> parameters. Ktorm provides this property to support pagination, we can calculate page count through dividing it by our page size.</li></ul><h2 id="Obtain-Query-Results"><a href="#Obtain-Query-Results" class="headerlink" title="Obtain Query Results"></a>Obtain Query Results</h2><p>Every JDBC user knows how to obtain query results from a <code>ResultSet</code>. We need a loop to iterate rows in it, calling the getter functions (such as <code>getInt</code>, <code>getString</code>, etc) to obtain the data of the specific column. A typical usage is based on a while loop: <code>while (rs.netxt()) { ... }</code>. Moreover, after finishing these works, we also have to call <code>close</code> function to release the resources.</p><p>That’s not so hard, but it’s still easy to get bored with writing those duplicated codes, but Ktorm provided another possibility for us. We can iterate results sets by a for-each loop, or process them via extension functions like <code>map</code>, <code>flatMap</code>, etc, just like the previous example.</p><p>You might have noticed that the return type of <code>Query.rowSet</code> was not a normal <code>ResultSet</code>, but a <code>QueryRowSet</code> instead. That’s a special implementation provided by Ktorm, different from normal result sets, it provides additional features:</p><ul><li><strong>Available offline:</strong> It’s connection independent, it remains available after the connection closed, and it’s not necessary to be closed after being used. Ktorm creates <code>QueryRowSet</code> objects with all data being retrieved from the result set into memory, so we just need to wait for GC to collect them after they are not useful.</li><li><strong>Indexed access operator:</strong> <code>QueryRowSet</code> overloads the <a href="https://kotlinlang.org/docs/reference/operator-overloading.html#indexed" target="_blank" rel="noopener">indexed access operator</a>, so we can use square brackets <code>[]</code> to obtain the value by giving a specific <code>Column</code> instance. It’s less error prone by the benefit of the compiler’s static checking. Also, we can still use <code>getXxx</code> functions in the <code>ResultSet</code> to obtain our results by labels or column indices.</li></ul><p>Obtain results via indexed access operator:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (row <span class="keyword">in</span> database.from(Employees).select()) &#123;</span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span>? = row[Employees.id]</span><br><span class="line">    <span class="keyword">val</span> name: String? = row[Employees.name]</span><br><span class="line">    <span class="keyword">val</span> salary: <span class="built_in">Long</span>? = row[Employees.salary]</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"<span class="variable">$id</span>, <span class="variable">$name</span>, <span class="variable">$salary</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can see that if the column’s type is <code>Column&lt;Int&gt;</code>, then the result’s type is <code>Int?</code>, and if the column’s type is <code>Column&lt;String&gt;</code>, the result type will be <code>String?</code>. The types are not limited to the return types of <code>getXxx</code> functions in <code>ResultSet</code>, they can be any types corresponding to the column instances instead. And additionally, there can be some necessary conversions on data, that depends on the column’s implementation of <a href="./schema-definition.html#SqlType">SqlType</a>.</p><h2 id="from"><a href="#from" class="headerlink" title="from"></a>from</h2><p><code>from</code> is an extension function of <code>Database</code>. It wraps the specific table as a <code>QuerySource</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Database.<span class="title">from</span><span class="params">(table: <span class="type">BaseTable</span>&lt;*&gt;)</span></span>: QuerySource</span><br></pre></td></tr></table></figure><p>As the function name <code>from</code> shows, <code>QuerySource</code> represents the from clause of a SQL query. After we get a <code>QuerySource</code> object, we can call the <code>select</code> function to create a query, or we can continue to call <code>innerJoin</code>, <code>leftJoin</code> or other functions to join some tables.</p><p>In this article we will use the <code>from</code> function to elicit our query DSL. As for joining, please refer to the <a href="./joining.html">next section</a>.</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>All queries in SQL start with a select keyword. Similarly, All queries in Ktorm start with a <code>select</code> function call. <code>select</code> is an extension function of <code>QuerySource</code>. Its signature is given as follows:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> QuerySource.<span class="title">select</span><span class="params">(<span class="keyword">vararg</span> columns: <span class="type">ColumnDeclaring</span>&lt;*&gt;)</span></span>: Query</span><br></pre></td></tr></table></figure><p>We can see it accepts any number of columns and returns a new-created <code>Query</code> object which selects specific columns from the current query source. The example below obtains employees’ ids and names via the <code>select</code> function:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database.from(Employees).select(Employees.id, Employees.name)</span><br></pre></td></tr></table></figure><p>Now we have a <code>Query</code> object, but no SQL has been executed yet. We can chaining call <code>where</code> or other extension functions to modify it, or iterate it by a for-each loop or any other way. While the query object is iterated, Ktorm will execute a generated SQL, then we can obtain results in the way we discussed above. The generated SQL is given as follows:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.id <span class="keyword">as</span> t_employee_id, t_employee.name <span class="keyword">as</span> t_employee_name </span><br><span class="line"><span class="keyword">from</span> t_employee</span><br></pre></td></tr></table></figure><p>Try to remove the arguments passed to the <code>select</code> function:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database.from(Employees).select()</span><br></pre></td></tr></table></figure><p>Then the generated SQL will be changed to <code>select *</code>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee</span><br></pre></td></tr></table></figure><p>You might have noticed that the parameter type of <code>select</code> function was <code>ColumnDeclaring</code> instead of <code>Column</code>. So we can not only select normal columns from a table, but complex expressions and aggregation functions are also supported. For instance, if we want to know the salary difference between the max and the min in a company, we can write a query like this:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(max(Employees.salary) - min(Employees.salary))</span><br><span class="line">    .forEach &#123; row -&gt; println(row.getLong(<span class="number">1</span>)) &#125;</span><br></pre></td></tr></table></figure><p>Here we use two aggregation functions, <code>max</code> and <code>min</code>, the return types of which are both <code>AggregateExpression</code>. Then subtracting the max by the min, we finally have a <code>BinaryExpression</code>, which is a subclass of <code>ColumnDeclaring</code>, so we can pass it to the <code>select</code> function. Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(t_employee.salary) - <span class="keyword">min</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee</span><br></pre></td></tr></table></figure><p>We can see that the generated SQL is highly corresponding to our Kotlin code. This benefits from Kotlin’s excellent features. Ktorm provides many overloaded operators, that’s why we can use the minus operator in the query above. Because of operator overloading, the minus operator here doesn’t perform an actual subtraction but being translated to a minus operator in SQL and executed in our database. In the section of <a href="./operators.html">Operators</a>, we will learn more about Ktorm’s operators.</p><blockquote><p>Small regret: Although the <code>select</code> function supports complex expressions, the <code>QueryRowSet</code> doesn’t. So while obtaining results from a <code>QueryRowSet</code>, we can not use index access operator <code>[]</code> here. The only thing we can use is <code>getXxx</code> functions extended from <code>ResultSet</code>, obtaining results by labels or column indices.</p></blockquote><h2 id="selectDistinct"><a href="#selectDistinct" class="headerlink" title="selectDistinct"></a>selectDistinct</h2><p><code>selectDistinct</code> is also an extension function of <code>QuerySource</code>. Just as its name implies, it will be translated to a <code>select distinct</code> statement in SQL, and its usage is totally the same with <code>select</code> function, so we won’t repeat it.</p><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p><code>where</code> is also an extension function of <code>Table</code> class, let’s learn its signature first:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> Query.<span class="title">where</span><span class="params">(block: () -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">Boolean</span>&gt;)</span></span>: Query</span><br></pre></td></tr></table></figure><p>It’s an inline function that accepts a parameter of type <code>() -&gt; ColumnDeclaring&lt;Boolean&gt;</code>, which is a closure function that returns a <code>ColumnDeclaring&lt;Boolean&gt;</code> as our filter condition. The <code>where</code> function creates a new <code>Query</code> object with all properties being copied from the current query, but applying a new filter condition, the return value of the closure. Typical usage:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.salary)</span><br><span class="line">    .<span class="keyword">where</span> &#123; (Employees.departmentId eq <span class="number">1</span>) and (Employees.name like <span class="string">"%vince%"</span>) &#125;</span><br></pre></td></tr></table></figure><p>Easy to know that the query obtains the salary of an employee named vince in department 1. The generated SQL is easy too:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.salary <span class="keyword">as</span> t_employee_salary </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">where</span> (t_employee.department_id = ?) <span class="keyword">and</span> (t_employee.name <span class="keyword">like</span> ?)</span><br></pre></td></tr></table></figure><p>We can return any filter conditions in <code>where</code> closure, here we constructed one by operators <code>eq</code>, <code>and</code> and <code>like</code>. Kotlin provides an infix keyword, functions marked with it can be called using the <a href="https://kotlinlang.org/docs/reference/functions.html#infix-notation" target="_blank" rel="noopener">infix notation</a> (omitting the dot and the parentheses for the call), that’s how these operators work.</p><blockquote><p>Ktorm’s built-in operators can be divided into two groups: those that is implemented by operator overloading, such as basic arithmetic operators; and those that is based on infix notations, such as <code>and</code>, <code>or</code>, <code>eq</code>, <code>gt</code>, <code>lt</code>, <code>like</code>, etc.</p></blockquote><p>Sometimes, we need a variable number of filter conditions in our queries, those conditions are combined with <code>and</code> or <code>or</code> operator and each of them can be enabled or disabled depending on different conditions. To meet this requirement, many ORM frameworks provide features like <em>dynamic query</em>, such as the <code>&lt;if&gt;</code> tag of MyBatis. However, this is not a problem at all in Ktorm, because queries in Ktorm are pure Kotlin codes, which is natively <em>dynamic</em>. Let’s learn the query below:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.salary)</span><br><span class="line">    .<span class="keyword">where</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> conditions = ArrayList&lt;ColumnDeclaring&lt;<span class="built_in">Boolean</span>&gt;&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (departmentId != <span class="literal">null</span>) &#123;</span><br><span class="line">            conditions += Employees.departmentId eq departmentId</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (managerId != <span class="literal">null</span>) &#123;</span><br><span class="line">            conditions += Employees.managerId eq managerId</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">            conditions += Employees.name like <span class="string">"%<span class="variable">$name</span>%"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        conditions.reduce &#123; a, b -&gt; a and b &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Here, we create an <code>ArrayList</code> to hold filter conditions first, then add different conditions to the list depending on whether the specific parameters are null or not, finally combine all of them with the <code>and</code> operator. We don’t need to do anything special with Ktorm, and the <em>dynamic query</em> is perfectly supported.</p><p>Obviously, there is a bug in the query above, that the reduce operation may throw an exception if the list is empty, all conditions are not matched. To avoid this exception, we can replace the reduce operation with <code>conditions.combineConditions</code>. This is an extension function provided by Ktorm, it combines all conditions with <code>and</code> operator, otherwise, if the list is empty, true will be returned directly.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Iterable<span class="type">&lt;ColumnDeclaring&lt;Boolean&gt;</span>&gt;.<span class="title">combineConditions</span><span class="params">()</span></span>: ColumnDeclaring&lt;<span class="built_in">Boolean</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.any()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.reduce &#123; a, b -&gt; a and b &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ArgumentExpression(<span class="literal">true</span>, BooleanSqlType)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To be honest, it’s easy to get bored with creating a new <code>ArrayList</code> and adding conditions to it every time. Ktorm provides a convenient function <code>whereWithConditions</code> which can reduce our duplicated codes. With this function, we can modify the query to:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.salary)</span><br><span class="line">    .whereWithConditions &#123;</span><br><span class="line">        <span class="keyword">if</span> (departmentId != <span class="literal">null</span>) &#123;</span><br><span class="line">            it += Employees.departmentId eq departmentId</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (managerId != <span class="literal">null</span>) &#123;</span><br><span class="line">            it += Employees.managerId eq managerId</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="literal">null</span>) &#123;</span><br><span class="line">            it += Employees.name like <span class="string">"%<span class="variable">$name</span>%"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Using <code>whereWithConditins</code>, we just need to add conditions to <code>it</code> which is exactly a <code>MutableList</code>, not needed to create a list and combine the conditions by ourselves anymore. On the other hand, Ktorm also provides a <code>whereWithOrConditions</code> function, which does the same thing as the other, but finally combining conditions with <code>or</code> instead of <code>and</code>.</p><h2 id="groupBy-having"><a href="#groupBy-having" class="headerlink" title="groupBy/having"></a>groupBy/having</h2><p>Both <code>groupBy</code> and <code>having</code> are extension functions for <code>Query</code> class, they provide aggregation support for Ktorm, a usage example is shown below:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = Employees.aliased(<span class="string">"t"</span>)</span><br><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(t)</span><br><span class="line">    .select(t.departmentId, avg(t.salary))</span><br><span class="line">    .groupBy(t.departmentId)</span><br><span class="line">    .having &#123; avg(t.salary) gt <span class="number">100.0</span> &#125;</span><br></pre></td></tr></table></figure><p>This query selects departments whose average salary is greater than 100, then returns the average salaries along with their department’s IDs. The usage is similar to other extension functions like <code>select</code> and <code>where</code>, and the generated SQL is also simple and direct too:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id <span class="keyword">as</span> t_employee_department_id, <span class="keyword">avg</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t_employee.department_id </span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(t_employee.salary) &gt; ?</span><br></pre></td></tr></table></figure><p>Question: what will happen if we just add one column to the query above? Assuming if we want to select the employees’ names additionally:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(t)</span><br><span class="line">    .select(t.departmentId, avg(t.salary), t.name)</span><br><span class="line">    .groupBy(t.departmentId)</span><br><span class="line">    .having &#123; avg(t.salary) gt <span class="number">100.0</span> &#125;</span><br></pre></td></tr></table></figure><p>The generated SQL will be changed to:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id <span class="keyword">as</span> t_employee_department_id, <span class="keyword">avg</span>(t_employee.salary), t_employee.name <span class="keyword">as</span> t_employee_name </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t_employee.department_id </span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(t_employee.salary) &gt; ?</span><br></pre></td></tr></table></figure><p>However, as any SQL users know, the generated SQL is wrong with syntax now, and it’s impossible to be executed in a database. That’s because the SQL’s grammar restricts that if we are using group by, every select column either comes from the group by clause or appears in an aggregation function. So, that’s not Ktorm’s fault, we don’t understand SQL enough, Ktorm just translates our Koltin code to SQL trustily.</p><blockquote><p>Note: Ktorm generates SQLs, but our design goal is never to replace SQL in Kotlin. Ktorm doesn’t mean to be an “automation” ORM framework that’s “large and complete”. Instead, one of our goals is to provide a set of flexible and convenient DSL for SQL by making full use of Kotlin’s excellent features. This requires our users to have a certain understanding of SQL because Ktorm just translates our DSL to SQL trustily, we have to take the responsibility of our SQL’s correctness and performance.</p></blockquote><h2 id="orderBy"><a href="#orderBy" class="headerlink" title="orderBy"></a>orderBy</h2><p><code>orderBy</code> is also an extension function for <code>Query</code> class, it’s corresponding to SQL’s order by keyword, here is its signature:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Query.<span class="title">orderBy</span><span class="params">(<span class="keyword">vararg</span> orders: <span class="type">OrderByExpression</span>)</span></span>: Query</span><br></pre></td></tr></table></figure><p>It can be seen that this function accepts a variable number of <code>OrderByExpression</code>s, that can be created by other two functions, <code>asc</code> and <code>desc</code>, naming by the keywords in SQL:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> ColumnDeclaring<span class="type">&lt;*&gt;</span>.<span class="title">asc</span><span class="params">()</span></span>: OrderByExpression</span><br><span class="line"><span class="function"><span class="keyword">fun</span> ColumnDeclaring<span class="type">&lt;*&gt;</span>.<span class="title">desc</span><span class="params">()</span></span>: OrderByExpression</span><br></pre></td></tr></table></figure><p>Typical usage is shown below. The query obtains all employees’ names, sorting them by their salaries descending:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.name)</span><br><span class="line">    .orderBy(Employees.salary.desc())</span><br></pre></td></tr></table></figure><p>Similar to <code>select</code>, the <code>orderBy</code> function not only supports sorting by normal columns, but complex expressions are also OK. The query below obtains departments’ IDs and their average salaries, and sorting them by their average salaries descending:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = Employees.aliased(<span class="string">"t"</span>)</span><br><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(t)</span><br><span class="line">    .select(t.departmentId, avg(t.salary))</span><br><span class="line">    .groupBy(t.departmentId)</span><br><span class="line">    .orderBy(avg(t.salary).desc())</span><br></pre></td></tr></table></figure><p>Generated SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id <span class="keyword">as</span> t_employee_department_id, <span class="keyword">avg</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t_employee.department_id </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">avg</span>(t_employee.salary) <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>The SQL standard doesn’t say how to implement paging queries, so different databases provide different implementations on that. For example, MySQL uses <code>limit m, n</code> syntax for pagination; PostgreSQL uses <code>limit m offset n</code> syntax; Oracle doesn’t even provide any keyword, we need to limit our pages in where clause by rownum.</p><p>To hide the paging syntax’s differences among databases, Ktorm provides a <code>limit</code> function to support pagination:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Query.<span class="title">limit</span><span class="params">(offset: <span class="type">Int</span>, limit: <span class="type">Int</span>)</span></span>: Query</span><br></pre></td></tr></table></figure><p><code>limit</code> is also an extension function for <code>Query</code> class, it accepts two parameters of int:</p><ul><li>offset: the offset to the first returned record, starts from 0.</li><li>limit: max record numbers returned by the query.</li></ul><p>Here is an example, this query obtains the first employee in the table:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database.from(Employees).select().limit(<span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>When we are using the <code>limit</code> function, Ktorm will generate appropriate SQLs depending on the currently enabled dialect. If we don’t use any dialects, an exception might be thrown:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">org</span><span class="selector-class">.ktorm</span><span class="selector-class">.database</span><span class="selector-class">.DialectFeatureNotSupportedException</span>: <span class="selector-tag">Pagination</span> <span class="selector-tag">is</span> <span class="selector-tag">not</span> <span class="selector-tag">supported</span> <span class="selector-tag">in</span> <span class="selector-tag">Standard</span> <span class="selector-tag">SQL</span>.</span><br></pre></td></tr></table></figure><p>This is OK, the SQL standard doesn’t say how to implement paging queries, so Ktorm is not able to generate the SQL for us. To avoid this exception, do not use <code>limit</code>, or enable a dialect. Refer to later chapters for how to <a href="./dialects-and-native-sql.html#Enable-Dialects">enable dialects</a>.</p><h2 id="union-unionAll"><a href="#union-unionAll" class="headerlink" title="union/unionAll"></a>union/unionAll</h2><p>Ktorm also supports to merge two or more query results, that’s the <code>union</code> and <code>unionAll</code> functions. The <code>union</code> function is corresponding to the union keyword in SQL, removing duplicated rows; The <code>unionAll</code> function is corresponding to the union all keyword, not removing duplicated rows. Here is an example:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(Employees.id)</span><br><span class="line">    .union(</span><br><span class="line">        Departments.select(Departments.id)</span><br><span class="line">    )</span><br><span class="line">    .unionAll(</span><br><span class="line">        Departments.select(Departments.id)</span><br><span class="line">    )</span><br><span class="line">    .orderBy(Employees.id.desc())</span><br></pre></td></tr></table></figure><p>Generated SQL：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">  select t_employee.id <span class="keyword">as</span> t_employee_id </span><br><span class="line">  from t_employee</span><br><span class="line">) union (</span><br><span class="line">  select t_department.id <span class="keyword">as</span> t_department_id </span><br><span class="line">  from t_department</span><br><span class="line">) union all (</span><br><span class="line">  select t_department.id <span class="keyword">as</span> t_department_id </span><br><span class="line">  from t_department</span><br><span class="line">) </span><br><span class="line">order <span class="keyword">by</span> t_employee_id desc</span><br></pre></td></tr></table></figure><h2 id="aliased"><a href="#aliased" class="headerlink" title="aliased"></a>aliased</h2><p>In version 2.6, Ktorm provided a feature of column aliases, which allows us to assign aliases to the selected columns of a query and use them in subsequent clauses such as <code>group by</code> and <code>having</code>, just like the <code>as</code> keyword in SQL. Here is an example. This query selects departments whose average salary is greater than 100, then returns the average salaries along with their department’s IDs.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> deptId = Employees.departmentId.aliased(<span class="string">"dept_id"</span>)</span><br><span class="line"><span class="keyword">val</span> salaryAvg = avg(Employees.salary).aliased(<span class="string">"salary_avg"</span>)</span><br><span class="line"></span><br><span class="line">database</span><br><span class="line">    .from(Employees)</span><br><span class="line">    .select(deptId, salaryAvg)</span><br><span class="line">    .groupBy(deptId)</span><br><span class="line">    .having &#123; salaryAvg gt <span class="number">100.0</span> &#125;</span><br><span class="line">    .forEach &#123; row -&gt;</span><br><span class="line">        println(<span class="string">"<span class="subst">$&#123;row[deptId]&#125;</span>:<span class="subst">$&#123;row[salaryAvg]&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id <span class="keyword">as</span> dept_id, <span class="keyword">avg</span>(t_employee.salary) <span class="keyword">as</span> salary_avg </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_id </span><br><span class="line"><span class="keyword">having</span> salary_avg &gt; ?</span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer" data-reactroot=""><div class="doc-footer-link">Prev Article: <a href="/en/schema-definition.html">Schema Definition</a></div><div class="doc-footer-link">Next Article: <a href="/en/joining.html">Joining</a></div>Any questions about the document? Try searching again on the left menu or <a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank" rel="noopener">Raise an issue on Github</a></div></div></article></div></div><div class="doc-footer">&copy; 2022 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm" target="_blank" rel="noopener">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script><script type="text/javascript" src="/vendors/docsearch@2.6.3/docsearch.min.js"></script><script type="text/javascript">docsearch({appId:"0DGANM0MZ3",apiKey:"071ea85fb6b0933d3f3d3925aa434e23",indexName:"ktorm",inputSelector:"#doc-search-input",algoliaOptions:{facetFilters:["lang:en","tags:doc"]},autocompleteOptions:{hint:!1,appendTo:"body"},debug:!1})</script><script>!function(){$(".kotlin .code .keyword").each(function(){var e=$(this);("where"===e.text()||"set"===e.text())&&e.removeClass("keyword")})}()</script></body></html><!-- rebuild by neat -->