<!-- build time:Sun Jan 01 2023 08:36:38 GMT+0800 (CST) --><!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Ktorm | Sequence Aggregation</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch@2.6.3/docsearch.min.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"Sequence Aggregation",lang:"en",related_path:"zh-cn/sequence-aggregation.html",path:"en/sequence-aggregation.html"},data:{"navigation-zh-cn":{home:[{title:"快速开始",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"概述",type:"link",path:"zh-cn/"},{text:"快速开始",type:"link",path:"zh-cn/quick-start.html"},{text:"连接管理",type:"label"},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html"},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html"},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html"},{text:"查询",type:"link",path:"zh-cn/query.html"},{text:"联表",type:"link",path:"zh-cn/joining.html"},{text:"增删改",type:"link",path:"zh-cn/dml.html"},{text:"运算符",type:"link",path:"zh-cn/operators.html"},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html"},{text:"实体类 API",type:"label"},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html"},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html"},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html"},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html"},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html"},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html"},{text:"支持和反馈",type:"label"},{text:"API 文档",type:"support-link",path:"api-docs/index.html"},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new"},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html"}]},"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"Overview",type:"link",path:"",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!0},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!1},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc",algolia:{appId:"2W81KMSLOD",apiKey:"2a146a809de068d9b7a07ba3fb70b4e5",indexName:"ktorm",chunkSize:5e3,fields:["title","lang","date","updated","_content:truncate,0,5200","path","permalink"]}}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><span class="doc-navbar__logo"><a href="/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="lang-switcher"><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/sequence-aggregation.html">简体中文</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><div class="dc-search-form doc-search-form"><input type="search" id="doc-search-input" class="dc-input dc-search-form__input doc-search-form__input" placeholder="Search documents" autofocus><button class="dc-btn dc-search-form__btn doc-search-form__btn" aria-label="Search"><i class="dc-icon dc-icon--search"></i></button></div></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/" target="_self"><span>Overview</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/quick-start.html" target="_self"><span>Quick Start</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>CONNECTION MANAGEMENT</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/connect-to-databases.html" target="_self"><span>Connect to Databases</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/transaction-management.html" target="_self"><span>Transaction Management</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/spring-support.html" target="_self"><span>Spring Support</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/schema-definition.html" target="_self"><span>Schema Definition</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/query.html" target="_self"><span>Query</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/joining.html" target="_self"><span>Joining</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/dml.html" target="_self"><span>Data Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/operators.html" target="_self"><span>Operators</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/dialects-and-native-sql.html" target="_self"><span>Dialects &amp; Native SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>ENTITY API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entities-and-column-binding.html" target="_self"><span>Entities &amp; Column Binding</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-finding.html" target="_self"><span>Entity Query</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-sequence.html" target="_self"><span>Entity Sequence</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current"><a href="/en/sequence-aggregation.html" target="_self"><span>Sequence Aggregation</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-dml.html" target="_self"><span>Entity Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/define-entities-as-any-kind-of-classes.html" target="_self"><span>Define Entities as Any Class</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SUPPORT &amp; FEEDBACK</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/api-docs/index.html" target="_self"><span>API Documents</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_self"><span>Issue Feedback</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/sponsor.html" target="_self"><span>Sponsor the Project</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher" data-reactroot=""><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/sequence-aggregation.html">简体中文</a></span></span></div><div class="dc-page"><div class="dc-card"><div id="doc-search-results" class="doc-search-results"><div id="doc-search-stats"></div><div id="doc-search-hits"></div><div id="doc-search-pagination"></div></div><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/en/sequence-aggregation.md"><i class="icon fa fa-github"></i> <span class="text">Edit Page</span></a><h1 id="Sequence-Aggregation"><a href="#Sequence-Aggregation" class="headerlink" title="Sequence Aggregation"></a>Sequence Aggregation</h1><p>The entity sequence APIs not only allow us to obtain entities from databases just like using <code>kotlin.sequences</code>, but they also provide rich support for aggregations, so we can conveniently count the columns, sum them, or calculate their averages, etc.</p><h2 id="Simple-Aggregation"><a href="#Simple-Aggregation" class="headerlink" title="Simple Aggregation"></a>Simple Aggregation</h2><p>Let’s learn the definition of the extension function <code>aggregateColumns</code> first:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>, C : Any&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">aggregateColumns</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    aggregationSelector: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">C</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: C?</span><br></pre></td></tr></table></figure><p>It’s a terminal operation, and it accepts a closure as its parameter, in which we need to return an aggregate expression. Ktorm will create an aggregate query, using the current filter condition and selecting the aggregate expression specified by us, then execute the query and obtain the aggregate result. The following code obtains the max salary in department 1:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .aggregateColumns &#123; max(it.salary) &#125;</span><br></pre></td></tr></table></figure><p>If we want to aggregate two or more columns, we just need to wrap our aggregate expressions by <code>tupleOf</code> in the closure, and the function’s return type becomes <code>TupleN&lt;C1?, C2?, .. Cn?&gt;</code>. The example below obtains the average and the range of salaries in department 1:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (avg, diff) = database.employees</span><br><span class="line">    .filter &#123; it.departmentId eq <span class="number">1</span> &#125;</span><br><span class="line">    .aggregateColumns &#123; tupleOf(avg(it.salary), max(it.salary) - min(it.salary)) &#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(t_employee.salary), <span class="keyword">max</span>(t_employee.salary) - <span class="keyword">min</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">where</span> t_employee.department_id = ?</span><br></pre></td></tr></table></figure><blockquote><p>Just like <code>mapColumns</code>, as the return type of <code>tupleOf</code> can be from <code>Tuple2</code> to <code>Tuple9</code>, we are able to aggregate a maximum of nine columns at once with <code>aggregateColumns</code> function.</p></blockquote><p>Additionally, Ktorm also provides many convenient helper functions, they are all implemented based on <code>aggregateColumns</code>. For example, we can use <code>maxBy { it.salary }</code> to obtain the max salary, that’s equivalent to <code>aggregateColumns { max(it.salary) }</code>. Here is a list of these functions:</p><table><thead><tr><th>Name</th><th>Usage Example</th><th>Description</th><th>Quivalent</th></tr></thead><tbody><tr><td>count</td><td><code>count { it.salary gt 1000 }</code></td><td>Count those whose salary greater than 1000</td><td><code>filter { it.salary gt 1000 }</code><br><code>.aggregateColumns { count() }</code></td></tr><tr><td>any</td><td><code>any { it.salary gt 1000 }</code></td><td>True if any one’s salary greater than 1000</td><td><code>count { it.salary gt 1000 } &gt; 0</code></td></tr><tr><td>none</td><td><code>none { it.salary gt 1000 }</code></td><td>True if no one’s salary greater than 1000</td><td><code>count { it.salary gt 1000 } == 0</code></td></tr><tr><td>all</td><td><code>all { it.salary gt 1000 }</code></td><td>True if everyone’s salary greater than 1000</td><td><code>count { it.salary lte 1000 } == 0</code></td></tr><tr><td>sumBy</td><td><code>sumBy { it.salary }</code></td><td>Obtain the salaries’ sum</td><td><code>aggregateColumns { sum(it.salary) }</code></td></tr><tr><td>maxBy</td><td><code>maxBy { it.salary }</code></td><td>Obtain the salaries’ max value</td><td><code>aggregateColumns { max(it.salary) }</code></td></tr><tr><td>minBy</td><td><code>minBy { it.salary }</code></td><td>Obtain the salaries’ min value</td><td><code>aggregateColumns { min(it.salary) }</code></td></tr><tr><td>averageBy</td><td><code>averageBy { it.salary }</code></td><td>Obtain the average salary</td><td><code>aggregateColumns { avg(it.salary) }</code></td></tr></tbody></table><h2 id="Grouping-Aggregation"><a href="#Grouping-Aggregation" class="headerlink" title="Grouping Aggregation"></a>Grouping Aggregation</h2><p>To use grouping aggregations, we need to learn how to group elements in an entity sequence first. Ktorm provides two different grouping functions, they are <code>groupBy</code> and <code>groupingBy</code>.</p><h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, K&gt;</span> EntitySequence<span class="type">&lt;E, *&gt;</span>.<span class="title">groupBy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    keySelector: (<span class="type">E</span>) -&gt; <span class="type">K</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Map&lt;K, List&lt;E&gt;&gt;</span><br></pre></td></tr></table></figure><p>Obviously, <code>groupBy</code> is a terminal operation, it will execute the internal query and iterate the query results right now, then extract a grouping key by the <code>keySelector</code> closure for each element, finally collect them into the groups they are belonging to. The following code obtains all the employees and groups them by their departments:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> employees = database.employees.groupBy &#123; it.department.id &#125;</span><br></pre></td></tr></table></figure><p>Here, the type of <code>employees</code> is <code>Map&lt;Int, List&lt;Employee&gt;&gt;</code>, in which the keys are departments’ IDs, and the values are the lists of employees belonging to the departments. Now we have the employees’ data for every department, we are able to do some aggregate calculations over the data. The following code calculates the average salaries for each department:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageSalaries = database.employees</span><br><span class="line">    .groupBy &#123; it.department.id &#125;</span><br><span class="line">    .mapValues &#123; (_, employees) -&gt; employees.map &#123; it.salary &#125;.average() &#125;</span><br></pre></td></tr></table></figure><p>But, unfortunately, the aggregate calculation here is performed inside the JVM, and the generated SQL still obtains all the employees, although we don’t really need them:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * </span><br><span class="line"><span class="keyword">from</span> t_employee</span><br></pre></td></tr></table></figure><p>Here, the only thing we need is the average salaries, but we still have to obtain all the employees’ data from the database. The performance issue may be intolerable in most cases. It’ll be better for us to generate proper SQLs using <em>group by</em> clauses and aggregate functions, and move the aggregate calculations back to the database. To solve this problem, we need to use the <code>groupingBy</code> function.</p><blockquote><p>Note that these two functions are design for very different purposes. The <code>groupBy</code> is a terminal operation, as it’ll obtain all the entity objects and divide them into groups inside the JVM memory; However, the <code>groupingBy</code> is an intermediate operation, it’ll add a <em>group by</em> clause to the final generated SQL, and particular aggregations should be specified using the following extension functions of <code>EntityGrouping</code>.</p></blockquote><h3 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>, K : Any&gt; EntitySequence<span class="type">&lt;E, T&gt;</span>.<span class="title">groupingBy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    keySelector: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">K</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: EntityGrouping&lt;E, T, K&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> EntityGrouping(<span class="keyword">this</span>, keySelector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>groupingBy</code> function is an intermediate operation, and it accepts a closure as its parameter, in which we should return a <code>ColumnDeclaring&lt;K&gt;</code> as the grouping key. The grouping key can be a column or expression, and it’ll be used in the SQL’s <em>group by</em> clause. Actually, the <code>groupingBy</code> function doesn’t do anything, it just returns a new-created <code>EntityGrouping</code> with the <code>keySelector</code> given by us. The definition of <code>EntityGrouping</code> is simple:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityGrouping</span>&lt;<span class="type">E : Any, T : BaseTable&lt;E</span>&gt;, <span class="type">K : Any&gt;</span></span>(</span><br><span class="line">    <span class="keyword">val</span> sequence: EntitySequence&lt;E, T&gt;,</span><br><span class="line">    <span class="keyword">val</span> keySelector: (T) -&gt; ColumnDeclaring&lt;K&gt;</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">asKotlinGrouping</span><span class="params">()</span></span>: kotlin.collections.Grouping&lt;E, K?&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Most of the <code>EntityGrouping</code>‘s APIs are provided as extension functions. Let’s learn the <code>aggregateColumns</code> first:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;E : Any, T : BaseTable&lt;E&gt;</span>, K : Any, C : Any&gt; EntityGrouping<span class="type">&lt;E, T, K&gt;</span>.<span class="title">aggregateColumns</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    aggregationSelector: (<span class="type">T</span>) -&gt; <span class="type">ColumnDeclaring</span>&lt;<span class="type">C</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Map&lt;K?, C?&gt;</span><br></pre></td></tr></table></figure><p>Similar to the <code>aggregateColumns</code> of <code>EntitySequence</code>, it’s a terminal operation, and it accepts a closure as its parameter, in which we should return an aggregate expression. Ktorm will create an aggregate query, using the current filter condition and the grouping key, selecting the aggregate expression specified by us, then execute the query and obtain the aggregate results. Its return type is <code>Map&lt;K?, C?&gt;</code>, in which the keys are our grouping keys, and the values are the aggregate results for the groups. The following code obtains the average salaries for each department:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .aggregateColumns &#123; avg(it.salary) &#125;</span><br></pre></td></tr></table></figure><p>Now we can see that the generated SQL uses a <em>group by</em> clause and do the aggregation inside the database:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id, <span class="keyword">avg</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t_employee.department_id</span><br></pre></td></tr></table></figure><p>If we want to aggregate two or more columns, we just need to wrap our aggregate expressions by <code>tupleOf</code> in the closure, and the function’s return type becomes <code>Map&lt;K?, TupleN&lt;C1?, C2?, .. Cn?&gt;&gt;</code>. The following code prints the averages and the ranges of salaries for each department:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .aggregateColumns &#123; tupleOf(avg(it.salary), max(it.salary) - min(it.salary)) &#125;</span><br><span class="line">    .forEach &#123; departmentId, (avg, diff) -&gt;</span><br><span class="line">        println(<span class="string">"<span class="variable">$departmentId</span>:<span class="variable">$avg</span>:<span class="variable">$diff</span>"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Generated SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t_employee.department_id, <span class="keyword">avg</span>(t_employee.salary), <span class="keyword">max</span>(t_employee.salary) - <span class="keyword">min</span>(t_employee.salary) </span><br><span class="line"><span class="keyword">from</span> t_employee </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t_employee.department_id</span><br></pre></td></tr></table></figure><p>Additionally, Ktorm also provides many convenient helper functions, they are all implemented based on <code>aggregateColumns</code>. Here is a list of them:</p><table><thead><tr><th>Name</th><th>Usage Example</th><th>Description</th><th>Equivalent</th></tr></thead><tbody><tr><td>eachCount(To)</td><td><code>eachCount()</code></td><td>Obtain record counts for each group</td><td><code>aggregateColumns { count() }</code></td></tr><tr><td>eachSumBy(To)</td><td><code>eachSumBy { it.salary }</code></td><td>Obtain salaries’s sums for each group</td><td><code>aggregateColumns { sum(it.salary) }</code></td></tr><tr><td>eachMaxBy(To)</td><td><code>eachMaxBy { it.salary }</code></td><td>Obtain salaries’ max values for each group</td><td><code>aggregateColumns { max(it.salary) }</code></td></tr><tr><td>eachMinBy(To)</td><td><code>eachMinBy { it.salary }</code></td><td>Obtain salaries’ min values for each group</td><td><code>aggregateColumns { min(it.salary) }</code></td></tr><tr><td>eachAverageBy(To)</td><td><code>eachAverageBy { it.salary }</code></td><td>Obtain salaries’ averages for each group</td><td><code>aggregateColumns { avg(it.salary) }</code></td></tr></tbody></table><p>With these functions, we can write the code below to obtain average salaries for each department:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> averageSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .eachAverageBy &#123; it.salary &#125;</span><br></pre></td></tr></table></figure><p>Besides, Ktorm also provides <code>aggregate</code>, <code>fold</code>, <code>reduce</code>, they have the same names as the extension functions of <code>kotlin.collections.Grouping</code>, and the usages are totally the same. The following code calculates the total salaries for each department:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> totalSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .fold(<span class="number">0L</span>) &#123; acc, employee -&gt; </span><br><span class="line">        acc + employee.salary </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Of course, if only the total salaries are needed, we don’t have to write codes in that way. Because the performance is really poor, as all employees are obtained from the database. Here we just show you the usage of the <code>fold</code> function. It’s better to use <code>eachSumBy</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> totalSalaries = database.employees</span><br><span class="line">    .groupingBy &#123; it.departmentId &#125;</span><br><span class="line">    .eachSumBy &#123; it.salary &#125;</span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer" data-reactroot=""><div class="doc-footer-link">Prev Article: <a href="/en/entity-sequence.html">Entity Sequence</a></div><div class="doc-footer-link">Next Article: <a href="/en/entity-dml.html">Entity Manipulation</a></div>Any questions about the document? Try searching again on the left menu or <a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank" rel="noopener">Raise an issue on Github</a></div></div></article></div></div><div class="doc-footer">&copy; 2023 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm" target="_blank" rel="noopener">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script><script type="text/javascript" src="/vendors/docsearch@2.6.3/docsearch.min.js"></script><script type="text/javascript">docsearch({appId:"0DGANM0MZ3",apiKey:"071ea85fb6b0933d3f3d3925aa434e23",indexName:"ktorm",inputSelector:"#doc-search-input",algoliaOptions:{facetFilters:["lang:en","tags:doc"]},autocompleteOptions:{hint:!1,appendTo:"body"},debug:!1})</script><script>!function(){$(".kotlin .code .keyword").each(function(){var e=$(this);("where"===e.text()||"set"===e.text())&&e.removeClass("keyword")})}()</script></body></html><!-- rebuild by neat -->