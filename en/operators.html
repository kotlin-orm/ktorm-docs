<!-- build time:Mon Jan 01 2024 19:39:07 GMT+0800 (CST) --><!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Ktorm | Operators</title><meta name="keywords" content="Kotlin, ORM, SQL, DSL, sequence"><meta name="description" content=""><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="referrer" content="always"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet"><link href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/vendors/docsearch@2.6.3/docsearch.min.css" rel="stylesheet"><link href="/style/doc.css" rel="stylesheet"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"></head><body><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-180275463-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript">window.__INITIAL_STATE__={page:{title:"Operators",lang:"en",related_path:"zh-cn/operators.html",path:"en/operators.html"},data:{"navigation-zh-cn":{home:[{title:"快速开始",link:"zh-cn/quick-start.html",color:"purple",icon:"flash",description:"快速配置 Ktorm 并开始使用"},{title:"SQL DSL",link:"zh-cn/query.html",color:"blue",icon:"code",description:'<a href="/zh-cn/schema-definition.html">定义表结构</a>，使用强类型的灵活的<a href="/zh-cn/query.html">查询 DSL</a>'},{title:"实体序列",link:"zh-cn/entity-sequence.html",color:"green",icon:"line-chart",description:'<a href="/zh-cn/entities-and-column-binding.html">配置列绑定</a>，使用<a href="/zh-cn/entity-sequence.html">序列 API</a> 获取实体对象'},{title:"API 文档",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"查看 Ktorm 中类与函数的 API 文档"}],main:[{text:"概述",type:"link",path:"zh-cn/"},{text:"快速开始",type:"link",path:"zh-cn/quick-start.html"},{text:"连接管理",type:"label"},{text:"连接数据库",type:"link",path:"zh-cn/connect-to-databases.html"},{text:"事务管理",type:"link",path:"zh-cn/transaction-management.html"},{text:"Spring 支持",type:"link",path:"zh-cn/spring-support.html"},{text:"SQL DSL",type:"label"},{text:"定义表结构",type:"link",path:"zh-cn/schema-definition.html"},{text:"查询",type:"link",path:"zh-cn/query.html"},{text:"联表",type:"link",path:"zh-cn/joining.html"},{text:"增删改",type:"link",path:"zh-cn/dml.html"},{text:"运算符",type:"link",path:"zh-cn/operators.html"},{text:"方言与原生 SQL",type:"link",path:"zh-cn/dialects-and-native-sql.html"},{text:"实体类 API",type:"label"},{text:"实体类与列绑定",type:"link",path:"zh-cn/entities-and-column-binding.html"},{text:"实体查询",type:"link",path:"zh-cn/entity-finding.html"},{text:"实体序列",type:"link",path:"zh-cn/entity-sequence.html"},{text:"序列聚合",type:"link",path:"zh-cn/sequence-aggregation.html"},{text:"实体增删改",type:"link",path:"zh-cn/entity-dml.html"},{text:"使用任意的类作为实体类",type:"link",path:"zh-cn/define-entities-as-any-kind-of-classes.html"},{text:"支持和反馈",type:"label"},{text:"API 文档",type:"support-link",path:"api-docs/index.html"},{text:"问题反馈",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new"},{text:"打赏作者",type:"support-link",path:"zh-cn/sponsor.html"}]},"navigation-en":{home:[{title:"Quick Start",link:"en/quick-start.html",color:"purple",icon:"flash",description:"Setting up Ktorm and starting up."},{title:"SQL DSL",link:"en/query.html",color:"blue",icon:"code",description:'Use the strong-typed and flexible <a href="/en/query.html">query DSL</a> after <a href="/en/schema-definition.html">defining table schemas</a>.'},{title:"Entity Sequence",link:"en/entity-sequence.html",color:"green",icon:"line-chart",description:'Obtain entities via <a href="/en/entity-sequence.html">sequence APIs</a> after <a href="/en/entities-and-column-binding.html">column bindings</a> configured.'},{title:"API Documents",link:"api-docs/index.html",color:"red",icon:"paperclip",description:"API documents for Ktorm's classes and functions."}],main:[{text:"Overview",type:"link",path:"",isCurrent:!1},{text:"Quick Start",type:"link",path:"en/quick-start.html",isCurrent:!1},{text:"CONNECTION MANAGEMENT",type:"label",isCurrent:!1},{text:"Connect to Databases",type:"link",path:"en/connect-to-databases.html",isCurrent:!1},{text:"Transaction Management",type:"link",path:"en/transaction-management.html",isCurrent:!1},{text:"Spring Support",type:"link",path:"en/spring-support.html",isCurrent:!1},{text:"SQL DSL",type:"label",isCurrent:!1},{text:"Schema Definition",type:"link",path:"en/schema-definition.html",isCurrent:!1},{text:"Query",type:"link",path:"en/query.html",isCurrent:!1},{text:"Joining",type:"link",path:"en/joining.html",isCurrent:!1},{text:"Data Manipulation",type:"link",path:"en/dml.html",isCurrent:!1},{text:"Operators",type:"link",path:"en/operators.html",isCurrent:!1},{text:"Dialects & Native SQL",type:"link",path:"en/dialects-and-native-sql.html",isCurrent:!1},{text:"ENTITY API",type:"label",isCurrent:!1},{text:"Entities & Column Binding",type:"link",path:"en/entities-and-column-binding.html",isCurrent:!1},{text:"Entity Query",type:"link",path:"en/entity-finding.html",isCurrent:!1},{text:"Entity Sequence",type:"link",path:"en/entity-sequence.html",isCurrent:!0},{text:"Sequence Aggregation",type:"link",path:"en/sequence-aggregation.html",isCurrent:!1},{text:"Entity Manipulation",type:"link",path:"en/entity-dml.html",isCurrent:!1},{text:"Define Entities as Any Class",type:"link",path:"en/define-entities-as-any-kind-of-classes.html",isCurrent:!1},{text:"SUPPORT & FEEDBACK",type:"label",isCurrent:!1},{text:"API Documents",type:"support-link",path:"api-docs/index.html",isCurrent:!1},{text:"Issue Feedback",type:"support-link",path:"https://github.com/kotlin-orm/ktorm/issues/new",isCurrent:!1},{text:"Sponsor the Project",type:"support-link",path:"en/sponsor.html",isCurrent:!1}]}},config:{timezone:null,root:"/",time_format:"HH:mm:ss",theme:"doc",algolia:{appId:"2W81KMSLOD",apiKey:"2a146a809de068d9b7a07ba3fb70b4e5",indexName:"ktorm",chunkSize:5e3,fields:["title","lang","date","updated","_content:truncate,0,5200","path","permalink"]}}},window.localStorage&&"true"===window.localStorage.getItem("navigation_collapsed")&&document.getElementsByTagName("body")[0].classList.add("doc-navigation--is-collapsed")</script><div id="navigation-container"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><span class="doc-navbar__logo"><a href="/"><img src="/images/logo.png" class="doc-navbar__logo__img"><img src="/images/logo-middle.png" class="doc-navbar__logo__img-full"></a></span><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i><span class="lang-switcher"><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/operators.html">简体中文</a></span></span></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"><div class="dc-search-form doc-search-form"><input type="search" id="doc-search-input" class="dc-input dc-search-form__input doc-search-form__input" placeholder="Search documents" autofocus><button class="dc-btn dc-search-form__btn doc-search-form__btn" aria-label="Search"><i class="dc-icon dc-icon--search"></i></button></div></div><ul class="doc-sidebar-list"><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/" target="_self"><span>Overview</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/quick-start.html" target="_self"><span>Quick Start</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>CONNECTION MANAGEMENT</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/connect-to-databases.html" target="_self"><span>Connect to Databases</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/transaction-management.html" target="_self"><span>Transaction Management</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/spring-support.html" target="_self"><span>Spring Support</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SQL DSL</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/schema-definition.html" target="_self"><span>Schema Definition</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/query.html" target="_self"><span>Query</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/joining.html" target="_self"><span>Joining</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/dml.html" target="_self"><span>Data Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link doc-sidebar-list__item--current"><a href="/en/operators.html" target="_self"><span>Operators</span></a><ul class="doc-sidebar-list__toc-list"></ul></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/dialects-and-native-sql.html" target="_self"><span>Dialects &amp; Native SQL</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>ENTITY API</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entities-and-column-binding.html" target="_self"><span>Entities &amp; Column Binding</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-finding.html" target="_self"><span>Entity Query</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-sequence.html" target="_self"><span>Entity Sequence</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/sequence-aggregation.html" target="_self"><span>Sequence Aggregation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/entity-dml.html" target="_self"><span>Entity Manipulation</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/define-entities-as-any-kind-of-classes.html" target="_self"><span>Define Entities as Any Class</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--label"><span>SUPPORT &amp; FEEDBACK</span></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/api-docs/index.html" target="_self"><span>API Documents</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_self"><span>Issue Feedback</span></a></li><li class="doc-sidebar-list__item doc-sidebar-list__item--link"><a href="/en/sponsor.html" target="_self"><span>Sponsor the Project</span></a></li></ul></div></nav></div></div><div class="doc-content"><div id="lang-switcher-container" class="lang-switcher-container"><span class="lang-switcher" data-reactroot=""><span><img src="/images/us.png"><span>English</span></span><span class="lang-divider"> | </span><span><img src="/images/cn.png"><a href="/zh-cn/operators.html">简体中文</a></span></span></div><div class="dc-page"><div class="dc-card"><div id="doc-search-results" class="doc-search-results"><div id="doc-search-stats"></div><div id="doc-search-hits"></div><div id="doc-search-pagination"></div></div><article id="page-content" class="doc-formatting"><a class="page-link-to-github" target="_blank" href="https://github.com/kotlin-orm/ktorm-docs/edit/master/source/en/operators.md"><i class="icon fa fa-github"></i> <span class="text">Edit Page</span></a><h1 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h1><p>In the former sections, we have had some knowledge about Ktorm’s operators. Now let’s introduce them more detailed.</p><h2 id="Built-in-Operators"><a href="#Built-in-Operators" class="headerlink" title="Built-in Operators"></a>Built-in Operators</h2><p>Any operator in Ktorm is a Kotlin function that returns a <code>SqlExpression</code>. Here is a list of built-in operators that Ktorm supports now:</p><table><thead><tr><th>Kotlin Function Name</th><th>SQL Keyword/Operator</th><th>Usage</th></tr></thead><tbody><tr><td>isNull</td><td>is null</td><td>Ktorm: Employees.name.isNull()<br>SQL: t_employee.name is null</td></tr><tr><td>isNotNull</td><td>is not null</td><td>Ktorm: Employees.name.isNotNull()<br>SQL: t_employee.name is not null</td></tr><tr><td>unaryMinus (-)</td><td>-</td><td>Ktorm: -Employees.salary<br>SQL: -t_employee.salary</td></tr><tr><td>unaryPlus (+)</td><td>+</td><td>Ktorm: +Employees.salary<br>SQL: +t_employee.salary</td></tr><tr><td>not (!)</td><td>not</td><td>Ktorm: !Employees.name.isNull()<br>SQL: not (t_employee.name is null)</td></tr><tr><td>plus (+)</td><td>+</td><td>Ktorm: Employees.salary + Employees.salary<br>SQL: t_employee.salary + t_employee.salary</td></tr><tr><td>minus (-)</td><td>-</td><td>Ktorm: Employees.salary - Employees.salary<br>SQL: t_employee.salary - t_employee.salary</td></tr><tr><td>times (*)</td><td>*</td><td>Ktorm: Employees.salary * 2<br>SQL: t_employee.salary * 2</td></tr><tr><td>div (/)</td><td>/</td><td>Ktorm: Employees.salary / 2<br>SQL: t_employee.salary / 2</td></tr><tr><td>rem (%)</td><td>%</td><td>Ktorm: Employees.id % 2<br>SQL: t_employee.id % 2</td></tr><tr><td>like</td><td>like</td><td>Ktorm: Employees.name like “vince”<br>SQL: t_employee.name like ‘vince’</td></tr><tr><td>notLike</td><td>not like</td><td>Ktorm: Employees.name notLike “vince”<br>SQL: t_employee.name not like ‘vince’</td></tr><tr><td>and</td><td>and</td><td>Ktorm: Employees.name.isNotNull() and (Employees.name like “vince”)<br>SQL: t_employee.name is not null and t_employee.name like ‘vince’</td></tr><tr><td>or</td><td>or</td><td>Ktorm: Employees.name.isNull() or (Employees.name notLike “vince”)<br>SQL: t_employee.name is null or t_employee.name not like ‘vince’</td></tr><tr><td>xor</td><td>xor</td><td>Ktorm: Employees.name.isNotNull() xor (Employees.name notLike “vince”)<br>SQL: t_employee.name is not null xor t_employee.name not like ‘vince’</td></tr><tr><td>lt / less</td><td>&lt;</td><td>Ktorm: Employees.salary lt 1000<br>SQL: t_employee.salary &lt; 1000</td></tr><tr><td>lte / lessEq</td><td>&lt;=</td><td>Ktorm: Employees.salary lte 1000<br>SQL: t_employee.salary &lt;= 1000</td></tr><tr><td>gt / greater</td><td>&gt;</td><td>Ktorm: Employees.salary gt 1000<br>SQL: t_employee.salary &gt; 1000</td></tr><tr><td>gte / greaterEq</td><td>&gt;=</td><td>Ktorm: Employees.salary gte 1000<br>SQL: t_employee.salary &gt;= 1000</td></tr><tr><td>eq</td><td>=</td><td>Ktorm: Employees.id eq 1<br>SQL: t_employee.id = 1</td></tr><tr><td>neq / notEq</td><td>&lt;&gt;</td><td>Ktorm: Employees.id neq 1<br>SQL: t_employee.id &lt;&gt; 1</td></tr><tr><td>between</td><td>between</td><td>Ktorm: Employees.id between 1..3<br>SQL: t_employee.id between 1 and 3</td></tr><tr><td>notBetween</td><td>not between</td><td>Ktorm: Employees.id notBetween 1..3<br>SQL: t_employee.id not between 1 and 3</td></tr><tr><td>inList</td><td>in</td><td>Ktorm: Employees.departmentId.inList(1, 2, 3)<br>SQL: t_employee.department_id in (1, 2, 3)</td></tr><tr><td>notInList</td><td>not in</td><td>Ktorm: Employees.departmentId notInList db.from(Departments).selectDistinct(Departments.id)<br>SQL: t_employee.department_id not in (select distinct t_department.id from t_department)</td></tr><tr><td>exists</td><td>exists</td><td>Ktorm: exists(db.from(Employees).select())<br>SQL: exists (select * from t_employee)</td></tr><tr><td>notExists</td><td>not exists</td><td>Ktorm: notExists(db.from(Employees).select())<br>SQL: not exists (select * from t_employee)</td></tr></tbody></table><p>These operators can be divided into two groups by the implementation way:</p><p><strong>Overloaded Kotlin built-in operators:</strong> This group of operators are generally used to implement basic arithmetic operators (such as plus, minus, times, etc). Because of operator overloading, they are used just like real arithmetic performs, for example, <code>Employees.salary + 1000</code>. But actually, they just create SQL expressions instead, those expressions will be translated into the corresponding operators in SQL by <code>SqlFormatter</code>. Here is the implementation of the plus operator, we can see that it just creates a <code>BinaryExpression&lt;T&gt;</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Number&gt;</span> ColumnDeclaring<span class="type">&lt;T&gt;</span>.<span class="title">plus</span><span class="params">(expr: <span class="type">ColumnDeclaring</span>&lt;<span class="type">T</span>&gt;)</span></span>: BinaryExpression&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> BinaryExpression(BinaryExpressionType.PLUS, asExpression(), expr.asExpression(), sqlType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Normal operator functions:</strong> There are many limits overloading Kotlin’s built-in operators. For example, the <code>equals</code> function is restricted to return <code>Boolean</code> values only, but Ktorm’s operator functions need to return SQL expressions, so Ktorm provides another function <code>eq</code> for us to implement equality comparisons. Additionally, there are also many operators that don’t exist in Kotlin, such as <code>like</code>, Ktorm provides a <code>like</code> function for string matching in SQL. Here is the implementation of the <code>like</code> function, and this kind of functions are generally marked with an infix keyword:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> ColumnDeclaring<span class="type">&lt;*&gt;</span>.<span class="title">like</span><span class="params">(argument: <span class="type">String</span>)</span></span>: BinaryExpression&lt;<span class="built_in">Boolean</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> BinaryExpression(</span><br><span class="line">        type = BinaryExpressionType.LIKE, </span><br><span class="line">        left = asExpression(), </span><br><span class="line">        right = ArgumentExpression(argument, VarcharSqlType), </span><br><span class="line">        sqlType = BooleanSqlType</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Operator-Precedence"><a href="#Operator-Precedence" class="headerlink" title="Operator Precedence"></a>Operator Precedence</h2><p>Operators can be used continuously, but if we use different operators together, we will meet the problem of their precedence. There can be many operators in an expression, different combination order of operators can lead to different results and even errors. Only if the operators are combined in a certain order, the expression’s result can be correct and unique.</p><p>For instance, in the expression 1 + 2 * 3, the multiplication’s precedence is higher than plus, so 2 * 3 is combined first, the result is 7; If we ignore the precedence of operators, then 1 + 2 is combined first, the result will be 9, which is absolutely wrong. Normally, the precedence of multiplicative operators is higher than additive operators’, the precedence of conjunctions are higher than disjunctions’. But there are a little difference in Ktorm.</p><p>For overloaded Kotlin built-in operators, their precedence follows the specification of Kotlin language. Such as the expression <code>Employees.salary + 1000 * 2</code>, the multiplication’s precedence is higher, so the final translated SQL is <code>t_employee.salary + 2000</code>.</p><p><strong>However, for normal operator functions, there is no such thing as precedence.</strong> In the level of Kotlin language, they are all normal function callings, so they just need to be combined sequentially, and that is quite counterintuitive for us. For example, in the expression <code>a or b and c</code>, the <code>or</code> and <code>and</code> are both operator functions. Intuitively, the precedence of <code>and</code> is higher, so it should be combined first, but actually, they are both normal functions, so our intuition is wrong. If we don’t have a clear understanding on this, some unexpected bugs may occur, to solve the problem, we can use brackets if needed, eg. <code>a or (b and c)</code>.</p><p>For detailed precedence in Kotlin language, please refer to <a href="https://kotlinlang.org/docs/reference/grammar.html#expressions" target="_blank" rel="noopener">Kotlin Reference</a>.</p><h2 id="Custom-Operators"><a href="#Custom-Operators" class="headerlink" title="Custom Operators"></a>Custom Operators</h2><p>We’ve talked about the built-in operators provided by Ktorm’s core module, they provided supports for operators in standard SQL, but what if we want to use some special operators provided by a special database? Let’s take PostgreSQL’s <code>ilike</code> operator as an example, learning how to extend our custom operators with Ktorm.</p><p><code>ilike</code> is a special operator in PostgreSQL. Similar to <code>like</code>, it also matches strings, but ignoring cases. Firstly, we create an expression type extending from <code>ScalarExpression&lt;Boolean&gt;</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ILikeExpression</span></span>(</span><br><span class="line">    <span class="keyword">val</span> left: ScalarExpression&lt;*&gt;,</span><br><span class="line">    <span class="keyword">val</span> right: ScalarExpression&lt;*&gt;,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> sqlType: SqlType&lt;<span class="built_in">Boolean</span>&gt; = BooleanSqlType,</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> isLeafNode: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">) : ScalarExpression&lt;<span class="built_in">Boolean</span>&gt;()</span><br></pre></td></tr></table></figure><p>Having the expression type, we also need an extension function to create expression instances conveniently, that’s the operator function. We mark this function with an infix keyword, so it can be used just like a real operator in SQL:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> ColumnDeclaring<span class="type">&lt;*&gt;</span>.<span class="title">ilike</span><span class="params">(argument: <span class="type">String</span>)</span></span>: ILikeExpression &#123;</span><br><span class="line">    <span class="keyword">return</span> ILikeExpression(asExpression(), ArgumentExpression(argument, VarcharSqlType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now we can use this operator function, just like other operators. But Ktorm cannot recognize our custom expression type <code>ILikeExpression</code> by default and are not able to generate SQLs correctly. So we can extend the <code>SqlFormatter</code> class, override the <code>visitUnknown</code> function, detect our custom expression types and generate proper SQLs:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSqlFormatter</span></span>(database: Database, beautifySql: <span class="built_in">Boolean</span>, indentSize: <span class="built_in">Int</span>)</span><br><span class="line">    : PostgreSqlFormatter(database, beautifySql, indentSize) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitUnknown</span><span class="params">(expr: <span class="type">SqlExpression</span>)</span></span>: SqlExpression &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr <span class="keyword">is</span> ILikeExpression) &#123;</span><br><span class="line">            <span class="keyword">if</span> (expr.left.removeBrackets) &#123;</span><br><span class="line">                visit(expr.left)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                write(<span class="string">"("</span>)</span><br><span class="line">                visit(expr.left)</span><br><span class="line">                removeLastBlank()</span><br><span class="line">                write(<span class="string">") "</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            write(<span class="string">"ilike "</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (expr.right.removeBrackets) &#123;</span><br><span class="line">                visit(expr.right)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                write(<span class="string">"("</span>)</span><br><span class="line">                visit(expr.right)</span><br><span class="line">                removeLastBlank()</span><br><span class="line">                write(<span class="string">") "</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> expr</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.visitUnknown(expr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Finally, register this custom SQL formatter into the <code>Database</code> object by dialect support. Refer to the later chapters for more details about <a href="./dialects-and-native-sql.html">dialects</a>.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> database = Database.connect(</span><br><span class="line">    url = <span class="string">"jdbc:postgresql://localhost:5432/ktorm"</span>,</span><br><span class="line">    dialect = <span class="keyword">object</span> : SqlDialect &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createSqlFormatter</span><span class="params">(database: <span class="type">Database</span>, beautifySql: <span class="type">Boolean</span>, indentSize: <span class="type">Int</span>)</span></span>: SqlFormatter &#123;</span><br><span class="line">            <span class="keyword">return</span> CustomSqlFormatter(database, beautifySql, indentSize)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>All done! The usage of <code>ilike</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> query = database.from(Employees).select().<span class="keyword">where</span> &#123; Employees.name ilike <span class="string">"VINCE"</span> &#125;</span><br></pre></td></tr></table></figure><p>In this way, Ktorm supports <code>ilike</code> operator now. Actually, this is one of the features of ktorm-support-postgresql module, if you really need to use <code>ilike</code>, you don’t have to repeat the code above, please add the dependency to your project.</p><p>Maven dependency:</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ktorm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ktorm-support-postgresql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;ktorm.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Or Gradle:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">"org.ktorm:ktorm-support-postgresql:$&#123;ktorm.version&#125;"</span></span><br></pre></td></tr></table></figure><div id="support-footer-container"><div class="doc-support-footer" data-reactroot=""><div class="doc-footer-link">Prev Article: <a href="/en/dml.html">Data Manipulation</a></div><div class="doc-footer-link">Next Article: <a href="/en/dialects-and-native-sql.html">Dialects &amp; Native SQL</a></div>Any questions about the document? Try searching again on the left menu or <a href="https://github.com/kotlin-orm/ktorm/issues/new" target="_blank" rel="noopener">Raise an issue on Github</a></div></div></article></div></div><div class="doc-footer">&copy; 2024 KTORM.ORG. Licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">Apache 2.0</a><br>Hosted by <a href="https://github.com/kotlin-orm/ktorm" target="_blank" rel="noopener">GitHub</a> <a href="https://github.com/kotlin-orm/ktorm/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/kotlin-orm/ktorm.svg?style=social" alt="Stars"></a></div></div><script src="/vendors/jquery@3.2.1/jquery.min.js"></script><script src="/script/doc.js"></script><script type="text/javascript" src="/vendors/docsearch@2.6.3/docsearch.min.js"></script><script type="text/javascript">docsearch({appId:"0DGANM0MZ3",apiKey:"071ea85fb6b0933d3f3d3925aa434e23",indexName:"ktorm",inputSelector:"#doc-search-input",algoliaOptions:{facetFilters:["lang:en","tags:doc"]},autocompleteOptions:{hint:!1,appendTo:"body"},debug:!1})</script><script>!function(){$(".kotlin .code .keyword").each(function(){var e=$(this);("where"===e.text()||"set"===e.text())&&e.removeClass("keyword")})}()</script></body></html><!-- rebuild by neat -->